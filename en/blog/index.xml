<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>TECH-NI Blog</title>
		<link>http://tech.nitoyon.com/en/blog/index.xml</link>
		<description>All Technology is Boiled in This Site.</description>
		<language>en</language>
		<copyright>Copyright nitoyon.</copyright>
		<lastBuildDate>Sun, 24 Mar 2013 22:26:42 +0000</lastBuildDate>
		<docs>http://blogs.law.harvard.edu/tech/rss</docs>
		<atom:link href="http://tech.nitoyon.com/en/blog/index.xml" rel="self" type="application/rss+xml" />









		<item>
			<title>LiveReloadX 0.2.0 Released: try include/exclude filter</title>
			<link>http://tech.nitoyon.com/en/blog/2013/03/25/livereloadx0-2-0/</link>
			<guid>http://tech.nitoyon.com/en/blog/2013/03/25/livereloadx0-2-0/</guid>
			<pubDate>Mon, 25 Mar 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p><a href="http://nitoyon.github.com/livereloadx/">LiveReloadX</a> 0.2.0 is released.</p>

<p>If you want to install, type <code>npm install -g livereloadx</code>. If you have installed older versions, run <code>npm update -g livereloadx</code>.</p>

<p>With older version, if you modifying any files under the monitored directory, browsers are reloaded. It means that running <code>git commit</code> made browsers reloaded.</p>

<p>So, I add a command line options to specify include/exclude filter.</p>

<p>For example, if you want to <code>cache</code> directory not to be watched, specify as follows:</p>
<div class="highlight"><pre><code class="text">$ livereloadx --exclude cache
</code></pre></div>
<p>And more, LiveReloadX 0.2.0 monitors files with extension such as html, shtml, css, js, jpg, gif, png, cgi, php... If you want to watch files with extension <code>ini</code>, run following:</p>
<div class="highlight"><pre><code class="text">$ livereloadx --include &quot;*.ini&quot;
</code></pre></div>
<p>Iinclude/exclude options works like rsync. See FILTER RULES section of rsync manual for details.</p>

<p>Try it now!!</p>
]]></description>
		</item>

		<item>
			<title>LiveReloadX Released: Reload your Browser Automatically!</title>
			<link>http://tech.nitoyon.com/en/blog/2013/02/27/livereloadx/</link>
			<guid>http://tech.nitoyon.com/en/blog/2013/02/27/livereloadx/</guid>
			<pubDate>Wed, 27 Feb 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p><center><img src="http://farm9.staticflickr.com/8100/8509399251_7056f91a11.jpg" width="500" height="294"></center></p>

<p>When we are developping a web site, we often edit source code and reload a browser. It would be wonderful if browsers are reloaded automatically.</p>

<p>There are some softwares such as <a href="http://incident57.com/codekit/">CodeKit</a> and <a href="http://livereload.com/">LiveReload</a>, but they are GUI tools and not free of charge. So I created a command line tool named <a href="http://nitoyon.github.com/livereloadx/">LiveReloadX</a> based on <a href="http://livereload.com/">LiveReload</a> source code.</p>

<p>LiveReloadX is using Node.js, so it runs on Windows, Mac and Linux. It reloads the browser not only on developping environment but also on iPhone and Android. Of course, free of charge.</p>

<p>See <a href="http://nitoyon.github.com/livereloadx/">LiveReloadX</a> for details!!</p>

<p>You can get source code from <a href="https://github.com/nitoyon/livereloadx">nitoyon/livereloadx - GitHub</a>. It would be a greate pleasure for me if you Star or send me a pull request.</p>
]]></description>
		</item>

		<item>
			<title>IRBWEB - Try Ruby on Your Browser!</title>
			<link>http://tech.nitoyon.com/en/blog/2009/04/05/irbweb-ruby-on-your-browser/</link>
			<guid>http://tech.nitoyon.com/en/blog/2009/04/05/irbweb-ruby-on-your-browser/</guid>
			<pubDate>Sun, 05 Apr 2009 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>One of the annoyances of trying ruby is installing Ruby. IRBWEB let you try it on your browser!</p>

<p>You can enter ruby expression and evaluate it.</p>

<p><center><a href="http://tech.nitoyon.com/irb/"><img src="http://f.hatena.ne.jp/images/fotolife/n/nitoyon/20090406/20090406011151.png" width="450" height="344" border="0"><br>IRBWEB</a></center></p>

<p>It works completely in your browser, so you get the result so quickly.</p>

<h1>Requirements</h1>

<p>The Silverlight 2.0 runtime plug-in required.</p>

<h1>How does it work?</h1>

<p>Silverlight supports DLR(Dynamic Language Runtime) which enables us to execute Ruby and Python on .NET application. IRBWEB is developped based on repl sample included in <a href="http://www.codeplex.com/sdlsdk">Silverlight Dynamic Languages SDK</a> 0.5.0.</p>
]]></description>
		</item>

		<item>
			<title>Processing &quot;FireCube&quot; example ported to ActionScript 3.0</title>
			<link>http://tech.nitoyon.com/en/blog/2009/03/25/processing-firecube-example-ported-to-actionscript-30/</link>
			<guid>http://tech.nitoyon.com/en/blog/2009/03/25/processing-firecube-example-ported-to-actionscript-30/</guid>
			<pubDate>Wed, 25 Mar 2009 00:00:00 +0900</pubDate>
			<description><![CDATA[<p><center><img src="http://f.hatena.ne.jp/images/fotolife/n/nitoyon/20090309/20090309001432.png" width="398" height="168"></center></p>

<p>Processing example <a href="http://processing.org/learning/topics/firecube.html">FireCube</a> is so interesting to me. I ported it to ActionScript 3.0.</p>

<p>The result is...</p>

<p><center><script src="http://www.gmodules.com/ig/ifr?url=http://nitoyon.googlepages.com/embed_flash.xml&amp;up_url=http%3A%2F%2Ftech.nitoyon.com%2Fmisc%2Fswf%2FFireCube.swf&amp;up_background=%23ffffff&amp;synd=open&amp;w=400&amp;h=300&amp;title=AS3.0+FireCube&amp;border=%23ffffff%7C3px%2C1px+solid+%23999999&amp;output=js"> </script><noscript>(Flash Player 9  or later required)</noscript></center></p>

<h1>Performance improvement</h1>

<p><a href="http://processing.org/learning/topics/firecube.html">Processing version</a> calculates every pixel color when</p>

<ul>
<li>creating noise,</li>
<li>combining values from adjacent pixels and</li>
<li>converting color.</li>
</ul>

<p>So I implement it as follows:</p>

<ul>
<li>creating noise -&gt; <code>BitmapData.noise()</code></li>
<li>combining values from adjacent pixels -&gt; <code>ConvolutionFilter</code></li>
<li>converting color -&gt; <code>BitmapData.paletteMap()</code></li>
</ul>

<h1>Difficulty</h1>

<p>HSV color space is not supported in AS3! I created a function called <code>HSVtoRGB</code>.</p>

<p>Drawing a cube was a pain. So, I changed a cube to circle...</p>

<p>Here is the code: (83 lines)</p>

<div class="highlight"><pre><code class="actionscript">// Processing FireCube (AS3 version) 
// original source: http://processing.org/learning/topics/firecube.html
package {
import flash.display.*;
import flash.filters.*;
import flash.geom.*;

public class FireCube extends Sprite{
    private const WIDTH:int = 200;
    private const HEIGHT:int = 150;

    public function FireCube(){
        stage.align = &quot;TL&quot;;
        stage.scaleMode = &quot;noScale&quot;;
        scaleX = scaleY = 2;

        // Create circle
        var circle:Sprite = new Sprite();
        circle.graphics.beginFill(0x808080);
        circle.graphics.drawCircle(0, 0, 10);
        circle.graphics.endFill();

        // Create buffered image
        var fire:BitmapData = new BitmapData(WIDTH, HEIGHT, false, 0);
        var pg:BitmapData = fire.clone();
        var noiseBmd:BitmapData = new BitmapData(WIDTH, 1);

        var bmp:Bitmap = new Bitmap(pg);
        addChild(bmp);

        // Generate the palette
        var r:Array = [], g:Array = [], b:Array = [];
        for(var x:int = 0; x &lt; 256; x++) {
            //Hue goes from 0 to 85: red to yellow
            //Saturation is always the maximum: 255
            //Lightness is 0..255 for x=0..128, and 255 for x=128..255
            HSVtoRGB(x / 3, 1, Math.min(x * 3 / 255.0, 1), r, g, b);
        }

        // Use ConvolutionFilter to calculate for every pixel
        var filter:ConvolutionFilter = new ConvolutionFilter(3, 3, [0, 0, 0, 16, 16, 16, 0, 16, 0], 65);

        // Prepare points and matrix
        var matrix:Matrix = new Matrix();
        var pt0:Point = new Point(0, HEIGHT - 1);
        var pt1:Point = new Point(0, -1);
        var pt2:Point = new Point(0, 1);

        // Do loop
        addEventListener(&quot;enterFrame&quot;, function(event:*):void{
            // Randomize the bottom row of the fire buffer
            noiseBmd.noise(Math.random() * 0xffffffff, 0, 190, 7, true);
            fire.copyPixels(noiseBmd, noiseBmd.rect, pt0);

            // Display circle
            matrix.tx = mouseX;
            matrix.ty = mouseY;
            fire.draw(circle, matrix);

            // Add pixel values around current pixel
            fire.applyFilter(fire, fire.rect, pt1, filter);

            // Output everything to screen using our palette colors
            pg.paletteMap(fire, fire.rect, pt2, r, g, b);
        });
    }

    // AS3 does not natively support HSV...  :-(
    private function HSVtoRGB(h:int, s:Number, v:Number, r:Array, g:Array, b:Array):void {
        if (h &lt; 60) {
            r.push((v * 255) &lt;&lt; 16);
            g.push((v * (1 - (1 - h / 60.0) * s) * 255) &lt;&lt; 8)
            b.push(v * (1 - s) * 255);
        } else if (h &lt; 120) {
            r.push((v * (1 - (-h / 60.0 - 1) * s) * 255) &lt;&lt; 16);
            g.push((v * 255) &lt;&lt; 8);
            b.push(v * (1 - s) * 255);
        } else {
            throw Error(&#39;not implemented&#39;);
        }
    }
}
}
</code></pre></div>
]]></description>
		</item>

		<item>
			<title>50 polygons Mona Lisa in AS3</title>
			<link>http://tech.nitoyon.com/en/blog/2009/02/17/50-polygons-mona-lisa-in-as3/</link>
			<guid>http://tech.nitoyon.com/en/blog/2009/02/17/50-polygons-mona-lisa-in-as3/</guid>
			<pubDate>Tue, 17 Feb 2009 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>I ported <a href="http://alteredqualia.com/visualization/evolve/">Image evolution</a> to ActionScript 3. </p>

<blockquote>
<p>We start from random 50 polygons that are invisible. In each optimization step
we randomly modify one parameter (like color components or polygon vertices)
and check whether such new variant looks more like the original image.
If it is, we keep it, and continue to mutate this one instead.</p>
</blockquote>

<p>In my computer, the result was as follows.</p>

<p><center><img src="http://f.hatena.ne.jp/images/fotolife/n/nitoyon/20090217/20090217014358.jpg" width="450" height="378"></center></p>

<p>It&#39;s waste of CPU.., but very interesting.</p>

<p>Published SWF (CAUSION: TOO HEAVY CPU 60%~)</p>

<p><object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" width="450"
    height="420" codebase="http://active.macromedia.com/flash7/cabs/swflash.cab#version=9,0,0,0">
    <param name="src" value="http://tech.nitoyon.com/misc/swf/MonalisaEvolve.swf"/>
    <param name="play" value="true"/>
    <param name="loop" value="true"/>
    <param name="bgcolor" value="#ffffff"/>
    <param name="quality" value="high"/>
    <embed src="http://tech.nitoyon.com/misc/swf/MonalisaEvolve.swf" width="450" height="420" bgcolor="#ffffff" play="true" loop="true"
    quality="high" pluginspage="http://www.macromedia.com/shockwave/download/index.cgi?P1_Prod_Version=ShockwaveFlash">
    </embed>
</object>
<noscript>(Flash Player 9 or above required)</noscript></p>

<p>Because this program uses <code>BitmapData.compare()</code> to improve performance, it is about 10 times faster than the <a href="http://alteredqualia.com/visualization/evolve/">JavaScript version</a>. The original <a href="http://rogeralsing.com/2008/12/11/genetic-programming-mona-lisa-source-code-and-binaries/">C# version</a> is about 3 times faster than mine.</p>

<p>Here is the code: (189lines)</p>

<div class="highlight"><pre><code class="actionscript">package{
import flash.display.*;
import flash.text.*;
import flash.geom.*;
import flash.filters.ColorMatrixFilter;
import flash.utils.setInterval;

[SWF(backgroundColor=&quot;#eeeeee&quot;)]
public class Evolve extends Sprite{
    [Embed(source=&#39;mona_lisa_crop.jpg&#39;)]
    private var MonaLisa:Class;
    private var imgWidth:int;
    private var imgHeight:int;

    private const POLYGONS:int = 50;
    private var polygons:Array = [];
    private var mutating:Boolean = false;

    private var monotoneFilter:ColorMatrixFilter = new ColorMatrixFilter([
            1 / 3, 1 / 3, 1 / 3, 0, 0, 
            1 / 3, 1 / 3, 1 / 3, 0, 0, 
            1 / 3, 1 / 3, 1 / 3, 0, 0, 
                0,     0,     0, 1, 0 ]);
    private var pt0:Point = new Point(0, 0);
    private var rect:Rectangle;

    private var bestBmd:BitmapData;
    private var testBmd:BitmapData;
    private var inputBmd:BitmapData;
    private var debugBmd:BitmapData;

    private var canvas:Sprite;

    private var score:uint;
    private var scoreMax:uint;
    private var mutations:uint = 0;
    private var candidates:uint = 0;
    private var totalTime:Number = 0;
    private var time:Date;
    private var scoreText:TextField;

    public function Evolve(){
        stage.scaleMode = &quot;noScale&quot;;
        stage.align = &quot;TL&quot;;

        // init image
        var bmp:Bitmap = new MonaLisa();
        inputBmd = bmp.bitmapData;
        addChild(bmp);
        imgWidth = bmp.width;
        imgHeight = bmp.height;
        rect = inputBmd.rect;
        score = scoreMax = rect.width * rect.height * 255;

        // init buffer
        bestBmd = inputBmd.clone(); bestBmd.fillRect(rect, 0x000000);
        testBmd = inputBmd.clone(); testBmd.fillRect(rect, 0x000000);
        debugBmd = inputBmd.clone();
        addChild(new Bitmap(bestBmd)).x = bmp.width + 10;

        // init data and canvas
        canvas = new Sprite();
        for(var i:int = 0; i &lt; POLYGONS; i++){
            polygons[i] = new Polygon();
            canvas.addChild(new Sprite());
        }
        drawTest();
        testToBest();

        // init ui
        var tf:TextField = new TextField();
        tf.text = &quot;click to start&quot;;
        tf.y = bmp.height + 10;
        tf.scaleX = tf.scaleY = 3;
        addChild(tf);
        stage.addEventListener(&quot;click&quot;, function(event:*):void{
            mutating = !mutating;
            time = (mutating ? new Date() : null);
            tf.text = (mutating ? &quot;Now Simulating...&quot; : &quot;click to start&quot;);
        });
        scoreText = new TextField();
        scoreText.autoSize = &quot;left&quot;;
        scoreText.y = bmp.height + 60;
        scoreText.scaleX = scoreText.scaleY = 3;
        addChild(scoreText);

        // start timer
        setInterval(update, 10);
    }

    private function update():void{
        if(!mutating) return;
        var t:Date = new Date();
        totalTime += (t.getTime() - time.getTime()) / 1000;
        time = t;

        for(var i:int = 0; i &lt; 10; i++) update1();
        scoreText.text = (int((1 - score / scoreMax) * 10000) / 100)
             + &quot;%\n&quot; + mutations + &quot; / &quot; + candidates + &quot;\n&quot;
             + (int(totalTime * 10) / 10) + &quot;s&quot;;
    }

    private function update1():void{
        var index:int = Math.random() * POLYGONS;
        var backup:Polygon = polygons[index].clone();
        polygons[index].mutate();
        drawTest();

        var diffBmd:BitmapData = testBmd.compare(inputBmd) as BitmapData;
        diffBmd.applyFilter(diffBmd, rect, pt0, monotoneFilter);
        var testScore:uint = 0;
        for(var i:int = 0; i &lt; 0x100; i++){
            testScore += diffBmd.threshold(diffBmd, rect, pt0, &quot;==&quot;, i, i, 0xff) * i;
        }

        if(score &gt; testScore){
            score = testScore;
            testToBest();
            mutations++;
        }else{
            polygons[index] = backup;
        }
        candidates++;
    }

    private function drawTest():void{
        canvas.graphics.clear();
        for(var i:int = 0; i &lt; POLYGONS; i++){
            polygons[i].draw(canvas, imgWidth, imgHeight);
        }

        testBmd.fillRect(rect, 0x000000);
        testBmd.draw(canvas);
    }

    private function testToBest():void{
        bestBmd.copyPixels(testBmd, rect, pt0);
    }
}
}

import flash.display.*;
import flash.geom.*;

class Polygon{
    private const POINTS:int = 6;

    public var points:Array = [];
    public var color:uint;
    public var alpha:Number;

    public function Polygon(polygon:Polygon = null){
        for(var i:int = 0; i &lt; POINTS; i++)
            points[i] = (polygon ? polygon.points[i].clone() : new Point(Math.random(), Math.random()));
        color = (polygon ? polygon.color : 0xffffff * Math.random());
        alpha = (polygon ? polygon.alpha : .1);
    }

    public function clone():Polygon{
        return new Polygon(this);
    }

    public function mutate():void{
        (Math.random() &lt; 0.5 ? mutateColor() : mutatePosition());
    }

    private function mutateColor():void{
        switch(int(Math.random() * 4)){
            case 0: color = (color &amp; 0x00ffff) + int(Math.random() * 255) * 0x010000; break;
            case 1: color = (color &amp; 0xff00ff) + int(Math.random() * 255) * 0x000100; break;
            case 2: color = (color &amp; 0xffff00) + int(Math.random() * 255) * 0x000001; break;
            case 3: alpha = Math.random(); break;
        }
    }

    private function mutatePosition():void{
        var p:int = Math.random() * POINTS;
        if(Math.random() &lt; .5) points[p].x = Math.random();
        else                   points[p].y = Math.random();
    }

    public function draw(canvas:Sprite, w:Number, h:Number):void{
        canvas.graphics.beginFill(color, alpha);
        canvas.graphics.moveTo(points[0].x * w, points[0].y * h);
        for(var i:int = 1; i &lt; POINTS; i++)
            canvas.graphics.lineTo(points[i].x * w, points[i].y * h);
        canvas.graphics.endFill();
    }
}
</code></pre></div>
]]></description>
		</item>

	</channel>
</rss>
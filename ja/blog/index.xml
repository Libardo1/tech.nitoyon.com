<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>てっく煮ブログ</title>
		<link>http://tech.nitoyon.com/ja/blog/index.xml</link>
		<description>All Technology is Boiled in This Site.</description>
		<language>ja</language>
		<copyright>Copyright nitoyon.</copyright>
		<lastBuildDate>Tue, 29 Jan 2013 02:51:53 +0000</lastBuildDate>
		<docs>http://blogs.law.harvard.edu/tech/rss</docs>
		<atom:link href="http://tech.nitoyon.com/ja/blog/index.xml" rel="self" type="application/rss+xml" />









		<item>
			<title>jQuery 1.9 のソースマップ対応で圧縮版でもデバッグが簡単になった話</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/01/29/jquery-source-map/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/01/29/jquery-source-map/</guid>
			<pubDate>Tue, 29 Jan 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>jQuery 1.9 がリリースされました。1.9 の新機能の中ではあまり注目されていませんが、<strong>ソースマップに対応</strong>したのが地味に便利そうです。</p>

<p>というのも、圧縮版の jquery.min.js を使っていると</p>

<ul>
<li>何か問題が起きたときにスタックトレースを眺めても jQuery の部分が意味不明</li>
<li>デバッガーで jQuery のソースにステップインしても意味不明</li>
</ul>

<p>といった理由で、開発中には非圧縮の jquery.js を使うことが多かったわけです。</p>

<p>それが、1.9 からはソースマップに対応したので<strong>圧縮版のままでのデバッグが簡単</strong>になってます。</p>

<h1>超簡単な使い方</h1>

<p>ソースマップに対応したブラウザーは現時点では Google Chrome のみなので、Google Chrome の手順を説明します。</p>

<p>(Firefox はソースマップへの対応を<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=771597">計画中</a>らしい)</p>

<h2>事前準備を忘れずに</h2>

<p>Google Chrome で [デベロッパー ツール] を開きます。</p>

<p><center><img src="http://farm9.staticflickr.com/8466/8423335379_7fdbcbf661.jpg" width="500" height="454"></center></p>

<p>右下の設定ボタンを押して、[Enable source maps] をチェックします。</p>

<p>下準備はこれだけ。簡単ですね！</p>

<h2>早速使ってみよう</h2>

<p>本家の <a href="http://jquery.com/">jquery.com</a> は早速 1.9.0 の圧縮版を使っていました。ということで、ここで実験してみます。</p>

<p>まず、<a href="http://jquery.com/">http://jquery.com/</a> に行って、[デベロッパー ツール] を開いてみます。</p>

<p>[Sources] タブから <code>main.js</code> を選択して、最初の <code>on()</code> 関数のコールバックにブレークポイントを仕込んでみます。</p>

<p><center><img src="http://farm9.staticflickr.com/8225/8423335179_d4bc25f945.jpg" width="500" height="263"></center></p>

<p>サイトの下のほうにある「CDN」の右側が <code>.cdn input</code> なので、ここをクリックすると…</p>

<p><center><img src="http://farm9.staticflickr.com/8368/8423335345_e11a941f99.jpg" width="500" height="240"></center></p>

<p>はい、ブレークしますね。ここで注目すべきは右側の [Call Stack]。よく見ると…</p>

<ul>
<li>(anonymous function) main.js:7</li>
<li>st.event.dispatch jquery.js:3045</li>
<li>st.event.add.y.handle jquery.js:2721</li>
</ul>

<p>jQuery の関数名と、行数が書いてありますね。<strong>jquery.min.js しかロードしてないページなのに、jquery.js の情報が表示</strong>されています！</p>

<p>ためしに <code>st.event.dispatch jquery.js:3045</code> をダブルクリックすると…</p>

<p><center><img src="http://farm9.staticflickr.com/8469/8423335301_af26ed3b0e.jpg" width="500" height="257"></center></p>

<p>jquery.js がロードされて、該当する場所を表示できました。圧縮前の jquery.js なので、当然、コメントも残っています。</p>

<p>これはすごい！</p>

<p>jQuery 1.9 では jquery.min.js を利用しててもデバッグでは困らないのです。</p>

<p>ところで、これ、どういう仕組みで動いてるか気になりませんか？　気になる人は続きをお読みください。</p>

<h1>ソースマップとは何ぞや</h1>

<p>jQuery 1.9 からの jquery.min.js には、最後の行に次のようなコメントがあります。</p>
<div class="highlight"><pre><code class="javascript">/*! jQuery v1.9.0 (省略) */(function(e,t){/* 省略 */})(window);
//@ sourceMappingURL=jquery.min.map
</code></pre></div>
<p><code>@ sourceMappingURL=jquery.min.map</code> に注目。ソースマップの URL が書いてあります。Google Chrome はこの部分を見て、ソースマップを読み込んでいたわけですね。</p>

<p>となると、気になるのが <code>jquery.min.map</code> の中身。Google CDN には jquery.min.js と同じディレクトリーに <a href="http://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.map"><code>jquery.min.map</code></a> が設置してあります。</p>

<p>整形して表示してみるとこうなります。</p>
<div class="highlight"><pre><code class="javascript">{
    &quot;version&quot;: 3,
    &quot;file&quot;: &quot;jquery.min.js&quot;,
    &quot;sources&quot;: [&quot;jquery.js&quot;],
    &quot;names&quot;: [&quot;window&quot;,&quot;undefined&quot;,&quot;isArraylike&quot;, /* 省略 */],
    &quot;mappings&quot;: &quot;CAaA,SAAWA,EAAQC,GACnB,(省略)&quot;
}
</code></pre></div>
<p><code>jquery.js</code> と書いてありますね。これを見て Google Chrome は <code>jquery.js</code> に行き着いたようです。<code>sources</code> が複数指定できることから、ソースマップは、複数のソースを結合して圧縮した場合にも対応できそうなフォーマットだと推測できます。</p>

<p>問題は <code>mappings</code> なのですが、これは「圧縮後の○列目の文字は、ソース△△の××行目の××列目にありますよ」という情報を BASE64 VLQ で圧縮したものだそうです。</p>

<p>詳しくは <a href="http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/">Introduction to JavaScript Source Maps - HTML5 Rocks</a> に書いてあるので、さらに興味がある人は参照してみてください。</p>

<h1>CDN を使わない場合</h1>

<p>いい忘れていましたが、Google CDN を使わないで自分のサーバーで jquery.min.js をホスティングする場合は、少し追加の手順が必要になります。</p>

<p>jquery.min.js をアップロードする場所に jquery.min.map と jquery.js を置くだけです。簡単ですね。</p>

<p><code>jquery.min.map</code> は jquery の公式サイトでは公開されてないけど、</p>

<ul>
<li><a href="http://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.map">http://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.map</a></li>
</ul>

<p>に置いてあるので、1.9.0 以降のバージョンがリリースされても URL の 1.9.0 の部分を置き換えれば取得できそうです。</p>

<h1>ソースマップを活用しよう</h1>

<p>さて、便利便利なソースマップなので、自分のプロジェクトでも活用してみたいですよね。</p>

<p>ソースマップは JavaScript の圧縮はもちろん、<strong>CoffeeScript/HaXe/TypeScript/JSX</strong> などの JavaScript を生成する言語でも出力できるようです。</p>

<p>さらに、CSS 生成で有名な <strong>SASS/LESS</strong> でも活用できるようです。</p>

<p>夢が広がったので、ソースマップの出力方法を調べてみました。</p>

<h2>JavaScript の圧縮</h2>

<p>jQuery が利用している圧縮ツールは <a href="https://github.com/mishoo/UglifyJS2">UglifyJS</a> です。コマンドライン引数に <code>--source-map</code> を指定すると、ソースマップを吐けるようです。</p>

<p>もう１つの主流な圧縮ツール <a href="https://developers.google.com/closure/compiler/">Closure compiler</a> では <code>--create_source_map ./foo.min.map --source_map_format=V3</code> と指定する模様。</p>

<h2>JavaScript を生成する色々</h2>

<p>ぐぐって調べて引っかかった結果をまとめておく。</p>

<ul>
<li>CoffeeScript: <code>coffee</code> コマンドに <code>--source-map</code> をつけるだけ。</li>
<li>HaXe: <code>haxe</code> コマンドに <code>--debug</code> をつけるだけ。</li>
<li>TypeScript: <code>tcs</code> コマンドに <code>-sourcemap</code> をつけるだけ。</li>
<li>JSX: <code>--enable-source-map</code> らしい。</li>
</ul>

<h2>SASS/LESS</h2>

<p>JavaScript よりも、もう少し複雑そう。詳しくはリンク先を。</p>

<ul>
<li>SASS: <a href="http://bricss.net/post/33788072565/using-sass-source-maps-in-webkit-inspector">Bricss - Using Sass source maps in WebKit Inspector</a></li>
<li>LESS: <a href="http://robdodson.me/blog/2012/12/28/debug-less-with-chrome-developer-tools/">Debug LESS with Chrome Developer Tools - Rob Dodson talks internets</a></li>
</ul>

<p>リンク先を見る限り、<code>@media -sass-debug-info</code> という独自の情報を出力して、それを Google Chrome 側で解釈する模様。</p>

<h1>まとめ</h1>

<p>ソースマップがあれば、圧縮したソースでの開発も怖くない！　え？　Google Chrome 以外のブラウザーで困ったら？　そのときは今まで通り・・・。</p>
]]></description>
		</item>

		<item>
			<title>はてなブックマークの入れ替わり激しくない人気エントリーを見る方法</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/01/25/old-hotentry/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/01/25/old-hotentry/</guid>
			<pubDate>Fri, 25 Jan 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p><a href="http://b.hatena.ne.jp/">はてなブックマーク</a>のトップページがリニューアルして、新しいデザインへの不満が一通り<a href="http://www.itmedia.co.jp/news/articles/1301/09/news089.html">出つくした</a>感があるけど、<strong>人気エントリーのアルゴリズムが改善された</strong>件について触れてる人をあまり見ない。</p>

<h1>人気エントリーの入れ替わりが激しくなった</h1>

<p>いままでは人気エントリーはキャッチーなやつで固定化されていたんだけど、今回の改善で、人気エントリーの入れ替わりが激しくなった。</p>

<p>公式にもアナウンスはされていて、<a href="http://hatena.g.hatena.ne.jp/hatenabookmark/20130108/1357641152">トップページとカテゴリページをリニューアルしました - はてなブックマーク日記</a> によると</p>

<blockquote>
<p>滞留や偏りをなくすためにアルゴリズムを変更いたしました。一定時間でコンテンツが入れ替わるよう更新性を高めています。その日にしかチェックできない、新鮮なエントリーが楽しめるようになりました。人気エントリーのアルゴリズムは、今後も継続的に改善してまいります。</p>
</blockquote>

<p>とある。</p>

<h2>いままでは「ブックマーク数」至上主義だった</h2>

<p>いままでの人気エントリーのアルゴリズムはきわめて単純だった。</p>

<p>「時間当たりのブックマーク数が多い順」。</p>

<p>単純で分かりやすいが弊害もある。人気を集めてトップページに掲載されると、それを見てブックマークする人が出てくるので、人気のある記事は半永久的にブックマークを集め続けられた。</p>

<p>キャッチーな記事は数日間トップページに居座り続けていたし、そうじゃなくても、「○○の××個まとめ」といった似たような記事ばかりトップページに載っていた。</p>

<p>結果、「すごく人気を集める記事」と「そこそこ需要はあるはずなのに人目に触れずに消えていく記事」に二分されていた。</p>

<h2>「鮮度」が重視されるようになった</h2>

<p>このような問題を改善するために、今回、「時間あたりのブックマーク数」だけでなく「情報の鮮度」が重視されるようになったようだ。しばらく人気エントリーに居座っていると、たとえブックマークを集めていてもランキングが落ちていく。</p>

<p>そのおかげで、以前よりもエントリーの入れ替わりが激しくなり、タイムリーに話題になっている記事が分かるようになった。いままでは人目に触れずに消えていったような記事がトップページでピックアップされやすくなった。</p>

<p>少し極端な例をあげてみる。これはとある日の、はてブトップページ。</p>

<p><center><img src="http://farm9.staticflickr.com/8045/8410686001_b50affeacb.jpg" width="500" height="404"></center></p>

<p>1 位が「55 users」、2 位が「42 users」。短い時間にブックマークを集めれば、50 users ほどでも 1 位になれるのだ。</p>

<p>(ただし、これでは極端すぎると判断したのか 1 週間後に<a href="http://hatena.g.hatena.ne.jp/hatenabookmark/20130116/1358333640">スコアリングが補正</a>されている。現在では 100～200 users ぐらい集めないと 1 位にはならないような印象がある)</p>

<h1>以前の計算方法で人気エントリーを見たい！</h1>

<p>さて、タイムリーな話題が分かるようになったのはいいけど、みんながみんな、四六時中、はてなブックマークを見ているわけではない。</p>

<p>タイムリーな記事ではなく、今日話題になっている記事を知りたい、という人も多いはずだ。</p>

<h2>日別ランキングがあるじゃないか</h2>

<p>実は、以前の人気エントリーに相当するようなページがある。</p>

<p>それが <a href="http://b.hatena.ne.jp/hotentry/daily">http://b.hatena.ne.jp/hotentry/daily</a> だ。<code>daily</code> という URL の通り、その 1 日の人気エントリーがブックマーク数順に並んでいるようだ。</p>

<p><a href="http://b.hatena.ne.jp/hotentry/daily"><center><img src="http://farm9.staticflickr.com/8468/8410686199_3366103bc6.jpg" width="500" height="418"></center></a></p>

<p>上位にブックマーク数の多いエントリーが並んでいる。昔の人気エントリーのアルゴリズムと完全に同じではないんだけど、かなり近い印象がある。懐かしい・・・。</p>

<p>一番下までスクロールすると、過去の日付にさかのぼるリンクもある。前日・前々日あたりの人気のエントリーが気になるなら、そちらもチェックするとよいだろう。</p>

<h2>週間・月間ランキングもあるよ</h2>

<p>さらに少し長いスパンでの人気エントリーを探したい場合は、</p>

<ul>
<li><a href="http://b.hatena.ne.jp/ranking">はてなブックマークランキング - 週間ランキング</a></li>
<li><a href="http://b.hatena.ne.jp/ranking/monthly">はてなブックマークランキング - 月間ランキング</a></li>
</ul>

<p>を見るとよい。</p>

<p><a href="http://b.hatena.ne.jp/ranking"><center><img src="http://farm9.staticflickr.com/8183/8410686329_e3d0be8450.jpg" width="500" height="379"></center></a></p>

<p>新しいトップページからはリンクされてないけど・・・。</p>

<h1>まとめ</h1>

<p>人気エントリーの算出方法が変わってタイムリーな記事が上位に来るようになったよ、前のような「ブックマーク数至上主義」なランキングを見たいなら <a href="http://b.hatena.ne.jp/hotentry/daily">日別ランキング</a>、<a href="http://b.hatena.ne.jp/ranking">週間別ランキング</a>、<a href="http://b.hatena.ne.jp/ranking/monthly">月間ランキング</a> が便利だよ、というお話でした。</p>

<p>新しいトップページについての個人的な感想は</p>

<ul>
<li>確かに一覧性は悪くなったけど、初めて見る人には親しみやすいデザインになったんじゃないかな。</li>
<li>Google Chrome で <code>[Ctrl] + [+]</code> で拡大しても文字サイズが変わらないのを何とかしてほしい。</li>
<li>Nexus 7 を横にしてカテゴリーページを開いたら「見やすい」と感じたので、「タイル」はスマホ・タブレット向きのデザインなんだろう。これからの Web サービスは PC と携帯デバイスの見え方の違いをどう吸収していくかが課題になりそう。</li>
<li>人気エントリーの新しいアルゴリズムは非常によい。トップページを見る頻度が上がった。</li>
</ul>

<p>といったところ。</p>
]]></description>
		</item>

		<item>
			<title>GitHub で clone するときは SSH じゃなく HTTP を使ったほうが高速</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/01/11/github-clone-http/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/01/11/github-clone-http/</guid>
			<pubDate>Fri, 11 Jan 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p><center><img src="http://farm9.staticflickr.com/8082/8367926710_8530642335_o.png" width="571" height="221"></center></p>

<p>GitHub には clone するための URL として [HTTP]、[SSH]、[Git Read-Only] の 3 つが用意されている。</p>

<p>いままで、SSH に慣れているという理由だけで [SSH] を利用していたのだけど、「<strong>SSH は転送速度が遅い</strong>」という問題がある。</p>

<h1>SSH だとこんなに遅い…</h1>

<p>さっき、[SSH] で clone してみたら 20～60 KiB/s 程度の速度しか出なかった。</p>
<div class="highlight"><pre><code class="text">$ git clone git@github.com:nitoyon/tech.nitoyon.com.git
Cloning into &#39;tech.nitoyon.com&#39;...
remote: Counting objects: 8856, done.
remote: Compressing objects: 100% (2125/2125), done.
remote: Total 8856 (delta 3251), reused 8731 (delta 3126)
Receiving objects: 100% (8856/8856), 7.04 MiB | 26 KiB/s, done.
Resolving deltas: 100% (3251/3251), done.
</code></pre></div>
<p>↑最終的に <code>26 KiB/s</code> しか出ていない。</p>

<p>これでは、巨大なリポジトリを clone すると、長大な時間を要することになる。</p>

<h1>HTTP は高速！</h1>

<p>そんなときは、 [HTTP] で clone すればよい。</p>

<p>さっき試したら、300～600 KiB/s 出た。</p>
<div class="highlight"><pre><code class="text">$ git clone https://github.com/nitoyon/tech.nitoyon.com.git
Cloning into &#39;tech.nitoyon.com&#39;...
remote: Counting objects: 8856, done.
remote: Compressing objects: 100% (2125/2125), done.
remote: Total 8856 (delta 3251), reused 8731 (delta 3126)
Receiving objects: 100% (8856/8856), 7.04 MiB | 604 KiB/s, done.
Resolving deltas: 100% (3251/3251), done.
</code></pre></div>
<p>↑<code>604 KiB/s</code> も出ている</p>

<p>[Git Read-Only] も試してみたら、こちらは 1 MiB/s ぐらいでたので一番高速だった。</p>

<p><s>つまり、[HTTP] が最強！　他の 10 倍速い。</s></p>

<p>つまり、速さは [Git Read-Only] &gt; [HTTP] &gt;&gt; [SSH] となった。</p>

<p>(訂正) 当初、[HTTP] が最強としていましたが、再度調べてみたところ、[Git Read-Only] が最強でした。お詫びして訂正します。</p>

<h1>push が面倒なら clone 後に SSH にすればよい</h1>

<p>[SSH] で clone したときのメリットは、push のときには ssh-agent なり pageant なりが、パスフレーズの入力を代行してくれる点にある。<code>git push</code> と入力するだけで push を開始できてお手軽だ。</p>

<p>一方、[HTTP] で clone してしまうと、push するたびにユーザー名とパスワードを要求されて面倒だ。<a href="https://help.github.com/articles/set-up-git#platform-windows">credential helper</a> を導入すればキャッシュしてくれるらしいが、これも面倒だ。</p>

<p>[Git Read-Only] だと Read-Only という名前の通り、push できない。</p>

<p>それが理由で、いままで [SSH] でちんたら clone していた。</p>

<p>けども、よく考えたら [HTTP] や [Git Read-Only] で clone したあとでも、[SSH] で push するように設定を変更できる。</p>
<div class="highlight"><pre><code class="text">$ git remote set-url origin git@github.com:user/repo.git
</code></pre></div>
<p><code>git remote</code> で <code>origin</code> の URL を変えるだけ。この手順は <a href="https://help.github.com/articles/why-is-git-always-asking-for-my-password">GitHub のヘルプ</a>にも書いてある。</p>

<p>これ以降の push / pull は [SSH] でやるようになる。[HTTP] に比べて転送速度は遅いけど、1度 clone したあとなら、差分のみの送受信なので、あまり速度は気にしなくてもよいはずだ。(もし大量に送受信する必要が出たなら、同じようにして再度 [HTTP] に切り替えてもよいだろう)</p>

<h1>(追記) SSH も設定を変えれば速くなる</h1>

<p><code>~/.ssh/config</code> に次の設定をすれば、SSH でも十分速くなるようです。</p>
<div class="highlight"><pre><code class="text">Host github.com
  Compression yes
  Ciphers arcfour256
</code></pre></div>
<p>はてなブックマークで id:y-kawaz さんに<a href="http://b.hatena.ne.jp/y-kawaz/20130111#bookmark-127926818">指摘していだきました</a>。ありがとうございます。</p>

<h1>まとめ</h1>

<p>次のような戦略が考えられる。</p>

<ul>
<li>push する必要がないなら [Git Read-Only] で clone すると高速。</li>
<li>[SSH] の clone は <code>~/.ssh/config</code> を設定すると速度が劇的に改善する。</li>
<li>clone したあとに、<code>git remote set-url</code> で URL を変更すれば、push するプロトコルを変更できる</li>
</ul>

<p>快適な GitHub 生活を。</p>
]]></description>
		</item>

		<item>
			<title>うちの年賀状2013</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/01/08/nenga/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/01/08/nenga/</guid>
			<pubDate>Tue, 08 Jan 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>毎年恒例で、一年の最初のエントリは我が家の年賀状でのご挨拶です。</p>

<p><center><img src="http://farm9.staticflickr.com/8327/8357146769_ddc6a148bd.jpg" width="357" height="500"></center></p>

<p>今年は映画ポスター風の実写で作成してみました。</p>

<h1>twitter アイコン</h1>

<p>毎年、twitter のアイコンを年賀状から抜粋しているのですが、自分の実写の顔をそのまま twitter のアイコンにするのは抵抗があったので、12 年前に描いた年賀状を使うことにしました。12 年間、データが残っていたのが驚き。</p>

<p><center><img src="http://farm9.staticflickr.com/8083/8357161789_f84bd3d726_o.jpg" width="612" height="612"></center></p>

<p>今年もよろしくおねがいします。</p>
]]></description>
		</item>

		<item>
			<title>Jekyll の 0.12.0 でシンタックス ハイライトが便利になった</title>
			<link>http://tech.nitoyon.com/ja/blog/2012/12/25/jekyll-0-12-0/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2012/12/25/jekyll-0-12-0/</guid>
			<pubDate>Tue, 25 Dec 2012 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>※ これは <a href="https://www.google.co.jp/search?q=%E3%81%9D%E3%82%93%E3%81%AA%E3%82%82%E3%81%AE%E3%81%AF%E3%81%AA%E3%81%84">Jekyll アドベントカレンダー</a> の 25 日目の記事です</p>

<p>このブログの生成にも利用している Jekyll が約 1 年ぶりにバージョン アップして 0.12.0 になった。<a href="http://rubygems.org/gems/jekyll">RubyGems</a> に公開されているので、<code>gem update</code> で更新できるはず。</p>

<p>この記事では、0.12.0 で個人的に注目している「シンタックス ハイライトに関する改善点」を 2 つ紹介する。</p>

<p>Jekyll の良さについては、<a href="/ja/blog/2012/09/20/moved-completed/">俺の最強ブログ システムが火を噴くぜ</a> で記事にしているので、知らない人はそちらからどうぞ。</p>

<h1>Redcarpet 2 のサポート</h1>

<p>まず 1 つ目は Redcarpet 2 のサポート。</p>

<p>Redcarpet は GitHub の中の人によって開発されている Markdown パーサーて、<a href="http://github.github.com/github-flavored-markdown/">GitHub Flavored Markdown</a> が使えるのが大きな特徴。</p>

<p>これまでも Jekyll では Redcarpet をサポートしていたが、Redcarpet 2 で外部 API が変わったので、Jekyll からは利用できない状態になっていた。</p>

<p>今回、Jekyll 0.12.0 で Redcarpet 2 の API に対応した。個人的には <code>```</code> での Fenced code blocks が使えるようになったのがうれしい。</p>

<p>たとえば、</p>
<div class="highlight"><pre><code class="text">```ruby
def fib(n);
    n &lt;= 1 ? n : fib(n-1)+fib(n-2)
end
print fib(10)
```
</code></pre></div>
<p>と書くと</p>
<div class="highlight"><pre><code class="ruby">def fib(n);
    n &lt;= 1 ? n : fib(n-1)+fib(n-2)
end
print fib(10)
</code></pre></div>
<p>となる。</p>

<p>これまでは「<code>{% highlight ruby %}</code> と <code>{% endhighlight %}</code> で囲う」という面倒な書き方をしなきゃならなかった。どうしても <code>```</code> を使いたいときは <a href="http://mattn.kaoriya.net/software/lang/ruby/20121011184445.htm">Big Sky :: Jekyll で GitHub みたいな Triple Backtick を使う。</a> のように、独自にプラグインを作るハックもあるにはあった。</p>

<p>ちなみに、Redcarpet を利用するには、<code>_config.yml</code> に次のように書くのを忘れずに。</p>
<div class="highlight"><pre><code class="yaml">markdown:    redcarpet
</code></pre></div>
<h1>シンタックス ハイライトの高速化</h1>

<p>2 つ目は速度の話。</p>

<p>Jekyll はシンタックス ハイライトに pygments を使っている。Ruby で動く Jekyll から、Python で動く pygments を利用するには、何らかの工夫が必要になる。</p>

<p>Jekyll 0.11.2 までは <a href="https://github.com/github/albino">Albino</a> を使っていた。Albino はハイライトするたびに、Python のプロセスを実行して結果を取得していた。ハイライトするコード 1 つごとに Python が 1 プロセス立ち上がっていたので、当然、遅かった。</p>

<p>そこで、Jekyll 0.12.0 では <a href="https://github.com/tmm1/pygments.rb">pygments.rb</a> が利用されるようになった。pygments.rb は高速化のための工夫がほどこされている。</p>

<p>pygments.rb には 0.2 系と 0.3 系があって、それぞれ別の高速化手法が使われていて面白い。</p>

<h2>pygments.rb 0.2 は RubyPython で無理やり</h2>

<p>0.2 では、<a href="http://rubypython.rubyforge.org/">rubypython</a> という Ruby 上で Python インタプリターを動かすライブラリーを使っている。<a href="https://github.com/ffi/ffi">FFI</a> で動的ライブラリーを読み込んでがんばっているようだ。</p>

<p>導入にはビルド環境が必要なので面倒だけど、劇的に高速化された。同一プロセス内で完結するので、プロセス起動のオーバーヘッドが 0 になる。</p>

<p>と、そこまではよかったのだけど、Ruby ごと落ちることがある。再現性はない。うまくいくこともあるし、落ちることもある。自分の環境が Windows だから不安定なのかと思いきや、Jekyll の Issue にも<a href="https://github.com/mojombo/jekyll/pull/667">上がっている</a> ので、RubyPython か FFI の問題なのだろう。</p>

<h2>pygments.rb 0.3 は Python を使いまわす</h2>

<p>0.2 の「Ruby 上で Python」作戦は不安定だったため、0.3 では純粋な Python を呼び出す方式に戻った。ただ、毎回呼び出すのではなく、プロセスを使いまわすようにした。</p>

<p>0.3 でハイライト処理を開始すると、Ruby と pygments を媒介する Python スクリプト <code>mentos.py</code> が立ち上がる。Ruby からは標準入出力を使って <code>mentos.py</code> に処理依頼をして、ハイライト結果を受け取る。複数回ハイライトを実行しても、同じプロセスを使いまわす。</p>

<p>純粋な Python が動くので、プロセスが死ぬような心配もない。0.2 のころに比べれば少しだけオーバーヘッドはある印象だが、Albino に比べれば十分速い。プロセス内に取り込むという暴挙に出て手に負えなくなったものが、ひとたび我に返って、実用に耐える速さと安定性を手に入れた。</p>

<p>ただし、最新の pygments 0.3.3 は Windows では動かない。<code>/dev/null</code> が見つからないなど、いろいろエラーになったので、動くようにして <a href="https://github.com/tmm1/pygments.rb/pull/55">pull request</a> を出しておいた。取り込まれるといいな。(追記) 取り込まれて 0.3.4 として公開された!!</p>

<h1>まとめ</h1>

<p>Jekyll 0.12.0 の個人的にうれしいところをざっと紹介した。その他の変更点は <a href="https://github.com/mojombo/jekyll/blob/master/History.txt">History.txt</a> を見れば載っているので、気になる人はぜひ。</p>
]]></description>
		</item>

	</channel>
</rss>
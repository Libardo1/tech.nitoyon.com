<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>てっく煮ブログ</title>
		<link>http://tech.nitoyon.com/ja/blog/index.xml</link>
		<description>All Technology is Boiled in This Site.</description>
		<language>ja</language>
		<copyright>Copyright nitoyon.</copyright>
		<lastBuildDate>Tue, 29 Oct 2013 09:31:30 +0000</lastBuildDate>
		<docs>http://blogs.law.harvard.edu/tech/rss</docs>
		<atom:link href="http://tech.nitoyon.com/ja/blog/index.xml" rel="self" type="application/rss+xml" />





		<item>
			<title>D3.js の d3.svg.line() を試してみた</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/10/29/d3js-svg-line/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/10/29/d3js-svg-line/</guid>
			<pubDate>Tue, 29 Oct 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>１つ前の記事 <a href="/ja/blog/2013/10/24/d3js/">D3.js の Data-Driven な DOM 操作がおもしろい</a> のサンプルコードではシンプルにするために、座標計算の処理を泥臭く書いていた。</p>

<p>たとえば</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript">  circles.enter()
    .attr(&#39;cx&#39;, function(d, i) { return i * 280 / n + 10; })
</code></pre></div>
<p>のような座標を計算する関数が何箇所かに散らばっていた。</p>

<p>これ、<code>d3.svg.line()</code> を使ったらまとめられるし、便利な <code>interpolate</code> の機能も使えるよ、というのが今回のお話。</p>

<h1>d3.svg.line() の使い方</h1>

<p>たとえば</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript">var line = d3.svg.line()
  .x(function(d, i) { return i; })
  .y(function(d, i) { return d * d; });
</code></pre></div>
<p>としておくことにする。<code>line.x()</code> とすると <code>function(d, i) { return i; }</code> を返してくれるので、関数を再利用してコードが読みやすくなる。<code>line.y()</code> も同様。</p>

<p>さらに、<code>line([5,2,4])</code> のようにして配列を渡すと <code>&quot;M0,25L1,4L2,16&quot;</code> を返す。これは <code>(1, 5*5)</code>、<code>(2, 2*2)</code>, <code>(3, 4*4)</code> を結んだ線を表す SVG である。</p>

<p>ま、これだけならちょっと便利かなぁ、というぐらいだけども、<code>line.interpolate(&quot;cardinal&quot;)</code> を実行しておくと、<code>line([5,2,4])</code> は <code>&quot;M0,25Q0.7999999999999999,4.9,1,4Q1.2,3.1,2,16&quot;</code> を返す。</p>

<p>これは、座標を曲線で結んだ SVG をあらわす。うまいこと計算してくれている。</p>

<h1>今回のサンプル</h1>

<p>というわけで、前回のサンプルを少し改善しつつ、各種の <code>interpolate</code> を試せるようにしたものを置いておく。</p>

<div>
<svg id="sample" width="300" height="300"
  style="background: white; border: .3em solid #ccc;"></svg>
</div>

<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>

<p><button onclick="random()">random</button>
<button onclick="push()">push</button>
<button onclick="pop()">pop</button>
<select id="line-interpolate">
  <option>linear</option>
  <option>linear-closed</option>
  <option>step</option>
  <option>step-before</option>
  <option>step-after</option>
  <option>basis</option>
  <option>basis-open</option>
  <option>basis-closed</option>
  <option>bundle</option>
  <option selected>cardinal</option>
  <option>cardinal-open</option>
  <option>cardinal-closed</option>
  <option>monotone</option>
</select>
<script src="d3js-svg-line.js" charset="utf-8"></script></p>

<h2>使い方</h2>

<ul>
<li>初期状態では 10 個の要素を持った配列を表示している。</li>
<li>横軸が配列のインデックス、縦軸が要素の値 (0～1) をあらわす。</li>
<li>[random] ボタンを押すと、配列の中身がランダムな値で置き換わる。</li>
<li>[push] ボタンを押すと、配列の末尾に要素を追加する。</li>
<li>[pop] ボタンを押すと、配列の末尾から要素を取り除く。</li>
<li>選択欄で <code>interpolate</code> の値を変更できる。</li>
</ul>

<p>ボタンを押すと、アニメーションつきで見た目が変更するのを確認していただけるだろうか (SVG をサポートしてる必要があるので、モダンではないブラウザーでは表示できない)。</p>

<h2>HTML のソース</h2>
<div class="highlight"><pre><code class="html language-html" data-lang="html">&lt;div&gt;
&lt;svg id=&quot;sample&quot; width=&quot;300&quot; height=&quot;300&quot;
  style=&quot;background: white; border: .3em solid #ccc;&quot;&gt;&lt;/svg&gt;
&lt;/div&gt;
&lt;script src=&quot;http://d3js.org/d3.v3.min.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;button onclick=&quot;random()&quot;&gt;random&lt;/button&gt;
&lt;button onclick=&quot;push()&quot;&gt;push&lt;/button&gt;
&lt;button onclick=&quot;pop()&quot;&gt;pop&lt;/button&gt;
&lt;select id=&quot;line-interpolate&quot;&gt;
  &lt;option&gt;linear&lt;/option&gt;
  &lt;option&gt;linear-closed&lt;/option&gt;
  &lt;option&gt;step&lt;/option&gt;
  &lt;option&gt;step-before&lt;/option&gt;
  &lt;option&gt;step-after&lt;/option&gt;
  &lt;option&gt;basis&lt;/option&gt;
  &lt;option&gt;basis-open&lt;/option&gt;
  &lt;option&gt;basis-closed&lt;/option&gt;
  &lt;option&gt;bundle&lt;/option&gt;
  &lt;option&gt;cardinal&lt;/option&gt;
  &lt;option&gt;cardinal-open&lt;/option&gt;
  &lt;option&gt;cardinal-closed&lt;/option&gt;
  &lt;option&gt;monotone&lt;/option&gt;
&lt;/select&gt;
&lt;script src=&quot;d3js-svg-line.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
</code></pre></div>
<h2>d3js-svg-line.js のソース</h2>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript">var svg = d3.select(&quot;svg#sample&quot;)
  .attr(&#39;width&#39;, 300).attr(&#39;height&#39;, 300)
  .style(&#39;display&#39;, &#39;block&#39;);
var polyline = svg.append(&#39;path&#39;)
  .attr(&#39;stroke&#39;, &#39;red&#39;)
  .attr(&#39;stroke-width&#39;, &#39;1&#39;)
  .attr(&#39;fill&#39;, &#39;transparent&#39;);

var values = [];
for (var i = 0; i &lt; 10; i++) {
  values.push(Math.random());
}
d3.select(&#39;#line-interpolate&#39;).on(&#39;change&#39;, update);

function update() {
  var n = values.length;

  var s = d3.select(&#39;#line-interpolate&#39;)[0][0];
  var interpolate = s.options[s.selectedIndex].value;

  var line = d3.svg.line()
    .x(function(d, i) { return (i + 1) * 300 / (n + 1); })
    .y(function(d, i) { return d * 280 + 10; })
    .interpolate(interpolate);

  var circles = svg.selectAll(&#39;circle&#39;).data(values);
  circles.enter()
    .append(&#39;circle&#39;)
    .attr(&#39;cx&#39;, line.x()).attr(&#39;cy&#39;, 0).attr(&#39;r&#39;, 0);
  circles.exit()
    .transition()
    .duration(300)
    .attr(&#39;cy&#39;, 0).attr(&#39;r&#39;, 0)
    .remove();
  circles
    .attr(&#39;fill&#39;, &#39;red&#39;)
    .transition()
    .duration(300)
    .attr(&#39;cx&#39;, line.x())
    .attr(&#39;cy&#39;, line.y())
    .attr(&#39;r&#39;, 6);
  polyline
    .transition()
    .duration(300)
    .attr(&#39;d&#39;, line(values));
}

function random() {
  var n = values.length;
  for (var i = 0; i &lt; n; i++) {
    values[i] = Math.random();
  }
  update();
}

function push() {
  values.push(Math.random());
  update();
}

function pop() {
  values.pop();
  update();
}

update();
</code></pre></div>]]></description>
		</item>

		<item>
			<title>D3.js の Data-Driven な DOM 操作がおもしろい</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/10/24/d3js/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/10/24/d3js/</guid>
			<pubDate>Thu, 24 Oct 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>ここんところ <a href="http://d3js.org/">D3.js</a> を触ってみているんだけど、これがなかなか面白い。</p>

<p><a href="http://d3js.org/"><center><img src="http://farm4.staticflickr.com/3767/10434503954_88b88529ce.jpg" width="500" height="313"></center></a></p>

<p>D3.js は「ビジュアライズ用のライブラリー」だと紹介されがちなんだけども、意外にも D3.js にはグラフを描画する機能がない。</p>

<p><a href="http://d3js.org/">D3.js</a> のトップページには次のように書いてある。</p>

<blockquote>
<p>D3.js はデータからドキュメントを生成するためのライブラリーです。D3 は HTML, SVG, CSS を使ってデータに命を吹き込みます。Web 標準を重要視しているので、独占的なフレームワークに縛られません。強力な<strong>ビジュアライズ用のコンポーネントと data-driven な DOM 操作手順</strong>を組み合わすことで、モダン ブラウザーの能力を最大限に活用できます。</p>

<blockquote>
<p>D3.js is a JavaScript library for manipulating documents based on data. D3 helps you bring data to life using HTML, SVG and CSS. D3’s emphasis on web standards gives you the full capabilities of modern browsers without tying yourself to a proprietary framework, combining <strong>powerful visualization components and a data-driven approach to DOM manipulation</strong>.</p>
</blockquote>
</blockquote>

<p>曰く、</p>

<ul>
<li>ビジュアライズ用のコンポーネント</li>
<li>data-driven な DOM 操作手順</li>
</ul>

<p>がウリらしい。</p>

<p>順番に見ていこう。</p>

<h1>ビジュアライズ用のコンポーネントの役割</h1>

<p>「ビジュアライズ用のコンポーネント」は<strong>「データ」と「チャートの種類」から「どこに描画すればいいか」を計算する</strong>機能だけを実装している。</p>

<h2>バブルチャートの例</h2>

<p><a href="(https://github.com/mbostock/d3/wiki/Gallery)">ギャラリー</a> の <a href="(http://bl.ocks.org/mbostock/4063269)">Bubble Chart</a> をみてみよう。</p>

<p><a href="http://bl.ocks.org/mbostock/4063269"><center><img src="http://farm8.staticflickr.com/7392/10442561554_9e73c2565b.jpg" width="500" height="259"></center></a></p>

<p>このチャートでは <a href="https://github.com/mbostock/d3/wiki/Pack-Layout"><code>d3.layout.pack()</code></a> という Pack Layout コンポーネントを利用している。</p>

<p>この例では、描画するノードの情報を、こんな形の JavaScript 配列をコンポーネントに渡している。</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript">[
  {
    className: &quot;AgglomerativeCluster&quot;,
    packageName: &quot;cluster&quot;,
    value: 3938
  },
  {
    className: &quot;CommunityStructure&quot;,
    packageName: &quot;cluster&quot;,
    value: 3812
  },
  {
    className: &quot;HierarchicalCluster&quot;,
    packageName: &quot;cluster&quot;,
    value: 6714
  },
  //...
]
</code></pre></div>
<p>これを <code>pack.nodes()</code> 関数に渡すと、<code>value</code> の値を元に計算して、ノードの位置情報をこんな感じで返す。</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript">[
  { /* root node の情報 */ },
  {
    className: &quot;AgglomerativeCluster&quot;,
    depth: 1,
    packageName: &quot;cluster&quot;
    parent: { /* root node */ },
    r: 22.159142384561406,
    value: 3938,
    x: 489.9621260527267,
    y: 532.5795625707091
  },
  {
    className: &quot;CommunityStructure&quot;,
    depth: 1,
    packageName: &quot;cluster&quot;,
    parent: { /* root node */ },
    r: 21.80175917979169,
    value: 3812,
    x: 535.3554715791261,
    y: 532.5795625707091
  },
  {
    className: &quot;&quot;HierarchicalCluster&quot;&quot;,
    depth: 1,
    packageName: &quot;cluster&quot;,
    parent: { /* root node */ },
    r: 28.933819019424202,
    value: 6714,
    x: 513.070926102582,
    y: 485.410700287188
  },
  // ...
]
</code></pre></div>
<p>いろんなプロパティーが追加されているけど、表示位置 (<code>x</code>, <code>y</code>) と半径 (<code>r</code>) の情報が返ってきている点に注目！</p>

<p>このように、ビジュアライズ用のコンポーネントは「データ」と「チャートの種類」から「どこに描画すればいいか」を計算するだけである。</p>

<h2>描画するには...</h2>

<p>この情報をどう画面に落とし込むかは実装側に任されている。</p>

<p>と聞くと、面倒そうに思えるかもしれないけど、<a href="(http://bl.ocks.org/mbostock/4063269)">Bubble Chart</a> のソースを見ると、描画処理はたったの 15 行。</p>

<p>それだけ簡単に描画できてしまうのは、D3.js の「data-driven な DOM 操作手順」を使って SVG を生成しているのが大きい。</p>

<h1>Data-Driven な DOM 操作を実感してみよう</h1>

<p><a href="http://d3js.org/">D3.js</a> には jQuery ライクな DOM 操作やイベント・アニメーション関係の API が用意されてる。jQuery を使ったことがある人なら簡単にマスターできるだろう。</p>

<p>jQuery にはないユニークな機能が <code>data()</code>・<code>enter()</code>・<code>exit()</code> 関数である。この関数の使い方を簡単なサンプルでみていこう。</p>

<p>JavaScript 上にこんな配列が定義されているとする。</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript">var shiritori = [&#39;りんご&#39;, &#39;ゴリラ&#39;, &#39;ラッパ&#39;];
</code></pre></div>
<p>HTML には入れ物の <code>&lt;ul&gt;</code> タグだけを用意しておく。</p>
<div class="highlight"><pre><code class="html language-html" data-lang="html">&lt;ul id=&quot;shiritori_list&quot;&gt;
&lt;/ul&gt;
</code></pre></div>
<p><code>&lt;ul&gt;</code> タグの中に <code>shiritori</code> 配列の中身を表示してみよう、というのがお題である。</p>

<h2>DOM の作成処理は data()＋enter()</h2>

<p>配列の中身を <code>&lt;ul&gt;</code> に追加するには、D3.js では次のように書く。</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript">// ul#shiritori_list を選択
d3.select(&#39;ul#shiritori_list&#39;)
  // その下の &lt;li&gt; を列挙
  .selectAll(&#39;li&#39;)
  // それぞれに shiritori 配列の要素を割り当てる
  .data(shiritori)
  // data より &lt;li&gt; が少ない場合は、足りない分について
  .enter()
  // &lt;li&gt; を追加する
  .append(&#39;li&#39;)
  // &lt;li&gt; の中身の文字を設定する
  .text(function(d, i) { return (i + 1) + &#39;番目は&#39; + d; });
</code></pre></div>
<p>これを実行すると、HTML はこうなる (なりそうですよね？　ね？)。</p>
<div class="highlight"><pre><code class="html language-html" data-lang="html">&lt;ul id=&quot;shiritori_list&quot;&gt;
  &lt;li&gt;1番目はりんご&lt;/li&gt;
  &lt;li&gt;2番目はゴリラ&lt;/li&gt;
  &lt;li&gt;3番目はラッパ&lt;/li&gt;
&lt;/ul&gt;
</code></pre></div>
<p>再度同じ JavaScript 処理を走らせるとどうなるだろう。<code>&lt;li&gt;</code> は 6 個になるだろうか。答えは「ならない」だ。</p>

<p>というのも、<code>enter()</code> 以降の処理は「<code>shiritori</code> 配列に対応する <code>&lt;li&gt;</code> がないとき」のみ実行される。「<code>&lt;li&gt;</code> の個数 ≦ <code>shiritori</code> 配列の要素数」である限りは何度実行しても <code>enter()</code> 以降は実行されない。</p>

<p>では、<code>shiritori.push(&#39;パイナップル&#39;)</code> として配列側を増やしてから、再度、上の JavaScript を走らせてみるとどうなるだろう。</p>

<p>そうすると、新規追加分の <code>&#39;パイナップル&#39;</code> に対してだけ、<code>enter()</code> 以降の処理が実行される。つまり、HTML は</p>
<div class="highlight"><pre><code class="html language-html" data-lang="html">&lt;ul id=&quot;shiritori_list&quot;&gt;
  &lt;li&gt;1番目はりんご&lt;/li&gt;
  &lt;li&gt;2番目はゴリラ&lt;/li&gt;
  &lt;li&gt;3番目はラッパ&lt;/li&gt;
  &lt;li&gt;4番目はパイナップル&lt;/li&gt;
&lt;/ul&gt;
</code></pre></div>
<p>となる。</p>

<p><code>enter()</code> は配列の増加分に対して、DOM を生成してくれるわけだ。</p>

<h2>DOM の削除処理は data()＋exit()</h2>

<p>次は、<code>shiritori</code> 配列が HTML より小さくなったときに対応しよう。</p>

<p><code>exit()</code> で削除方法を書く。</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript">// ul#shiritori_list を選択
d3.select(&#39;ul#shiritori_list&#39;)
  .select(&#39;ul#shiritori_list&#39;)
  // その下の &lt;li&gt; を列挙
  .selectAll(&#39;li&#39;)
  // それぞれに shiritori 配列の要素を割り当てる
  .data(shiritori)
  // data の数よりも多い &lt;li&gt; については
  .exit()
  // 削除する
  .remove();
</code></pre></div>
<p>はい。これで終わり。</p>

<p><code>shiritori</code> が減ってないときは何も起こらないし、<code>shiritori.pop();</code> してから実行すると末尾の <code>&lt;li&gt;</code> は消える。<code>shiritori = [];</code> してから実行すると <code>&lt;li&gt;</code> は消えてなくなる。</p>

<h2>DOM の更新処理は data()</h2>

<p>最後に更新処理。</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript">// ul#shiritori_list を選択
d3.select(&#39;ul#shiritori_list&#39;)
  // その下の &lt;li&gt; を列挙
  .selectAll(&#39;li&#39;)
  // それぞれに shiritori 配列の要素を割り当てる
  .data(shiritori)
  // &lt;li&gt; の中身の文字を設定する
  .text(function(d, i) { return (i + 1) + &#39;番目は&#39; + d; });
</code></pre></div>
<p><code>enter()</code> や <code>exit()</code> なしにすれば、更新時の処理になる。</p>

<p>データが与えられたときに、それぞれの要素をどのように表示すべきかを記述している。配列を書き換えて、この処理を実行すると、中身の文字が適切に更新される。</p>

<p>ここでは <code>text()</code> しか使ってないが、jQuery 的な <code>attr()</code> や <code>style()</code> を活用すれば、柔軟な指定が可能である。</p>

<h2>全部まとめる</h2>

<p>生成・削除・更新の処理をまとめてみる。</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript">function update_shiritori() {
  var s = d3.select(&#39;ul#shiritori_list&#39;)
    .selectAll(&#39;li&#39;)
    .data(shiritori);

  // 作成
  s.enter().append(&#39;li&#39;);

  // 削除
  s.exit().remove();

  // 更新
  s.text(function(d, i) { return (i + 1) + &#39;番目は&#39; + d; });
}
</code></pre></div>
<p>(「作成」のところで <code>text()</code> を実行しなくなっているが、そのあとの「更新」のところでまとめて設定できるのでご安心を)</p>

<p>完成したソースを改めて見てみると、</p>

<ul>
<li>作成: 増えたデータに対して DOM を追加</li>
<li>削除: 減ったデータに対して DOM を削除</li>
<li>更新: データに対応する表示に更新</li>
</ul>

<p>という処理がシンプルに書けているのが嬉しい。</p>

<p>同じような書き方を jQuery でやるのは難しい。たぶん「毎回 DOM ツリーを作り直す」という富豪的な手順をとると思う。それだと効率が悪いし、次の例にあるような増減に関係したアニメーションを実現するのは困難である。</p>

<h1>Data-Driven なアニメーション</h1>

<p>今度は、少し色気を加えて、アニメーションさせる。</p>

<div>
<svg id="sample2" width="300" height="300" style="background: white; border: .3em solid #ccc;"></svg>
</div>

<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>

<script src="d3js-enter-exit.js" charset="utf-8"></script>

<p><button style="padding: .5em .8em" onclick="change()">random</button>
<button style="padding: .5em .8em" onclick="add()">push</button>
<button style="padding: .5em .8em" onclick="del()">pop</button></p>

<h2>使い方</h2>

<ul>
<li>初期状態では 10 個の要素を持った配列を表示している。</li>
<li>横軸が配列のインデックス、縦軸が要素の値 (0～1) をあらわす。</li>
<li>[random] ボタンを押すと、配列の中身がランダムな値で置き換わる。</li>
<li>[push] ボタンを押すと、配列の末尾に要素を追加する。</li>
<li>[pop] ボタンを押すと、配列の末尾から要素を取り除く。</li>
</ul>

<p>ボタンを押すと、アニメーションつきで見た目が変更するのを確認していただけるだろうか (SVG をサポートしてる必要があるので、モダンではないブラウザーでは表示できない)。</p>

<h2>コンソールからの変更にも対応</h2>

<p>このページを開いている状態であれば、JavaScript コンソールで直接</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript">values = [0.5, 0, 1];
update();
</code></pre></div>
<p>と入力しても、アニメーションつきで配列が反映されるはずだ。</p>

<h2>更新部分のソースコード</h2>

<p>では、その <code>update()</code> 関数をみてみよう。</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript">function update() {
  // 配列の個数を n に代入
  var n = values.length;

  // &lt;svg&gt; の中の &lt;circle&gt; を列挙して、values を割り当てる
  var circles = d3.select(&quot;svg#sample2&quot;)
    .selectAll(&#39;circle&#39;).data(values);

  // 作成: 足りない &lt;circle&gt; を追加する
  circles.enter()
    .append(&#39;circle&#39;)
    .attr(&#39;fill&#39;, &#39;red&#39;)
    .attr(&#39;cx&#39;, function(d, i) { return i * 280 / n + 10; })
    .attr(&#39;cy&#39;, 0).attr(&#39;r&#39;, 0);

  // 削除: 余分な &lt;circle&gt; はアニメーションつきで削除
  circles.exit()
    .transition()
    .duration(300)
    .attr(&#39;cy&#39;, 0).attr(&#39;r&#39;, 0)
    .remove();

  // 更新: アニメーションで正しい位置とサイズに移動
  circles
    .transition()
    .duration(300)
    .attr(&#39;cx&#39;, function(d, i) { return i * 280 / n + 10; })
    .attr(&#39;cy&#39;, function(d, i) { return d * 280 + 10; })
    .attr(&#39;r&#39;, 6);

  // 線の位置も調整する
  d3.select(&#39;svg#sample2 polyline&#39;)
    .transition()
    .duration(300)
    .attr(&#39;points&#39;, values.map(function(d, i) {
      return (i * 280 / n + 10) + &#39; &#39; + (d * 280 + 10);
    }).join(&#39;,&#39;));
}
</code></pre></div>
<p>画面の描画は SVG で行っている。</p>

<p>削除と更新のときに <code>transition()</code> でアニメーションを指定してる点に注目。これがアニメーションの肝である。</p>

<p>円の大きさのアニメーションを例に説明する。</p>

<p>「追加」のときには <code>&lt;circle&gt;</code> の半径を <code>0</code> で初期化している。そのあとの「更新」で <code>6</code> にしてる。その結果、追加時には徐々に大きくなりながら画面に現れる。</p>

<p>ソースが長くなって、多少複雑になったが、「追加」「削除」「更新」の基本は変わっていない。</p>

<h1>まとめ</h1>

<p><a href="http://d3js.org/">D3.js</a> の Data-Driven な DOM 操作を説明した。入力されたデータに対して、「追加」「削除」「更新」の処理を分けて書くことで、驚くほどシンプルに記述できることが分かった。</p>

<p>基礎が分かったら、<a href="(https://github.com/mbostock/d3/wiki/Gallery)">ギャラリー</a> と <a href="(https://github.com/mbostock/d3/wiki/API-Reference)">API リファレンス</a> を見比べれば、いろんな使い方が分かってくることだろう。あと、SVG の知識も必要にはなってくる。</p>

<p>D3.js は「表示機能がない」という異色のビジュアライズ用のライブラリーだけども、表示処理を自由に操れるということは、見た目のカスタマイズをやりやすくなる。この手のライブラリーで一番苦労するのが、ちょっとしたカスタマイズをやりにくいところなので、こういう設計は実はありがたいのかもしれない。</p>
]]></description>
		</item>

		<item>
			<title>grunt-contrib-watch が重いので grunt-este-watch を試したら幸せになった</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/10/10/grunt-watch-slow/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/10/10/grunt-watch-slow/</guid>
			<pubDate>Thu, 10 Oct 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>最近、<a href="http://gruntjs.com/">Grunt</a> と <a href="https://github.com/gruntjs/grunt-contrib-watch"><code>grunt-contrib-watch</code></a> を使っているのだけど、<code>grunt-contrib-watch</code> が CPU を消費しがちである。</p>

<p>watch 対象のファイルが少ないうちは <code>grunt-contrib-watch</code> は問題なく動くんだけども、ファイル数が増えてくると CPU の消費量が増えてくる。自分の環境では、1,000 個ぐらいのファイルを監視していると、常時 10% 程度 CPU を消費している。</p>

<p>この問題は既知であり、<a href="https://github.com/gruntjs/grunt-contrib-watch/#why-is-the-watch-devouring-all-my-memorycpu">FAQ</a> には次のように書いている。</p>

<blockquote>
<p>たくさんのファイルを監視している場合、デフォルトの <code>interval</code> の値が小さすぎるかもしれない。<code>options: { interval: 5007 }</code> のようにして増やしてみてほしい。詳しくは issues <a href="https://github.com/gruntjs/grunt-contrib-watch/issues/35">#35</a> と <a href="https://github.com/gruntjs/grunt-contrib-watch/issues/145">#145</a> を参照のこと (※日本語訳は私によるもの)</p>

<blockquote>
<p>Another reason if you&#39;re watching a large number of files could be the low default <code>interval</code>. Try increasing with <code>options: { interval: 5007 }</code>. Please see issues <a href="https://github.com/gruntjs/grunt-contrib-watch/issues/35">#35</a> and <a href="https://github.com/gruntjs/grunt-contrib-watch/issues/145">#145</a> for more information.</p>
</blockquote>
</blockquote>

<h1>なぜ CPU を消費するのか？</h1>

<p><code>grunt-contrib-watch</code> はファイルの監視に <a href="https://github.com/shama/gaze"><code>gaze</code></a> というモジュールを使用している。</p>

<p><code>gaze</code> さんがファイルを監視するときには、ネイティブな監視 API の <code>fs.watch()</code> だけでなく、<code>fs.watchFile()</code> を併用している。<code>fs.watchFile()</code> は定期的に <code>fs.stat()</code> を実行しているだけであり、監視対象のファイルに変化がなくても CPU を消費する (詳しくは <a href="/ja/blog/2013/10/02/node-watch-impl/">Node.js の fs.watch() と fs.watchFile() の違い</a> をご覧あれ)。そのため、ファイルが増えるに従って、CPU の消費も激しくなるのである。</p>

<p>なんで <code>gaze</code> はわざわざ CPU 負荷が高くなる <code>fs.watchFile()</code> を利用しているのだろうか。それには歴史的な理由があるらしく、<a href="https://github.com/paulmillr/chokidar">chokidar/README.md</a> に <code>fs.watch()</code> についての愚痴が書いてある。</p>

<blockquote>
<p>Node.js の <code>fs.watch</code> は...</p>

<ul>
<li>Mac でファイル名を報告してくれない。</li>
<li>Mac で TextMate2 のようなエディターで編集したときに何もイベントが発生しない</li>
<li>ときどき、2 重にイベントを報告する。</li>
<li>利用価値のない <code>rename</code> イベントしかない。</li>
<li><a href="https://github.com/joyent/node/search?q=fs.watch&amp;type=Issues">他にもたくさんの問題</a>がある。</li>
</ul>

<p>(※日本語訳は私によるもの)</p>

<blockquote>
<p>Node.js <code>fs.watch</code>:</p>

<ul>
<li>Doesn&#39;t report filenames on mac.</li>
<li>Doesn&#39;t report events at all when using editors like TextMate2 on mac.</li>
<li>Sometimes report events twice.</li>
<li>Has only one non-useful event: <code>rename</code>.</li>
<li>Has <a href="https://github.com/joyent/node/search?q=fs.watch&amp;type=Issues">a lot of other issues</a></li>
</ul>
</blockquote>
</blockquote>

<h1>どうやって回避したか</h1>

<p>CPU 負荷が耐えられなくなったので、<code>grunt-contrib-watch</code> を諦めてみることにした。</p>

<p>検索して探したところ、<a href="https://github.com/steida/grunt-este-watch/"><code>grunt-este-watch</code></a> が便利そうであった。<a href="https://github.com/steida/grunt-este-watch/blob/master/README.md"><code>grunt-este-watch/README.md</code></a> には次のように書いてあった。</p>

<blockquote>
<p><em>公式の grunt-contrib-watch の問題点は何か？</em></p>

<p>遅い、そして、バグがある。というのも、公式のものは歴史的な理由で fs.watchFile と fs.watch を組み合わせて使っている。
Node の 0.9.2 以降では、fs.watch には問題はない。</p>

<p><a href="http://github.com/steida/este">github.com/steida/este</a> では最大限のパフォーマンスと安定性が必要だったので、新しい Node.js の file watcher を作る必要があった。この watcher は Mac, Linux, Windows で継続的にテストしている (※日本語訳は私によるもの)。</p>

<blockquote>
<p><em>What&#39;s wrong with official grunt-contrib-watch?</em></p>

<p>It&#39;s slow and buggy, because it uses combination fs.fileWatch and fs.watch, for
historical reason. From Node 0.9.2+, fs.watch is ok.</p>

<p><a href="http://github.com/steida/este">github.com/steida/este</a> Needs maximum performance and
stability, so that&#39;s why I had to create yet another Node.js file watcher.
This watcher is continuously tested on Mac, Linux, Win platforms.</p>
</blockquote>
</blockquote>

<p>この作者が試す限り問題はないようだ。信じて試してみたところ、<strong>待機中に CPU を消費しなくなくなった</strong>。万歳。</p>

<h2>設定例</h2>

<p>ためしにこのブログのビルド環境に組み込んでみた。<a href="https://github.com/nitoyon/tech.nitoyon.com/blob/b1fd0f12a6318b200390d8a2934d5cb66e46d454/Gruntfile.js"><code>Gruntfile.js</code></a> がこちら。</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript">module.exports = function(grunt) {
  grunt.initConfig({
    pkg: grunt.file.readJSON(&#39;package.json&#39;),
    shell: {
      jekyll_build: {
        command: &#39;jekyll build&#39;
      },
      // snip
    },
    // snip
    esteWatch: {
      options: {
        dirs: [&#39;./&#39;, &#39;_posts/*/&#39;, &#39;_layouts&#39;, &#39;_includes&#39;,
               &#39;javascript/**/&#39;, &#39;apollo/tutorial&#39;,
               &#39;_plugins/**/&#39;, &#39;stylesheets&#39;, &#39;javascripts&#39;],
        livereload: {
          enabled: false
        }
      },
      &#39;*&#39;: function(filepath) { return &#39;shell:jekyll_build&#39; }
    }
  });
</code></pre></div>
<p><code>grunt-este-watch</code> の設定は <code>grunt-contrib-watch</code> とかなり違う点に注意。</p>

<p><code>grunt-este-watch</code> は監視するディレクトリの一覧を記述する。ディレクトリ配下のファイルが変更されたら、コールバック関数が呼び出される。</p>

<p>自分のコールバック関数では、単純に <code>&#39;shell:jekyll_build&#39;</code> と返しているので、ファイルが更新されたら <code>grunt</code> は <code>shell:jekyll_build</code> タスクを実行してくれる。その気になれば <code>filepath</code> 引数に応じて、返すタスク名を変えることもできる。</p>

<p><code>&#39;*&#39;</code> ってのは「すべての拡張子」を意味する。特定の拡張子を指定することもできる。<a href="https://github.com/steida/grunt-este-watch/blob/master/README.md">grunt-este-watch/README.md</a> のサンプルを見ると分かりやすい。</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript">    coffee: function(filepath) {
      var files = [{
        expand: true,
        src: filepath,
        ext: &#39;.js&#39;
      }];
      grunt.config([&#39;coffee&#39;, &#39;app&#39;, &#39;files&#39;], files);
      grunt.config([&#39;coffee2closure&#39;, &#39;app&#39;, &#39;files&#39;], files);
      return [&#39;coffee:app&#39;, &#39;coffee2closure:app&#39;];
    },
    // snip
    css: function(filepath) {
      if (grunt.option(&#39;stage&#39;)) {
        return &#39;cssmin:app&#39;;
      }
    }
</code></pre></div>
<p><a href="https://github.com/gruntjs/grunt-contrib-watch"><code>grunt-contrib-watch</code></a> の CPU 負荷が高くて困っている人はぜひ試してみてほしい。</p>
]]></description>
		</item>

		<item>
			<title>Node.js の fs.watch() と fs.watchFile() の違い</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/10/02/node-watch-impl/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/10/02/node-watch-impl/</guid>
			<pubDate>Wed, 02 Oct 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>Node.js のファイル監視の API には <code>fs.watch()</code> と <code>fs.watchFile()</code> の 2 つがある。</p>

<p>微妙に機能がかぶっているし、使い分けが分かりにくかったので調べてみた。</p>

<h1>公式情報を見る</h1>

<p>まずは公式の<a href="http://nodejs.org/docs/v0.8.0/api/fs.html#fs_fs_watchfile_filename_options_listener">ドキュメント (v0.8.0)</a>を見てみた。</p>

<blockquote>
<h2>fs.watchFile(filename, [options], listener)</h2>

<p>Stability: 2 - Unstable.  Use fs.watch instead, if available.</p>

<p>Watch for changes on <code>filename</code>.</p>

<h2>fs.watch(filename, [options], [listener])</h2>

<p>Stability: 2 - Unstable.  Not available on all platforms.</p>

<p>Watch for changes on <code>filename</code>, where <code>filename</code> is either a file or a directory.</p>
</blockquote>

<p>と書いてある。</p>

<p>つまり</p>

<ul>
<li><code>fs.watch()</code> の利用を推奨している</li>
<li><code>fs.watch()</code> は全てのプラットフォームで使えるわけではない</li>
<li><code>fs.watch()</code> はファイルとディレクトリを監視できるが、<code>fs.watchFile()</code> はファイルしか監視できない</li>
</ul>

<p>ことが分かる。</p>

<h1>歴史的見地から調べる</h1>

<p>次に、過去をさかのぼるために <a href="https://github.com/joyent/node/blob/master/ChangeLog">ChangeLog</a> を見てみた。</p>

<ul>
<li><code>fs.watchFile()</code> は v0.1.18 で <code>process.watchFile()</code> として登場した古い API</li>
<li><code>fs.watch()</code> は v0.5.9 で実装された新しい API</li>
</ul>

<p>だと分かった。</p>

<p>しかし、これ以上の公式の情報が見つからなかったため、全体像が見えない。</p>

<h1>ソースコードを見る</h1>

<p>困ったらソースコードを見ろ、と昔の偉い人も言っている。いざ、コード リーディング！</p>

<h2>fs.watch()</h2>

<p>まずは、<code>fs.watch()</code> の実装をみてみよう。(ソースコードは執筆時点で最新の <a href="https://github.com/joyent/node/tree/v0.10.19">v0.10.19</a> を利用する)</p>

<p><a href="https://github.com/joyent/node/blob/v0.10.19/lib/fs.js"><code>lib/fs.js</code></a> → <a href="https://github.com/joyent/node/blob/v0.10.19/src/fs_event_wrap.cc#L102"><code>src/fs_event_wrap.cc</code></a> の順にたどっていくと、<code>uv_fs_event_init()</code> 関数が本丸だと分かった。</p>

<p><code>uv</code> で始まる関数は libuv で定義されたもの。libuv は Node.js のプラットフォーム間の差を吸収するためのライブラリらしく、IO やスレッド、タイマーなどの処理が実装されているようだ。</p>

<p>では、<code>uv_fs_event_init()</code> の実装を見てみる。<code>deps/uv/src</code> の下を grep してみると</p>

<ul>
<li>unix\aix.c</li>
<li>unix\cygwin.c</li>
<li>unix\kqueue.c</li>
<li>unix\linux-inotify.c</li>
<li>unix\sunos.c</li>
<li>win\fs-event.c</li>
</ul>

<p>が引っかかった。プラットフォームごとに実装が異なっているようだ。</p>

<p>ざっと読んでみると、</p>

<table><thead>
<tr>
<th>プラットフォーム</th>
<th>実装方法</th>
</tr>
</thead><tbody>
<tr>
<td>Linux</td>
<td>inotify を利用</td>
</tr>
<tr>
<td>MacOS、*BSD</td>
<td>kqueue を利用</td>
</tr>
<tr>
<td>Windows</td>
<td><code>ReadDirectoryChangesW()</code> を利用</td>
</tr>
<tr>
<td>Solaris</td>
<td>Event Ports を利用</td>
</tr>
<tr>
<td>AIX</td>
<td>(未対応)</td>
</tr>
<tr>
<td>Cygwin</td>
<td>(未対応)</td>
</tr>
</tbody></table>

<p>となっていた。</p>

<p>つまり、<strong>fs.watch() はネイティブの監視処理を利用して、変更があったら OS から通知してもらっている</strong>ことが分かった。</p>

<h2>fs.watchFile()</h2>

<p>一方の <code>fs.watchFile()</code> を見てみる。Node.js には古くから実装されているが、現在では利用が推奨されていないほうの関数である。</p>

<p><a href="https://github.com/joyent/node/blob/v0.10.19/lib/fs.js"><code>lib/fs.js</code></a> → <a href="https://github.com/joyent/node/blob/v0.10.19/src/node_stat_watcher.cc#L112"><code>src/node_stat_watcher.cc</code></a> の順にたどっていくと、<code>uv_fs_poll_start()</code> 関数が本丸だと分かった。</p>

<p>あとは、<code>uv_fs_poll_start()</code> の流れをつかめばおしまい。<a href="https://github.com/joyent/node/blob/v0.10.19/deps/uv/src/fs-poll.c#L56"><code>deps/uv/src/fs-poll.c</code></a> を見てみよう。なんとなくポーリングをしていそうな名前である。</p>
<div class="highlight"><pre><code class="c language-c" data-lang="c">int uv_fs_poll_start(uv_fs_poll_t* handle,
                     uv_fs_poll_cb cb,
                     const char* path,
                     unsigned int interval) {
  // 初期化処理は省略

  if (uv_fs_stat(loop, &amp;ctx-&gt;fs_req, ctx-&gt;path, poll_cb))
    abort();
</code></pre></div>
<p>肝は <code>uv_fs_stat()</code> の呼び出し。この関数は、Node.js で言うところの <code>fs.stat()</code> 相当の処理だろう。ファイルの更新日時の取得を依頼して、取得が完了したら、<code>poll_cb()</code> が呼ばれる。</p>

<p>その <a href="https://github.com/joyent/node/blob/v0.10.19/deps/uv/src/fs-poll.c#L139"><code>poll_cb()</code></a> を見てみよう。</p>
<div class="highlight"><pre><code class="c language-c" data-lang="c">static void poll_cb(uv_fs_t* req) {
  // 異常処理とか、前回と違ってたらイベント発行する処理とか

  /* Reschedule timer, subtract the delay from doing the stat(). */
  interval = ctx-&gt;interval;
  interval -= (uv_now(ctx-&gt;loop) - ctx-&gt;start_time) % interval;

  if (uv_timer_start(&amp;ctx-&gt;timer_handle, timer_cb, interval, 0))
    abort();
}
</code></pre></div>
<p>実行結果の解析が終わったら、<code>interval</code> 後に <code>timer_cb()</code> が呼ばれるようにタイマーを開始している。</p>

<p><code>timer_cb()</code> では、再度 <code>uv_fs_stat()</code> を実行している。つまり、定期的に <code>fs.stat()</code> を実行している。</p>

<p>つまり、<strong>fs.watchFile() は定期的に fs.stat() をポーリングで実行して、変更されたらイベントを発行している</strong> ことが分かった。非常に原始的な実装になっている。</p>

<h1>まとめ</h1>

<p><code>fs.watch()</code>:</p>

<ul>
<li>新しい API、利用が推奨されている</li>
<li>push 型 (OS の監視機能を利用しているので、待機中に CPU を消費しない)</li>
<li>一部のプラットフォーム (AIX、Cygwin) では利用できない</li>
</ul>

<p><code>fs.watchFile()</code>:</p>

<ul>
<li>古い API、あまり使ってほしくなさそう</li>
<li>poll 型 (定期的に stat を実行する)</li>
<li>どのプラットフォームでも動く</li>
</ul>
]]></description>
		</item>

		<item>
			<title>LiveReloadX を Grunt から使えるようにした</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/07/29/livereloadx0-3-0/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/07/29/livereloadx0-3-0/</guid>
			<pubDate>Mon, 29 Jul 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p><a href="http://nitoyon.github.io/livereloadx/">LiveReloadX</a> に少し手を入れて <a href="http://gruntjs.com/">Grunt</a> のタスクとして動作させられるようにした。</p>

<p>今回のバージョンは 0.3.0。新規インストールするなら今まで通り <code>npm install -g livereloadx</code> で、バージョンアップするなら <code>npm update -g livereloadx</code> でどうぞ。</p>

<p>設定手順は <a href="http://nitoyon.github.io/livereloadx/">LiveReloadX</a> の「Run as a Grunt Task」あたりを参照してもらうとして、この記事では実装した背景を説明しておこう。</p>

<h1>Grunt に対応させる価値</h1>

<p><a href="http://gruntjs.com/">Grunt</a> は、サイトの生成にあたっての必要な処理をひとまとめにできるのでとても便利である。そこに live reload する機能まで含んでいればさらに便利そうである。</p>

<p>といっても、実は、公式の <a href="https://github.com/gruntjs/grunt-contrib-watch#optionslivereload">grunt-contrib-watch</a> プラグインに live reload 機能はついている。</p>

<p>じゃあ、公式でよさそうなのだけど、公式を使うためには「HTML に JavaScript のスニペットを埋め込む」か「ブラウザ拡張を導入する」必要がある。<code>grunt-contrib-watch</code> のページに <a href="https://github.com/intesso/connect-livereload">connect-livereload</a> を使う方法も紹介されてるが、そっちは少し煩雑そうだった。</p>

<p><a href="http://nitoyon.github.io/livereloadx/">LiveReloadX</a> の一番のウリが static モードと proxy モードで、JavaScript スニペットの埋め込みを Web サーバー側でやってくれる。この機能を使いたかったので、<a href="http://nitoyon.github.io/livereloadx/">LiveReloadX</a> 自体を <a href="http://gruntjs.com/">Grunt</a> に組み込んでみた。</p>

<p>組み込むにあたっては、Grunt のドキュメントを見たり、各種プラグインのソースを見たりすれば、だいたいの方法は分かったので、比較的簡単に対応できた。</p>

<h1>ブログ書くのがさらに手軽になった</h1>

<p>個人的には、今回の機能によって、ブログを書くのがとても楽になった。</p>

<p>いままでは、このブログを書くにあたって、<code>jekyll</code> と <code>livereloadx</code> を個別に実行していた。</p>

<p>以前、<a href="/ja/blog/2013/06/25/jekyll-grunt/">Jekyll で --watch の代わりに Grunt を使ってみるテスト</a> で書いたとおり、<a href="https://github.com/mojombo/jekyll">Jekyll</a> を <a href="http://gruntjs.com/">Grunt</a> から使うことには成功していた。今回、<a href="http://nitoyon.github.io/livereloadx/">LiveReloadX</a> も組み合わせられるようになった。</p>

<p>つまり、<code>grunt</code> と実行するだけで</p>

<ul>
<li>Web サーバーが起動して、Jekyll のビルド結果を確認できる</li>
<li>Markdown 記法の記事をテキストエディターから編集したら、<code>jekyll</code> が走って HTML を生成する。</li>
<li>表示しているページの HTML や画像が生成されたら、自動でブラウザーがリロードされる</li>
</ul>

<p>という環境が整った。</p>

<p>このブログのソースコードは <a href="https://github.com/nitoyon/tech.nitoyon.com">nitoyon/tech.nitoyon.com - GitHub</a> を参照してほしい。</p>

<p>理想のブログ環境に近づいてきた。</p>
]]></description>
		</item>

	</channel>
</rss>
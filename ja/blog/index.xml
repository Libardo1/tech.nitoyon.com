<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>てっく煮ブログ</title>
		<link>http://tech.nitoyon.com/ja/blog/index.xml</link>
		<description>All Technology is Boiled in This Site.</description>
		<language>ja</language>
		<copyright>Copyright nitoyon.</copyright>
		<lastBuildDate>Fri, 25 Jan 2013 01:51:45 +0000</lastBuildDate>
		<docs>http://blogs.law.harvard.edu/tech/rss</docs>
		<atom:link href="http://tech.nitoyon.com/ja/blog/index.xml" rel="self" type="application/rss+xml" />









		<item>
			<title>はてなブックマークの入れ替わり激しくない人気エントリーを見る方法</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/01/25/old-hotentry/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/01/25/old-hotentry/</guid>
			<pubDate>Fri, 25 Jan 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p><a href="http://b.hatena.ne.jp/">はてなブックマーク</a>のトップページがリニューアルして、新しいデザインへの不満が一通り<a href="http://www.itmedia.co.jp/news/articles/1301/09/news089.html">出つくした</a>感があるけど、<strong>人気エントリーのアルゴリズムが改善された</strong>件について触れてる人をあまり見ない。</p>

<h1>人気エントリーの入れ替わりが激しくなった</h1>

<p>いままでは人気エントリーはキャッチーなやつで固定化されていたんだけど、今回の改善で、人気エントリーの入れ替わりが激しくなった。</p>

<p>公式にもアナウンスはされていて、<a href="http://hatena.g.hatena.ne.jp/hatenabookmark/20130108/1357641152">トップページとカテゴリページをリニューアルしました - はてなブックマーク日記</a> によると</p>

<blockquote>
<p>滞留や偏りをなくすためにアルゴリズムを変更いたしました。一定時間でコンテンツが入れ替わるよう更新性を高めています。その日にしかチェックできない、新鮮なエントリーが楽しめるようになりました。人気エントリーのアルゴリズムは、今後も継続的に改善してまいります。</p>
</blockquote>

<p>とある。</p>

<h2>いままでは「ブックマーク数」至上主義だった</h2>

<p>いままでの人気エントリーのアルゴリズムはきわめて単純だった。</p>

<p>「時間当たりのブックマーク数が多い順」。</p>

<p>単純で分かりやすいが弊害もある。人気を集めてトップページに掲載されると、それを見てブックマークする人が出てくるので、人気のある記事は半永久的にブックマークを集め続けられた。</p>

<p>キャッチーな記事は数日間トップページに居座り続けていたし、そうじゃなくても、「○○の××個まとめ」といった似たような記事ばかりトップページに載っていた。</p>

<p>結果、「すごく人気を集める記事」と「そこそこ需要はあるはずなのに人目に触れずに消えていく記事」に二分されていた。</p>

<h2>「鮮度」が重視されるようになった</h2>

<p>このような問題を改善するために、今回、「時間あたりのブックマーク数」だけでなく「情報の鮮度」が重視されるようになったようだ。しばらく人気エントリーに居座っていると、たとえブックマークを集めていてもランキングが落ちていく。</p>

<p>そのおかげで、以前よりもエントリーの入れ替わりが激しくなり、タイムリーに話題になっている記事が分かるようになった。いままでは人目に触れずに消えていったような記事がトップページでピックアップされやすくなった。</p>

<p>少し極端な例をあげてみる。これはとある日の、はてブトップページ。</p>

<p><center><img src="http://farm9.staticflickr.com/8045/8410686001_b50affeacb.jpg" width="500" height="404"></center></p>

<p>1 位が「55 users」、2 位が「42 users」。短い時間にブックマークを集めれば、50 users ほどでも 1 位になれるのだ。</p>

<p>(ただし、これでは極端すぎると判断したのか 1 週間後に<a href="http://hatena.g.hatena.ne.jp/hatenabookmark/20130116/1358333640">スコアリングが補正</a>されている。現在では 100～200 users ぐらい集めないと 1 位にはならないような印象がある)</p>

<h1>以前の計算方法で人気エントリーを見たい！</h1>

<p>さて、タイムリーな話題が分かるようになったのはいいけど、みんながみんな、四六時中、はてなブックマークを見ているわけではない。</p>

<p>タイムリーな記事ではなく、今日話題になっている記事を知りたい、という人も多いはずだ。</p>

<h2>日別ランキングがあるじゃないか</h2>

<p>実は、以前の人気エントリーに相当するようなページがある。</p>

<p>それが <a href="http://b.hatena.ne.jp/hotentry/daily">http://b.hatena.ne.jp/hotentry/daily</a> だ。<code>daily</code> という URL の通り、その 1 日の人気エントリーがブックマーク数順に並んでいるようだ。</p>

<p><a href="http://b.hatena.ne.jp/hotentry/daily"><center><img src="http://farm9.staticflickr.com/8468/8410686199_3366103bc6.jpg" width="500" height="418"></center></a></p>

<p>上位にブックマーク数の多いエントリーが並んでいる。昔の人気エントリーのアルゴリズムと完全に同じではないんだけど、かなり近い印象がある。懐かしい・・・。</p>

<p>一番下までスクロールすると、過去の日付にさかのぼるリンクもある。前日・前々日あたりの人気のエントリーが気になるなら、そちらもチェックするとよいだろう。</p>

<h2>週間・月間ランキングもあるよ</h2>

<p>さらに少し長いスパンでの人気エントリーを探したい場合は、</p>

<ul>
<li><a href="http://b.hatena.ne.jp/ranking">はてなブックマークランキング - 週間ランキング</a></li>
<li><a href="http://b.hatena.ne.jp/ranking/monthly">はてなブックマークランキング - 月間ランキング</a></li>
</ul>

<p>を見るとよい。</p>

<p><a href="http://b.hatena.ne.jp/ranking"><center><img src="http://farm9.staticflickr.com/8183/8410686329_e3d0be8450.jpg" width="500" height="379"></center></a></p>

<p>新しいトップページからはリンクされてないけど・・・。</p>

<h1>まとめ</h1>

<p>人気エントリーの算出方法が変わってタイムリーな記事が上位に来るようになったよ、前のような「ブックマーク数至上主義」なランキングを見たいなら <a href="http://b.hatena.ne.jp/hotentry/daily">日別ランキング</a>、<a href="http://b.hatena.ne.jp/ranking">週間別ランキング</a>、<a href="http://b.hatena.ne.jp/ranking/monthly">月間ランキング</a> が便利だよ、というお話でした。</p>

<p>新しいトップページについての個人的な感想は</p>

<ul>
<li>確かに一覧性は悪くなったけど、初めて見る人には親しみやすいデザインになったんじゃないかな。</li>
<li>Google Chrome で <code>[Ctrl] + [+]</code> で拡大しても文字サイズが変わらないのを何とかしてほしい。</li>
<li>Nexus 7 を横にしてカテゴリーページを開いたら「見やすい」と感じたので、「タイル」はスマホ・タブレット向きのデザインなんだろう。これからの Web サービスは PC と携帯デバイスの見え方の違いをどう吸収していくかが課題になりそう。</li>
<li>人気エントリーの新しいアルゴリズムは非常によい。トップページを見る頻度が上がった。</li>
</ul>

<p>といったところ。</p>
]]></description>
		</item>

		<item>
			<title>GitHub で clone するときは SSH じゃなく HTTP を使ったほうが高速</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/01/11/github-clone-http/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/01/11/github-clone-http/</guid>
			<pubDate>Fri, 11 Jan 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p><center><img src="http://farm9.staticflickr.com/8082/8367926710_8530642335_o.png" width="571" height="221"></center></p>

<p>GitHub には clone するための URL として [HTTP]、[SSH]、[Git Read-Only] の 3 つが用意されている。</p>

<p>いままで、SSH に慣れているという理由だけで [SSH] を利用していたのだけど、「<strong>SSH は転送速度が遅い</strong>」という問題がある。</p>

<h1>SSH だとこんなに遅い…</h1>

<p>さっき、[SSH] で clone してみたら 20～60 KiB/s 程度の速度しか出なかった。</p>
<div class="highlight"><pre><code class="text">$ git clone git@github.com:nitoyon/tech.nitoyon.com.git
Cloning into &#39;tech.nitoyon.com&#39;...
remote: Counting objects: 8856, done.
remote: Compressing objects: 100% (2125/2125), done.
remote: Total 8856 (delta 3251), reused 8731 (delta 3126)
Receiving objects: 100% (8856/8856), 7.04 MiB | 26 KiB/s, done.
Resolving deltas: 100% (3251/3251), done.
</code></pre></div>
<p>↑最終的に <code>26 KiB/s</code> しか出ていない。</p>

<p>これでは、巨大なリポジトリを clone すると、長大な時間を要することになる。</p>

<h1>HTTP は高速！</h1>

<p>そんなときは、 [HTTP] で clone すればよい。</p>

<p>さっき試したら、300～600 KiB/s 出た。</p>
<div class="highlight"><pre><code class="text">$ git clone https://github.com/nitoyon/tech.nitoyon.com.git
Cloning into &#39;tech.nitoyon.com&#39;...
remote: Counting objects: 8856, done.
remote: Compressing objects: 100% (2125/2125), done.
remote: Total 8856 (delta 3251), reused 8731 (delta 3126)
Receiving objects: 100% (8856/8856), 7.04 MiB | 604 KiB/s, done.
Resolving deltas: 100% (3251/3251), done.
</code></pre></div>
<p>↑<code>604 KiB/s</code> も出ている</p>

<p>[Git Read-Only] も試してみたら、こちらは 1 MiB/s ぐらいでたので一番高速だった。</p>

<p><s>つまり、[HTTP] が最強！　他の 10 倍速い。</s></p>

<p>つまり、速さは [Git Read-Only] &gt; [HTTP] &gt;&gt; [SSH] となった。</p>

<p>(訂正) 当初、[HTTP] が最強としていましたが、再度調べてみたところ、[Git Read-Only] が最強でした。お詫びして訂正します。</p>

<h1>push が面倒なら clone 後に SSH にすればよい</h1>

<p>[SSH] で clone したときのメリットは、push のときには ssh-agent なり pageant なりが、パスフレーズの入力を代行してくれる点にある。<code>git push</code> と入力するだけで push を開始できてお手軽だ。</p>

<p>一方、[HTTP] で clone してしまうと、push するたびにユーザー名とパスワードを要求されて面倒だ。<a href="https://help.github.com/articles/set-up-git#platform-windows">credential helper</a> を導入すればキャッシュしてくれるらしいが、これも面倒だ。</p>

<p>[Git Read-Only] だと Read-Only という名前の通り、push できない。</p>

<p>それが理由で、いままで [SSH] でちんたら clone していた。</p>

<p>けども、よく考えたら [HTTP] や [Git Read-Only] で clone したあとでも、[SSH] で push するように設定を変更できる。</p>
<div class="highlight"><pre><code class="text">$ git remote set-url origin git@github.com:user/repo.git
</code></pre></div>
<p><code>git remote</code> で <code>origin</code> の URL を変えるだけ。この手順は <a href="https://help.github.com/articles/why-is-git-always-asking-for-my-password">GitHub のヘルプ</a>にも書いてある。</p>

<p>これ以降の push / pull は [SSH] でやるようになる。[HTTP] に比べて転送速度は遅いけど、1度 clone したあとなら、差分のみの送受信なので、あまり速度は気にしなくてもよいはずだ。(もし大量に送受信する必要が出たなら、同じようにして再度 [HTTP] に切り替えてもよいだろう)</p>

<h1>(追記) SSH も設定を変えれば速くなる</h1>

<p><code>~/.ssh/config</code> に次の設定をすれば、SSH でも十分速くなるようです。</p>
<div class="highlight"><pre><code class="text">Host github.com
  Compression yes
  Ciphers arcfour256
</code></pre></div>
<p>はてなブックマークで id:y-kawaz さんに<a href="http://b.hatena.ne.jp/y-kawaz/20130111#bookmark-127926818">指摘していだきました</a>。ありがとうございます。</p>

<h1>まとめ</h1>

<p>次のような戦略が考えられる。</p>

<ul>
<li>push する必要がないなら [Git Read-Only] で clone すると高速。</li>
<li>[SSH] の clone は <code>~/.ssh/config</code> を設定すると速度が劇的に改善する。</li>
<li>clone したあとに、<code>git remote set-url</code> で URL を変更すれば、push するプロトコルを変更できる</li>
</ul>

<p>快適な GitHub 生活を。</p>
]]></description>
		</item>

		<item>
			<title>うちの年賀状2013</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/01/08/nenga/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/01/08/nenga/</guid>
			<pubDate>Tue, 08 Jan 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>毎年恒例で、一年の最初のエントリは我が家の年賀状でのご挨拶です。</p>

<p><center><img src="http://farm9.staticflickr.com/8327/8357146769_ddc6a148bd.jpg" width="357" height="500"></center></p>

<p>今年は映画ポスター風の実写で作成してみました。</p>

<h1>twitter アイコン</h1>

<p>毎年、twitter のアイコンを年賀状から抜粋しているのですが、自分の実写の顔をそのまま twitter のアイコンにするのは抵抗があったので、12 年前に描いた年賀状を使うことにしました。12 年間、データが残っていたのが驚き。</p>

<p><center><img src="http://farm9.staticflickr.com/8083/8357161789_f84bd3d726_o.jpg" width="612" height="612"></center></p>

<p>今年もよろしくおねがいします。</p>
]]></description>
		</item>

		<item>
			<title>Jekyll の 0.12.0 でシンタックス ハイライトが便利になった</title>
			<link>http://tech.nitoyon.com/ja/blog/2012/12/25/jekyll-0-12-0/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2012/12/25/jekyll-0-12-0/</guid>
			<pubDate>Tue, 25 Dec 2012 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>※ これは <a href="https://www.google.co.jp/search?q=%E3%81%9D%E3%82%93%E3%81%AA%E3%82%82%E3%81%AE%E3%81%AF%E3%81%AA%E3%81%84">Jekyll アドベントカレンダー</a> の 25 日目の記事です</p>

<p>このブログの生成にも利用している Jekyll が約 1 年ぶりにバージョン アップして 0.12.0 になった。<a href="http://rubygems.org/gems/jekyll">RubyGems</a> に公開されているので、<code>gem update</code> で更新できるはず。</p>

<p>この記事では、0.12.0 で個人的に注目している「シンタックス ハイライトに関する改善点」を 2 つ紹介する。</p>

<p>Jekyll の良さについては、<a href="/ja/blog/2012/09/20/moved-completed/">俺の最強ブログ システムが火を噴くぜ</a> で記事にしているので、知らない人はそちらからどうぞ。</p>

<h1>Redcarpet 2 のサポート</h1>

<p>まず 1 つ目は Redcarpet 2 のサポート。</p>

<p>Redcarpet は GitHub の中の人によって開発されている Markdown パーサーて、<a href="http://github.github.com/github-flavored-markdown/">GitHub Flavored Markdown</a> が使えるのが大きな特徴。</p>

<p>これまでも Jekyll では Redcarpet をサポートしていたが、Redcarpet 2 で外部 API が変わったので、Jekyll からは利用できない状態になっていた。</p>

<p>今回、Jekyll 0.12.0 で Redcarpet 2 の API に対応した。個人的には <code>```</code> での Fenced code blocks が使えるようになったのがうれしい。</p>

<p>たとえば、</p>
<div class="highlight"><pre><code class="text">```ruby
def fib(n);
    n &lt;= 1 ? n : fib(n-1)+fib(n-2)
end
print fib(10)
```
</code></pre></div>
<p>と書くと</p>
<div class="highlight"><pre><code class="ruby">def fib(n);
    n &lt;= 1 ? n : fib(n-1)+fib(n-2)
end
print fib(10)
</code></pre></div>
<p>となる。</p>

<p>これまでは「<code>{% highlight ruby %}</code> と <code>{% endhighlight %}</code> で囲う」という面倒な書き方をしなきゃならなかった。どうしても <code>```</code> を使いたいときは <a href="http://mattn.kaoriya.net/software/lang/ruby/20121011184445.htm">Big Sky :: Jekyll で GitHub みたいな Triple Backtick を使う。</a> のように、独自にプラグインを作るハックもあるにはあった。</p>

<p>ちなみに、Redcarpet を利用するには、<code>_config.yml</code> に次のように書くのを忘れずに。</p>
<div class="highlight"><pre><code class="yaml">markdown:    redcarpet
</code></pre></div>
<h1>シンタックス ハイライトの高速化</h1>

<p>2 つ目は速度の話。</p>

<p>Jekyll はシンタックス ハイライトに pygments を使っている。Ruby で動く Jekyll から、Python で動く pygments を利用するには、何らかの工夫が必要になる。</p>

<p>Jekyll 0.11.2 までは <a href="https://github.com/github/albino">Albino</a> を使っていた。Albino はハイライトするたびに、Python のプロセスを実行して結果を取得していた。ハイライトするコード 1 つごとに Python が 1 プロセス立ち上がっていたので、当然、遅かった。</p>

<p>そこで、Jekyll 0.12.0 では <a href="https://github.com/tmm1/pygments.rb">pygments.rb</a> が利用されるようになった。pygments.rb は高速化のための工夫がほどこされている。</p>

<p>pygments.rb には 0.2 系と 0.3 系があって、それぞれ別の高速化手法が使われていて面白い。</p>

<h2>pygments.rb 0.2 は RubyPython で無理やり</h2>

<p>0.2 では、<a href="http://rubypython.rubyforge.org/">rubypython</a> という Ruby 上で Python インタプリターを動かすライブラリーを使っている。<a href="https://github.com/ffi/ffi">FFI</a> で動的ライブラリーを読み込んでがんばっているようだ。</p>

<p>導入にはビルド環境が必要なので面倒だけど、劇的に高速化された。同一プロセス内で完結するので、プロセス起動のオーバーヘッドが 0 になる。</p>

<p>と、そこまではよかったのだけど、Ruby ごと落ちることがある。再現性はない。うまくいくこともあるし、落ちることもある。自分の環境が Windows だから不安定なのかと思いきや、Jekyll の Issue にも<a href="https://github.com/mojombo/jekyll/pull/667">上がっている</a> ので、RubyPython か FFI の問題なのだろう。</p>

<h2>pygments.rb 0.3 は Python を使いまわす</h2>

<p>0.2 の「Ruby 上で Python」作戦は不安定だったため、0.3 では純粋な Python を呼び出す方式に戻った。ただ、毎回呼び出すのではなく、プロセスを使いまわすようにした。</p>

<p>0.3 でハイライト処理を開始すると、Ruby と pygments を媒介する Python スクリプト <code>mentos.py</code> が立ち上がる。Ruby からは標準入出力を使って <code>mentos.py</code> に処理依頼をして、ハイライト結果を受け取る。複数回ハイライトを実行しても、同じプロセスを使いまわす。</p>

<p>純粋な Python が動くので、プロセスが死ぬような心配もない。0.2 のころに比べれば少しだけオーバーヘッドはある印象だが、Albino に比べれば十分速い。プロセス内に取り込むという暴挙に出て手に負えなくなったものが、ひとたび我に返って、実用に耐える速さと安定性を手に入れた。</p>

<p>ただし、最新の pygments 0.3.3 は Windows では動かない。<code>/dev/null</code> が見つからないなど、いろいろエラーになったので、動くようにして <a href="https://github.com/tmm1/pygments.rb/pull/55">pull request</a> を出しておいた。取り込まれるといいな。(追記) 取り込まれて 0.3.4 として公開された!!</p>

<h1>まとめ</h1>

<p>Jekyll 0.12.0 の個人的にうれしいところをざっと紹介した。その他の変更点は <a href="https://github.com/mojombo/jekyll/blob/master/History.txt">History.txt</a> を見れば載っているので、気になる人はぜひ。</p>
]]></description>
		</item>

		<item>
			<title>text-hatena.js を GitHub に移動した</title>
			<link>http://tech.nitoyon.com/ja/blog/2012/12/21/text-hatena-js-github/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2012/12/21/text-hatena-js-github/</guid>
			<pubDate>Fri, 21 Dec 2012 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>2005 年ごろに作成して放置していた <a href="http://tech.nitoyon.com/javascript/application/texthatena/download.html">text-hatena.js</a> について、twitter で</p>

<blockquote class="twitter-tweet" lang="ja"><p>@<a href="https://twitter.com/nitoyon">nitoyon</a> さん、2005年くらいのtext-hatena.js をGitHub等に公開は可能でしょうか？ <a href="http://t.co/Z6zylivM" title="http://tech.nitoyon.com/javascript/application/texthatena/download.html">tech.nitoyon.com/javascript/app…</a></p>&mdash; テラまこさん (@teramako) <a href="https://twitter.com/teramako/status/280642151715594240" data-datetime="2012-12-17T11:54:37+00:00">12月 17, 2012</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>というツッコミを受けたので GitHub で公開してみました。</p>

<ul>
<li><a href="https://github.com/nitoyon/text-hatena.js">nitoyon / text-hatena.js - GitHub</a></li>
</ul>

<p>いま text-hatena.js のコードを読み返すと、グローバルな名前空間を汚染してたり、Object.extend() を定義してたりと、いろいろ酷い。</p>

<p>当時は今に比べると JavaScript の知識も浅かったが、浅いなりに prototype.js のコードを読んだり、真似したりして勉強していたことを思い出した。</p>

<h1>2005 年の話</h1>

<p>text-hatena.js を公開した 2005 年といえば Web 2.0 だとか Ajax という言葉がバズっていて、ちょうどはてなブックマークが登場したあたりでもあった。</p>

<p>はてなブックマークは今よりも遥かに技術者寄りで、ホットエントリーには 2ch まとめや NAVER まとめの姿はなく、Ajax や JavaScript の話であふれていた。それらの記事を目を輝かせながら読み漁っていた。</p>

<p>自分もホットエントリーの仲間に入りたくて作ったものの 1 つが text-hatena.js だった。</p>

<p>公開当時にそこそこ話題になったのもうれしかったが、その後に層々たる人がプレゼン資料やブラウザー拡張に活用してくれたのがうれしかった。もしかしたら、自分が作ったものの中で、一番、人の役に立ってるのかもしれない。</p>

<h1>2012 年の話</h1>

<p>せっかく GitHub に公開するのだから、ついでに 2012 年っぽく書き直してみることにした。</p>

<p>実践したのは次の 3 つ。</p>

<ul>
<li>QUnit で単体試験を定義</li>
<li>無名関数でグローバル変数を汚さないようにしつつ、node.js でも動くように</li>
<li>Grunt でファイルを監視して lint &amp; QUnit</li>
</ul>

<p>特に Grunt を組み込んだことで、ファイルを変更するたびに自動で lint して単体試験が走るのが便利だ。設定を少し変えれば、コード結合や minify もできちゃう。可能性を感じる。</p>

<p>考えてみると、jQuery や node.js は 2005 年当時は存在すらしていなかった。Google Chrome はもちろん Firebug もなかった。</p>

<p>prototype.js が全盛の時代にちまちまブラウザーで動作試験していたコードが、7 年のときを経て、現代の技術を活用して効率的に開発できるようになったわけで、隔世の感で胸が熱くなる。</p>
]]></description>
		</item>

	</channel>
</rss>
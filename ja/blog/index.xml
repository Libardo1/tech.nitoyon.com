<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>てっく煮ブログ</title>
		<link>http://tech.nitoyon.com/ja/blog/index.xml</link>
		<description>All Technology is Boiled in This Site.</description>
		<language>ja</language>
		<copyright>Copyright nitoyon.</copyright>
		<lastBuildDate>Tue, 25 Jun 2013 01:37:12 +0000</lastBuildDate>
		<docs>http://blogs.law.harvard.edu/tech/rss</docs>
		<atom:link href="http://tech.nitoyon.com/ja/blog/index.xml" rel="self" type="application/rss+xml" />









		<item>
			<title>Jekyll で --watch の代わりに Grunt を使ってみるテスト</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/06/25/jekyll-grunt/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/06/25/jekyll-grunt/</guid>
			<pubDate>Tue, 25 Jun 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>このブログでは <a href="https://github.com/mojombo/jekyll">Jekyll</a> を使ってることは何度か書いたのだけど、いままで記事を書くときには <code>jekyll --auto</code> を実行した状態で書いていた。このようにしておくと、ファイルを書き換えたら自動的にサイトをビルドしてくれるようになる。ただ、このコマンドを実行してると CPU がグオーンと音を上げ始め、クアッドコアで CPU 使用率 25% に達するという地球に優しくない状態であった。</p>

<p>原因を調べてみると <code>directory_watcher</code> モジュールが犯人だった。このモジュールは、監視対象のディレクトリー配下の全ファイルに対して、毎秒、<code>File::Stat()</code> を実行する、という富豪的実装になっている。もちろん、ファイルの数が少ないときには問題なく動くんだけども、ファイルの数が増えると CPU を浪費してしまう。</p>

<p>たとえば、このサイトの場合、600 個以上の記事があって、Jekyll が 900 個のファイルを生成する。しかも、<code>.git</code> フォルダーの下には 5,000 個程度のファイルがある。ひどいことに、Jekyll 0.12 までのバージョンは、これらのファイルすべてを監視対象にする。毎秒 6,500 個のファイルを stat するわけだから、当然、CPU は振り切る。</p>

<p>Jekyll 1.0 になって、コマンドも <code>jekyll build --watch</code> に変わって、<code>_site</code> (サイトの出力先) や <code>.git</code> が監視対象から外れたので、パフォーマンスはだいぶ改善した。それでも自分の環境で常時 10% ぐらい CPU を消費し続けている。</p>

<p>ということで、<code>--watch</code> (もしくは <code>--auto</code>) オプションの代わりに、流行の <a href="http://gruntjs.com/">Grunt</a> を使ってみることにした。</p>

<h1>Grunt の設定ファイル</h1>

<p>使っているバージョンやプラグインは次の通り。</p>

<ul>
<li>Jekyll 1.0.3</li>
<li>Grunt 0.4.1

<ul>
<li><code>grunt-shell-spawn</code> プラグイン</li>
<li><code>grunt-contrib-watch</code> プラグイン</li>
</ul></li>
</ul>

<p>最初は、<code>grunt-shell-spawn</code> ではなく <code>grunt-jekyll</code> を使ってたんだけど、<code>grunt-jekyll</code> は Jekyll を実行中の途中経過を表示してくれないので使うのをやめた。</p>

<p>Grunt の使い方については <a href="http://gruntjs.com/getting-started">Getting started - Grunt</a> を見たほうが早いだろうから、ここでは <code>package.json</code> と <code>Gruntfile.js</code> を紹介する。</p>

<h2>package.json</h2>
<div class="highlight"><pre><code class="json language-json" data-lang="json">{
  &quot;name&quot;: &quot;tech-ni&quot;,
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;devDependencies&quot;: {
    &quot;grunt&quot;: &quot;~0.4.1&quot;,
    &quot;grunt-shell-spawn&quot;: &quot;~0.2.4&quot;,
    &quot;grunt-contrib-watch&quot;: &quot;~0.4.4&quot;
  }
}
</code></pre></div>
<h2>Gruntfile.js</h2>
<div class="highlight"><pre><code class="js language-js" data-lang="js">module.exports = function(grunt) {
  grunt.initConfig({
    pkg: grunt.file.readJSON(&#39;package.json&#39;),
    shell: {
      jekyll: {
        command: &#39;jekyll build&#39;,
        options: {
          async: false
        }
      }
    },
    watch: {
      jekyll: {
        files: [&#39;_posts/**/*.md&#39;, &#39;_layout/*.html&#39;, &#39;_includes/*.html&#39;],
        tasks: [&#39;shell:jekyll&#39;]
      }
    }
  });

  grunt.loadNpmTasks(&#39;grunt-shell-spawn&#39;);
  grunt.loadNpmTasks(&#39;grunt-contrib-watch&#39;);

  grunt.registerTask(&#39;default&#39;, [&#39;shell:jekyll&#39;]);
};
</code></pre></div>
<p>(Jekyll 0.12 までを使用している場合は、<code>jekyll build</code> を <code>jekyll</code> で置き換えるべし)</p>

<h1>使い方</h1>

<p><code>grunt watch</code> を実行すると、ファイルの監視を始める。記事や HTML が編集されたら、<code>jekyll build</code> が実行されるようになっている。</p>

<p>しかし、Jekyll で監視するよりも CPU 消費量は小さいが・・・0 ではない・・・!?　と、ここで調べてみて気づいたんだけども、Grunt の watch は、ネイティブ API の <code>fs.watch()</code> を使ってファイルを監視していない!!!　<code>gaze</code> モジュールを使って定期的にファイルを stat しているだけだった。</p>

<p>これでは Ruby の <code>directory_watcher</code> と同じである。</p>

<p>どうやら、Node.js の <code>fs.watch()</code> は Mac OS でファイル名を取れなかった過去があるなど、歴史的に不安定であり、結局、stat で独自に監視する、という手順が一般的になったようだ。なんという罠。</p>
]]></description>
		</item>

		<item>
			<title>ブログのタグ機能が復活したよ</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/06/17/blog-tag/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/06/17/blog-tag/</guid>
			<pubDate>Mon, 17 Jun 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>昨年 9 月に<a href="/ja/blog/2012/09/20/moved-completed/">はてなダイアリーから引っ越した</a>ときにタグ機能が消えてしまっていたのですが、このたび、重い腰をあげて復活させました。</p>

<p>たとえばこの記事の場合、上側の日付の右にタグが 2 つあることにお気づきいただけるでしょうか。タグ名をクリックすると、そのタグがついた記事の一覧が表示できますよ。</p>

<p>ついでに、既存のタグも整理しています。統廃合したり、無意味なものを消したり。整理した結果がこの<a href="/ja/blog/tags/">タグ一覧</a>。</p>

<p><center><img src="http://farm8.staticflickr.com/7325/9056245193_eccb68e139.jpg" width="500" height="225"></center></p>

<p>トップページの記事一覧にもタグを表示するようにしました。</p>

<p><center><img src="http://farm8.staticflickr.com/7387/9055850365_dafbc8f937.jpg" width="500" height="348"></center></p>

<h1>Jekyll のタグ機能をカスタマイズ</h1>

<p><a href="/ja/blog/2012/09/20/moved-completed/">以前に書いた</a>とおり、このブログの出力には <a href="https://github.com/mojombo/jekyll/">Jekyll</a> を使っています。Jekyll 本体には、記事に<a href="/en/blog/2013/04/17/jekyll-pluralize/">タグを設定する機構</a>は用意されているのですが、タグの記事一覧を出力する機能がなくて、自前で実装する必要があります。</p>

<p>そこで、<a href="https://github.com/BlackBulletIV/blackbulletiv.github.com/">blackbulletiv.github.com</a> さんの <a href="https://github.com/BlackBulletIV/blackbulletiv.github.com/blob/master/_plugins/tags_categories.rb">tags_categories.rb</a> を参考にしつつ、「日本語タグだけど URL は英語」「複数ブログ対応」といったあたりを実現するために、いろいろと手をいれてカスタマイズしています。</p>

<p>詳しくは、</p>

<ul>
<li><a href="https://github.com/nitoyon/tech.nitoyon.com/blob/master/_plugins/tags.rb">tags.rb</a></li>
<li><a href="https://github.com/nitoyon/tech.nitoyon.com/blob/master/_plugins/filters/tag_filter.rb">tag_filter.rb</a></li>
<li><a href="https://github.com/nitoyon/tech.nitoyon.com/blob/master/_config.yml">_config.yml</a></li>
</ul>

<p>あたりを見れば雰囲気が分かると思います。</p>

<h1>この後の野望</h1>

<p>このあとやってみたいことは・・・</p>

<ul>
<li>サイト内検索:<br>あると便利なのは間違いないし、検索向け AdSense というのがあるらしい。</li>
<li>サムネール:<br>各記事にサムネールを設定して、それを利用したデザインになると嬉しい。</li>
<li>Web フォント:<br>フラットなデザインが流行しつつあるので、Web フォントを使ったアイコンの利用率も増えてきそう。</li>
<li>2 カラム化:<br>スクロールすると固定するカラムには興味ある。せっかく 1 カラム化したのだけど・・・。</li>
<li>Jekyll 1.0 対応:<br>いつのまにか正式版が出ていたらしい。何が便利になったのか、まだ追えていない。</li>
</ul>

<p>そんなことより、もっと頻繁に記事を書けよ、という感じではありますが・・・。</p>
]]></description>
		</item>

		<item>
			<title>Bugzilla に登録してあるバグをプログラムから更新する方法</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/05/17/bugzilla-hack/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/05/17/bugzilla-hack/</guid>
			<pubDate>Fri, 17 May 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>会社で BTS として Bugzilla を使っているんだけど、修正したあとに手作業で Web インターフェースから書き込むのが面倒になってきたので、自動化してみた。</p>

<p>コミットしたとき (Git の場合は push したとき) に、コミットメッセージからバグ番号を読み取って、対応するバグにメッセージを書き込みつつ、FIXED にすればよい。</p>

<p>情報がなくて困ったのが、バグにコメントを書いたり、FIXED にする方法。この部分の処理を抜き出してみた。</p>
<div class="highlight"><pre><code class="perl language-perl" data-lang="perl">#!/usr/bin/perl -I/path/to/bugzilla -I/path/to/bugzilla/lib

use strict;
use Bugzilla;
use Bugzilla::User;
use Bugzilla::Status;
use Bugzilla::Bug;
use utf8;

&amp;update_bug(1, &quot;ほげほげ&quot;);

# API document: http://www.bugzilla.org/docs/4.2/en/html/api/
sub update_bug {
    my ($bug_id, $text) = @_;

    # open bug
    my $bug = Bugzilla::Bug-&gt;new($bug_id);
    die $bug-&gt;error if defined $bug-&gt;error;

    # get user
    my $user = Bugzilla::User-&gt;new({name =&gt; &#39;admin@example.com&#39;});
    die &#39;user not found!!!!&#39; unless defined $user;

    # login
    Bugzilla-&gt;set_user($user);

    # comment to the bug
    $bug-&gt;add_comment($text);

    # FIXED
    $bug-&gt;set_bug_status(Bugzilla::Status-&gt;new({name =&gt; &#39;RESOLVED&#39;}),
                         {resolution =&gt; &#39;FIXED&#39;});

    # save to database
    $bug-&gt;update();
}
</code></pre></div>
<p>Bugzilla 4.2.5 で動作を確認している。</p>

<p>あとは、Git なら <code>post-receive</code> フックで、コミットログを解析して、この関数を呼ぶようにすればよい。</p>

<p>注意点:</p>

<ul>
<li>Bugzilla がインストールされているサーバー上で動くことを前提としている。同一サーバーならパスワードなしで、特定のユーザーに su できるようだ。</li>
<li><code>Bugzilla::Bug</code> はドキュメント化されていないので、バージョンアップしたら使えなくなる可能性がある。同じような機能の <code>Bugzilla::WebService::Bug</code> はドキュメントがあるんだけど、使おうとしたら <code>Test/Taint.pm</code> が必要だとか言われて面倒になったのでやめた。</li>
</ul>
]]></description>
		</item>

		<item>
			<title>git commit --amend を省力化する方法</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/05/02/git-commit-amend/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/05/02/git-commit-amend/</guid>
			<pubDate>Thu, 02 May 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>Git で最後のコミットを修正するときには <code>git commit --amend</code> を使うんだけども、いままでは</p>

<ol>
<li><code>git add .</code></li>
<li><code>git commit --amend</code></li>
<li>エディターが立ち上がって、前回のコミット メッセージが表示される</li>
<li>エディターを終了させる</li>
</ol>

<p>としていた。</p>

<p>この作業は何度も繰り返すと面倒だったので、man を調べてみると <code>--no-edit</code> なるステキなオプションを発見した。</p>

<h1>--no-edit を使う</h1>

<p><code>--no-edit</code> を指定すると、上の手順はこうなる。</p>

<ol>
<li><code>git add .</code></li>
<li><code>git commit --amend --no-edit</code></li>
</ol>

<p>コミット メッセージはそのままに、コミットの中身だけを書き換えられる。エディターが立ち上がらないので楽チン。</p>

<h1>-a でさらに省力化</h1>

<p>さらに <code>git add .</code> も省力化できて</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">git commit -a --amend --no-edit
</code></pre></div>
<p>とすればよい。</p>

<p><strong>コマンド一発</strong>になった。超楽チン。</p>

<p>注意点は次の 2 つ。</p>

<ul>
<li>新しいファイルを追加したときは明示的に add する必要がある。<code>git add .</code> と <code>git commit -a</code> ではステージするファイルが違うので注意。</li>
<li>コミットしたくない変更がワーキング ディレクトリーに残ってる状態では使えない。<code>git stash</code> するなどでよけておくべし。</li>
</ul>
]]></description>
		</item>

		<item>
			<title>Google Chrome で超手軽にスマホ向けデザインを確認する方法</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/04/23/chrome-responsive-debug/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/04/23/chrome-responsive-debug/</guid>
			<pubDate>Tue, 23 Apr 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>最近、<strong>Google Chrome のデベロッパー ツールにスマートフォンでの表示を確認する機能がある</strong>ことを知りました。</p>

<p>いままでは、レスポンシブデザイン Web デザインをするときに、ちまちまとブラウザーのサイズを変えたり、Web サービス (<a href="http://mattkersley.com/responsive/">Responsive Design Testing</a> とか <a href="http://designmodo.com/responsive-test/">Responsive Web Design Test Tool</a> とか) を使っていたのですが、こちらの手順のほうがお手軽なので紹介します。</p>

<h1>設定は超簡単！！</h1>

<p>Google Chrome のデベロッパー ツールを開いて、右下の歯車のアイコンをクリックします。</p>

<p>左側から [Overrides] を選んで、[User Agent] と [Device metrics] にチェックを入れます。</p>

<p><center><img src="http://farm9.staticflickr.com/8260/8672447614_28f45f8d1d.jpg" width="500" height="296"></center></p>

<p>これだけです！</p>

<h2>ためしに Yahoo! を表示してみよう</h2>

<p>[User Agent] で [iPhone -- iOS 4] を選んでから Yahoo! のトップページを開いてみると・・・。</p>

<p><center><img src="http://farm9.staticflickr.com/8114/8672493580_8246647f79.jpg" width="500" height="477"></center></p>

<p>m.yahoo.co.jp にリダイレクトされて、iPhone 4 のサイズで表示されました。</p>

<p>解像度指定の右にあるボタンを押すと「縦横切り替え」ができます。リロード不要です！</p>

<p><center><img src="http://farm9.staticflickr.com/8379/8672493572_927d7e0e0e.jpg" width="485" height="500"></center></p>

<p>横方向になると、画面の構成が少し変わりましたね。</p>

<p>今度は [iPad -- iOS 5] にしてみます。リロードしてみると・・・。</p>

<p><center><img src="http://farm9.staticflickr.com/8397/8671392997_2fc220a0eb.jpg" width="500" height="377"></center></p>

<p>はい、PC 版にリダイレクトされて、iPad のサイズで表示できました。</p>

<p>User Agent も切り替えてくれるので、レスポンシブ Web デザインに対応したサイトだけでなく、User Agent で表示を切り替えているサイトも確認できますね。</p>

<h2>登録されているスマートフォン一覧</h2>

<p>Google Chrome 26 に登録されているスマートフォンは次のもの。</p>

<ul>
<li>iPhone -- iOS 5</li>
<li>iPhone -- iOS 4</li>
<li>iPad -- iOS 5</li>
<li>iPad -- iOS 4</li>
<li>Android 2.3 -- Nexus S</li>
<li>Android 4.0.2 -- Galaxy Nexus</li>
<li>BlackBerry -- PlayBook 2.1</li>
<li>BlackBerry -- 9900</li>
<li>BlackBerry -- BB10</li>
<li>MeeGo -- Nokia N9</li>
</ul>

<p>試したい機種が登録されていなくても心配後無用。User Agent や解像度は手入力も可能です。</p>

<h2>気になるところ</h2>

<p>注意しなきゃいけないのは、<strong>スマートフォンの表示を完全にエミュレートできるわけではない</strong>、ということです。PC 版ブラウザーでUserAgent と表示サイズを変更しているだけだと割り切りましょう。</p>

<p>まず、viewport の設定が無視されます。そのため、viewport の設定によっては実際のスマートフォンでの表示と異なります。</p>

<p>たとえば、Yahoo! のモバイル版では viewport に <code>device-width</code> が設定してあるので、iPhone 4 では横幅 <code>320px</code> 相当で描画されるべきです。しかし、実際には <code>640px</code> 相当で描画してしまってます。実際の iPhone の表示に近づけるためには、サイズを <code>320px</code> に変更しなきゃいけません。</p>

<p>他にも、[Fit in window] をチェックすると、ブラウザーの領域内に収まるように表示してくれて便利なのですが、iPad の設定で Yahoo! のトップページを開くと横スクロールバーが表示されて変でした。[Fit in window] のチェックを外すと表示されないので、ズーム関係の処理と CSS の何かの指定がバッティングしてるのかもしれません。</p>

<p>ということで、最終確認は必ず実機でやるべきです。それでも、この機能を活用すれば、開発効率はかなり改善するはずです！</p>

<h1>まとめ</h1>

<p>Google Chrome に統合されているので、とてもお手軽に試せることが分かりました。レスポンシブ Web デザインしている場合も、サーバー側で User Agent みている場合でも、どちらでも活用できるのが便利です。大手サイトのスマホ デザインを確認するのも手軽にできるのが嬉しいですね。</p>

<p>ちなみに、User Agent を変更する機能は 2012 年 2 月の <a href="http://googlesystem.blogspot.jp/2011/12/changing-user-agent-new-google-chrome.html">Chrome 17 から提供</a>、サイズを変更する機能は 2012 年 10 月から<a href="http://blog.chromium.org/2012/10/do-more-with-chrome-developer-tools.html">提供されている</a>ようです。</p>
]]></description>
		</item>

	</channel>
</rss>
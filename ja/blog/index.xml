<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>てっく煮ブログ</title>
		<link>http://tech.nitoyon.com/ja/blog/index.xml</link>
		<description>All Technology is Boiled in This Site.</description>
		<language>ja</language>
		<copyright>Copyright nitoyon.</copyright>
		<lastBuildDate>Fri, 05 Apr 2013 01:23:32 +0000</lastBuildDate>
		<docs>http://blogs.law.harvard.edu/tech/rss</docs>
		<atom:link href="http://tech.nitoyon.com/ja/blog/index.xml" rel="self" type="application/rss+xml" />









		<item>
			<title>SourceTree が Git のグローバルな無視リストを書き換えて困った話</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/04/05/sourcetree/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/04/05/sourcetree/</guid>
			<pubDate>Fri, 05 Apr 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>Git を使ってるときに、<code>git status</code> に存在するはずのファイルが Untracked files に出てこない現象に出会って困ってしまった。</p>

<p>いろいろ調べてみたところ、SourceTree さんがインストール時にグローバルな無視リストを作成していたことが判明した。SourceTree を使ってないときにも影響がでるのでたちが悪い。</p>

<h1>勝手に書き換えられてしまうファイルはこれだ!!</h1>

<p>Windows 版の例だけど、まず、<code>.gitconfig</code>。</p>
<div class="highlight"><pre><code class="ini">[core]
    excludesfile = C:\\Users\\username\\Documents\\gitignore_global.txt
</code></pre></div>
<p>Mac の場合は <code>/User/username/.gitignore_global</code> に設定する模様。</p>

<p>gitignore_global.txt はこんな感じ。</p>
<div class="highlight"><pre><code class="text">#ignore thumbnails created by windows
Thumbs.db
#Ignore files build by Visual Studio
*.obj
*.exe
*.pdb
*.user
*.aps
*.pch
*.vspscc
*_i.c
*_p.c
*.ncb
*.suo
*.tlb
*.tlh
*.bak
*.cache
*.ilk
*.log
*.dll
*.lib
*.sbr
</code></pre></div>
<p>Windows 系の開発で自動生成されたり、コミットする必要のないファイルが列挙されている。</p>

<h1>.gitconfig に excludesfile がないときに発動</h1>

<p>セットアップ時に、最初のダイアログには [Allow SourceTree to modify global Git and Mercurial config files] という設定項目がある。</p>

<p><center><img src="http://farm9.staticflickr.com/8382/8619841968_d036e18115.jpg" width="470" height="500"></center></p>

<p>デフォルトでチェック入ってるんだけど、これが入ってる以上は、<code>.gitconfig</code> がいじられても文句は言えない。</p>

<p>デフォルトのままで先に進むと、<code>.gitconfig</code> に <code>excludesfile</code> の設定がない場合には SourceTree さんは上に書いたような書き換えを行ってくれる。</p>

<p>シンセツダナー。</p>

<p>この親切すぎて涙がでてしまう挙動は、当然のように一部のユーザーの逆鱗に触れることとなり、非難轟々、雨嵐霰がふき乱れた。</p>

<blockquote class="twitter-tweet" lang="ja"><p>@<a href="https://twitter.com/daniellangnet">daniellangnet</a> Sorry this caused you hassle. We don't do this if you have a global ignore already, and it's a checkbox in the setup wizard</p>&mdash; SourceTree updatesさん (@sourcetree) <a href="https://twitter.com/sourcetree/status/314672749203308544">2013年3月21日</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>「最低なやつめ！　なんで gitignore_global.txt を勝手に作って .dll と .exe を除外しちゃうんだよ！？」というユーザーのお怒りの声。</p>

<p>これに対して、「怒らせてごめんよ。すでにグローバルな ignore ファイルがあればそんなことはしないよ。」と答える SourceTree さん。</p>

<blockquote class="twitter-tweet" lang="ja"><p>@<a href="https://twitter.com/daniellangnet">daniellangnet</a> We defaulted that to 'Yes' if you have no global ignore, trying to help people new to git, since committing dlls/exes is rare</p>&mdash; SourceTree updatesさん (@sourcetree) <a href="https://twitter.com/sourcetree/status/314672902148616192">2013年3月21日</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>「git に不慣れな人を助けるために、グローバルな ignore ファイルがないならそうしてるんだよ。だって、exe や dll をコミットすることなんてめったにないでしょ？」。まぁ、それはそうなんだけども・・・。</p>

<blockquote class="twitter-tweet" lang="ja"><p>@<a href="https://twitter.com/daniellangnet">daniellangnet</a> We'll draw attention to that setup option more clearly in the next update to avoid this for people who commit binaries</p>&mdash; SourceTree updatesさん (@sourcetree) <a href="https://twitter.com/sourcetree/status/314674613844062208">2013年3月21日</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>「次のリリースでは、もうちょっと注意を引きやすい警告を出すようにして、バイナリー ファイルをコミットしたい人を困らせないようにするよ」と、将来のバージョン アップを誓っている。</p>

<h1>最近は警告ダイアログをだしてくれる</h1>

<p>で、その結果、最近のリリースでは、こんなダイアログが表示されるようになった。</p>

<p><center><img src="http://farm9.staticflickr.com/8391/8619841994_5093182205_o.png" width="623" height="344"></center></p>

<p>ざっと訳すと</p>

<blockquote>
<p>グローバルな ignore ファイルがないようだけど、SourceTree がデフォルトのやつを設定したげようか？</p>

<p>.exe とか .dll とか .obj とか .suo とか Debug のようなフォルダーとか、普通はソース管理しないようなやつを追加しといてあげるよ。</p>

<p>もし、デフォルトで全部のファイルをみれるようにしたいなら、とりあえず No を選んどいてね。あとで、Tools &gt; Options から設定することもできるよ。</p>
</blockquote>

<p>と書いてある。</p>

<p>次のキャプチャーを見る限りは Mac 版でも「グローバル無視リスト」を書き換える処理はあるようだ。</p>

<p><center><img src="http://farm9.staticflickr.com/8525/8618737121_b83669bf6a.jpg" width="500" height="456"></center></p>

<p>(画像は <a href="http://kashewnuts-tech.blogspot.jp/2011/11/macgitmercurialgui-sourcetree.html">kashew_nuts-tech: Mac用Git/MercurialのGUIクライアント-SourceTree-を試してみた</a> より)</p>

<h1>まとめ</h1>

<p>SourceTree の Windows 版を試した人 (特に初期のバージョン) は、マイドキュメント直下に <code>gitignore_global.txt</code> がないか確認しておくとよいだろう。このファイルが残っていると、Git を使っていて無駄に混乱してしまうかもしれない。分かってて設定する分にはいいんだけども。</p>
]]></description>
		</item>

		<item>
			<title>Git で複数ブランチを同時に扱いたいなら git-new-workdir が便利</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/03/29/git-new-workdir/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/03/29/git-new-workdir/</guid>
			<pubDate>Fri, 29 Mar 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>Git で管理してるレポジトリーで、いくつかのブランチを別々の場所にチェックアウトしたいことがある。</p>

<p>たとえば</p>

<ul>
<li>GUI なツールでブランチ間の比較したい</li>
<li>同時に実行して比較しつつテストしたい</li>
<li>ブランチ間でファイルをコピーしたい</li>
<li>ドキュメントの生成結果を別ブランチで管理したい</li>
</ul>

<p>といったときに、必要になる。</p>

<p>ブランチの個数だけ clone しちゃえば用は足りそうなんだけど、でかいレポジトリーだったら時間もディスク容量ももったいない。</p>

<h1>git-new-workdir を使うべきでしょう！</h1>

<p>先日、「git-new-workdir を使えばワーキング ディレクトリーを複数を作れて便利」と書いてあるブログを読んだ。</p>

<ul>
<li><a href="http://subtech.g.hatena.ne.jp/secondlife/20121207/1354854068">git-new-workdir が便利 - #生存戦略 、それは - subtech</a></li>
</ul>

<p><code>git-new-workdir</code> の usage を見てたら、別ブランチのワーキング ディレクトリー作成にも対応しているらしい！</p>
<div class="highlight"><pre><code class="text">git-new-workdir &lt;repository&gt; &lt;new_workdir&gt; [&lt;branch&gt;]
</code></pre></div>
<p>これは活用しない手はない。</p>

<h2>git-new-workdir はこんなに便利</h2>

<p><code>master</code> ブランチで作業しているとして、<code>develop</code> ブランチの中身も展開したいと思ったとする。</p>
<div class="highlight"><pre><code class="text">git-new-workdir . ../foo-develop develop
</code></pre></div>
<p>これだけで <code>../foo-develop</code> に <code>develop</code> ブランチの中身を展開してくれる。</p>

<p>展開の処理に工夫があって、ワーキングディレクトリーとステージ (インデックス) は独立なんだけど、コミット履歴などはシンボリックリンクで共有されている。</p>

<p>だから、ワーキング ディレクトリーの中身を比較できるのはもちろん、別々の場所で編集してコミットしてもよい。片方でコミットした内容は、もう片方で <code>git log</code> すれば表示できる。</p>

<p><code>git push</code> すれば <code>master</code> と <code>develop</code> の両方の変更を一気に push できる。別々に clone していたらありえない。</p>

<p>もちろん、<code>git fetch</code> も、どちらか一方で実行すれば、もう片方も最新の状態になってる。</p>

<p>いろいろ便利でハッピー！</p>

<h2>ドキュメントを別ブランチで管理するような場合にも使える</h2>

<p>GitHub Pages を使うときにはありがちなんだけど、ドキュメントの生成結果を別ブランチにコミットする。このブログでは、Jekyll でサイト生成した結果を別ブランチにコミットしている (詳しくは <a href="/ja/blog/2012/09/20/moved-completed/">俺の最強ブログ システムが火を噴くぜ</a> 参照)。</p>

<p>このようなケースには、サブモジュールを使うテクニックが知られている。</p>

<ul>
<li><a href="http://blog.64p.org/entry/20100310/1268189518">Doxygen を github-pages にあげるのをお気楽にやる方法 - tokuhirom&#39;s blog.</a></li>
<li><a href="http://tell-k.hatenablog.com/entry/2012/01/20/020531">github のプロジェクトにSphinxドキュメントを良さげな感じにおきたい 其の二 - Study08.net 対シンバシ殲滅用人型機動兵器</a></li>
<li><a href="http://blog.kaihatsubu.com/?p=1836">GitHub 上に ページを作成する | Tanablog</a></li>
</ul>

<p>このテクニックは一見便利そうなんだけども、使っているうちに不便なところが目に付いてきた・・・。</p>

<ul>
<li>同じレポジトリーを 2 回 clone するので非効率的。</li>
<li>2 つの作業ディレクトリーのそれぞれで push, pull しなきゃいけない。</li>
<li>ドキュメントのディレクトリーでコミットするたびに、submodule が更新された状態になる。それを放置してると、<code>submodule init</code> した人が古い状態のツリーを参照してしまうので、定期的にコミットして、サブモジュールの指す先を更新する必要がある。</li>
</ul>

<p>サブモジュールはそもそも別の Git レポジトリーを管理するために設計されたものだし、同じレポジトリーをサブモジュールとして持つのはいろいろ弊害あるように思う。</p>

<p>で、サブモジュールに困っていたところで、<code>git-new-workdir</code> を使ってみたら便利だった。</p>

<p>開発用ブランチが <code>master</code> で、ドキュメントのブランチが <code>gh-pages</code> だとして、gh-pages ディレクトリーに <code>gh-pages</code> ブランチの中身をチェックアウトする。</p>
<div class="highlight"><pre><code class="text">git-new-workdir . gh-pages gh-pages
</code></pre></div>
<p>これで、Git レポジトリー直下の gh-pages ディレクトリーに <code>gh-pages</code> ブランチがチェックアウトされた。間違ってディレクトリーの中身をコミットしないように <code>.gitignore</code> に gh-pages を入れておくと安全だろう。</p>

<p>あとは個別のディレクトリーで編集してコミットしていく。先ほどの例と同じく、片方でコミットした内容は、もう片方の作業ディレクトリーで <code>git log</code> すれば反映されるし、<code>git push</code> すれば一気にリモートに反映される。</p>

<p>便利便利である。</p>

<h1>git-new-workdir の導入方法</h1>

<p>git-new-workdir は git-core の contrib に入っている。詳しくは <a href="http://subtech.g.hatena.ne.jp/secondlife/20121207/1354854068">git-new-workdir が便利 - #生存戦略 、それは - subtech</a> を参照。</p>

<p>ただ、Windows で Git for Windows (msysGit) を使ってる場合は、そのまま持ってきても動かないので、次のようにした。</p>

<ol>
<li><a href="https://github.com/dansmith65/git/blob/master/contrib/workdir/git-new-workdir-win">git/contrib/workdir/git-new-workdir-win at master - dansmith65/git</a> から git-new-workdir-win を拾ってくる。</li>
<li><code>C:\Program Files (x86)\Git\libexec\git-core</code> に <code>git-new-workdir</code> としてコピーする。(x86 環境なら <code>Program Files (x86)</code> を <code>Program Files</code> に読み替えるべし)</li>
</ol>

<p>これでおしまい。ただし、mklink.exe を使う関係で、UAC 有効にしてる環境では、bash を管理者として実行しておかないと、権限が足りなくてエラーになるので注意すべし。</p>

<h1>まとめ</h1>

<p><code>git-new-workdir</code> で便利な Git 生活を！</p>
]]></description>
		</item>

		<item>
			<title>rsync の複雑怪奇な exclude と include の適用手順を理解しよう</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/03/26/rsync-include-exclude/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/03/26/rsync-include-exclude/</guid>
			<pubDate>Tue, 26 Mar 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>rsync は便利なんだけど、オプションが多くて難しい。特にややこしいのがファイルを選別するための <code>--exclude</code> と <code>--include</code> オプションだ。</p>

<p>man を読んでもイメージがつかみにくかったので、ググったり、<code>-vvv</code> の結果を見たり、ソースを読んだりしつつ調べてみたところ、<strong>3 つのルール</strong>を理解すれば何とかなりそうなことが分かった。</p>

<p>この記事では、その 3 つのルールをなるべく分かりやすく説明する。</p>

<h1>ルール1: 指定順に意味がある</h1>

<p>コマンドライン引数は、通常、どの順番に指定しても同じ挙動になることが多い。しかし、rsync の <code>include</code> と <code>exclude</code> に関しては、指定順が意味を持つ。</p>

<p>man にも出てくる例で説明しよう。MP3 だけをコピーするには次のようにする。</p>
<div class="highlight"><pre><code class="text">rsync -av --include=&#39;*/&#39; --include=&#39;*.mp3&#39; --exclude=&#39;*&#39; src dst
</code></pre></div>
<p><code>-av</code> はコピーするときのお決まりのオプション。ネットワーク越しにコピーするときは、<code>-avz</code> として圧縮して転送することが多い。<code>-n</code> (dry run) をつければ、どのファイルが同期されるのかを事前に知ることができる。</p>

<p>今回の本題は 3 つのフィルター。それぞれの意味は次の通り。</p>

<ol>
<li><code>--include=&#39;*/&#39;</code>: フォルダーはコピーする</li>
<li><code>--include=&#39;*.mp3&#39;</code>: 拡張子が MP3 のファイルはコピーする</li>
<li><code>--exclude=&#39;*&#39;</code>: それ以外はコピーしない</li>
</ol>

<p>もし、<code>exclude</code> を手前にもってきて</p>
<div class="highlight"><pre><code class="text">rsync --include=&#39;*/&#39; --exclude=&#39;*&#39; --include=&#39;*.mp3&#39; src dst
</code></pre></div>
<p>とすると、フィルターの優先順位が</p>

<ol>
<li><code>--include=&#39;*/&#39;</code>: ディレクトリーはコピーする</li>
<li><code>--exclude=&#39;*&#39;</code>: すべてのファイルをコピーしない</li>
<li><code>--include=&#39;*.mp3&#39;</code>: 拡張子が MP3 のファイルはコピーする</li>
</ol>

<p>となる。<code>*.mp3</code> の前に <code>*</code> にマッチしてしまうので、何もコピーしてくれない。</p>

<p>フィルターの指定順には意味があって、<strong>先頭から順番に判定していく</strong>と覚えておこう。</p>

<h1>ルール2: 上の階層から順番に調べる</h1>

<p>いきなりクイズ。</p>

<p>次のコマンドを実行したとき、src フォルダーにある public_html/index.html はコピーされるだろうか？</p>
<div class="highlight"><pre><code class="text">rsync -av --include=&#39;index.html&#39; --exclude=&#39;public_html/&#39; src dst
</code></pre></div>
<p>このコマンドのフィルターは次の 2 つ。</p>

<ol>
<li><code>--include=index.html</code></li>
<li><code>--exlclude=public_html/</code></li>
</ol>

<p>public_html/index.html は両方のフィルターにマッチしそうだ。さきほど「先頭のフィルターを優先する」と説明したので、1 つ目のフィルターを優先してコピーされそうに思える。</p>

<p>しかし、答えは「コピーされない」である。その理由を説明していこう。</p>

<h2>まず最初に上の階層をチェック</h2>

<p>rsync は <code>public_html/index.html</code> をコピーするか判定する前に、上の階層の public_html をコピーするかどうかを確認する。</p>

<p>public_html に対して、2 つのフィルターを順番に適用する。</p>

<ol>
<li><code>--include=index.html</code> にはマッチしないので先へ進む。</li>
<li><code>--exclude=public_html/</code> にはマッチする。</li>
</ol>

<p>exclude になった場合、それより下位のフォルダーは確認しない。</p>

<p>つまり、public_html/index.html は問答無用でコピー対象から除外される。</p>

<h2>フォルダー内の特定のファイルのみを転送するには？</h2>

<p>では、public_html の下の index.html のみをコピー対象とするにはどう設定すればよいだろうか。</p>

<p>答えはこうなる。</p>
<div class="highlight"><pre><code class="text">rsync -av --include &#39;index.html&#39; --exclude &#39;public_html/*&#39; src dst
</code></pre></div>
<p>順番にみていこう。</p>

<p>まず最初に public_html に対して 2 つのフィルターを適用する。</p>

<ol>
<li><code>--include=index.html</code> にはマッチしないので先へ進む。</li>
<li><code>--exclude=public_html/*</code> にもマッチしない (<code>*</code> は 1 文字以上の任意の文字にしかマッチしない)。</li>
</ol>

<p><code>include</code> にマッチしたときと、どのフィルターにもマッチしなかったときは、下の階層のチェックに進む。</p>

<p>ということで、public_html/index.html に対して 2 つのフィルターを適用してみよう。</p>

<ol>
<li><code>--include=index.html</code> にはマッチする。</li>
</ol>

<p><code>include</code> にマッチしたので、次の階層のチェックに進む。が、これが最後の階層なので、public_html/index.html はコピー対象となる。</p>

<p>同じように考えていけば、public_html/other.html が除外されることも分かるだろう。</p>

<h2>(参考) 擬似コード</h2>

<p>ここまで文字で長々説明してきたが、プログラムが読める人なら、擬似コードで説明したほうが早いだろう (読めない人は飛ばしてね)。</p>
<div class="highlight"><pre><code class="javascript">// public_html/index.html をコピーするか確認 (上の階層から順番にチェックする)
foreach (name in [&#39;public_html&#39;, &#39;public_html/index.html&#39;]) {
  // 1 つ目のフィルターから順番にチェックする
  foreach (filter in filters) {
    if (filter_match(name, filter)) {
      if (is_exclude(filter)) {
        // exclude フィルターにマッチしたらその場で中断
        return false;
      } else {
        // include フィルターにマッチしたら、次の階層のチェックに移る
        break;
      }
    }
  }

  // include にマッチしたとき、1 つもマッチしなかったときはここにくる
}

// すべての階層で除外されなければコピーする
return true;
</code></pre></div>
<h1>ルール3: 個別のフィルターの記法いろいろ</h1>

<p>あとはフィルターの記法を知ってれば完璧に理解できるだろう。</p>

<h2>foo は何にマッチするか</h2>

<p>単に <code>foo</code> というフィルターを書いたとき、末尾部分が foo になっているファイルにマッチする。</p>

<ul>
<li>○: <code>foo</code></li>
<li>×: <code>abcfoo</code></li>
<li>○: <code>abc/foo</code></li>
<li>×: <code>foo/abc</code></li>
</ul>

<p>正規表現で書くと <code>(^|/)foo$</code> となる。</p>

<h2>/ から始めると</h2>

<p>一方、<code>/</code> から始めて、<code>/foo</code> のようにすると、マッチ対象が先頭のみになる。</p>

<ul>
<li>○: <code>foo</code></li>
<li>×: <code>abcfoo</code></li>
<li>×: <code>abc/foo</code></li>
<li>×: <code>foo/abc</code></li>
</ul>

<p>正規表現で書くと <code>^foo$</code> となる。</p>

<h2>/ で終わると</h2>

<p>末尾に <code>/</code> をつけると、対象がフォルダーのときのみマッチする。</p>

<p><code>foo/</code> は <code>foo</code> がフォルダーのときはマッチするが、ファイルのときにはマッチしない。</p>

<h2>* や ** を使ってみる</h2>

<p>記号についてもまとめておこう。</p>

<table><thead>
<tr>
<th>記号</th>
<th>意味</th>
<th>対応する正規表現</th>
</tr>
</thead><tbody>
<tr>
<td><code>*</code></td>
<td><code>/</code> 以外の 1 文字以上</td>
<td><code>[^/]+</code></td>
</tr>
<tr>
<td><code>**</code></td>
<td><code>/</code> を含む 1 文字以上</td>
<td><code>.+</code></td>
</tr>
<tr>
<td><code>?</code></td>
<td><code>/</code> 以外の 1 文字</td>
<td><code>[^/]</code></td>
</tr>
</tbody></table>

<p>たとえば、<code>*.png</code> を正規表現で書くと <code>(^|/)[^/]+\.png$</code> となる。<code>abc.png</code> や <code>foo/abc.png</code> にはマッチするが、<code>abc.png/foo</code> や <code>.png</code>にはマッチしない。</p>

<p>さらに、<code>***</code> は <code>foo/***</code> のように指定することで、フォルダーとその配下のファイルをまとめて指定できる。<code>foo/***</code> と指定するのは、<code>foo/</code> と <code>foo/**</code> の両方を指定することと等しい。</p>

<h2>[a-z] を使う</h2>

<p>正規表現のように、マッチする文字の範囲を指定できる。<code>[^a-z]</code> のように特定の文字以外にマッチするようにも書ける。POSIX クラスで <code>[[:digit:][:upper:][:space:]]</code> のように書くこともできる。</p>

<p>正規表現のように書けてうれしいのだが、<code>[a-z]*</code> と書いたとしても、単に <code>[a-z][^/]+</code> にしかマッチしない。間違えないように注意。</p>

<h1>まとめ</h1>

<p>rsync の複雑な <code>include</code> / <code>exclude</code> の処理について説明した。要点は次の 3 つ。</p>

<ul>
<li>フィルターは指定順に優先されている</li>
<li>判定処理は上の階層から実施して、各階層の中でフィルターを順番に適用していく</li>
<li>個別の記法を理解すべし</li>
</ul>

<p>これが理解できれば、あとは頭の体操でフィルター条件を作れるはず！</p>

<p>一見複雑怪奇ではあるが、このような仕組みになっているおかげで、一部除外や一部許可を設定しやすくなっている。一方、<code>tar</code> コマンドは man を見ると <code>exclude</code> を優先すると書いてあるので、一部除外しか指定できないような気がする。</p>
]]></description>
		</item>

		<item>
			<title>LiveReloadX 0.2.0 公開！ 除外ファイルを指定可能になったよ</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/03/25/livereloadx0-2-0/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/03/25/livereloadx0-2-0/</guid>
			<pubDate>Mon, 25 Mar 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p><a href="http://nitoyon.github.com/livereloadx/">LiveReloadX</a> 0.2.0 を公開した。</p>

<p>新規インストールするなら今まで通り <code>npm install -g livereloadx</code> で、バージョンアップするなら <code>npm update -g livereloadx</code> でどうぞ。</p>

<p>以前のバージョンでは、監視対象のフォルダー配下のファイルが更新されるたびにブラウザーをリロードしていたので、たとえば、git で管理しているフォルダーを監視していると、<code>git commit</code> するたびにブラウザーがリロードされるという悲しい状態だった。</p>

<p>そこで、除外フォルダーやファイルを指定できるようにした。</p>

<p>たとえば、<code>cache</code> フォルダーを監視から除外したいときは</p>
<div class="highlight"><pre><code class="text">$ livereloadx --exclude cache
</code></pre></div>
<p>とすればよい。</p>

<p>また、デフォルトでは html, shtml, css, js, jpg, gif, png, cgi, php など、Web 開発に一通り必要そうな拡張子のみを監視するようにした。たとえば、追加で ini を編集したときにリロードさせたい場合には</p>
<div class="highlight"><pre><code class="text">$ livereloadx --include &quot;*.ini&quot;
</code></pre></div>
<p>とすればよい。いままで通り、すべてのファイルを監視したければ、</p>
<div class="highlight"><pre><code class="text">$ livereloadx --include &quot;*&quot;
</code></pre></div>
<p>とすればよい。</p>

<p>include/exclude の判定ロジックは rsync の真似をしているので自由度はかなり高い。ただ、rsync の include/exclude ルール自体が複雑怪奇なので、それについては <a href="/ja/blog/2013/03/26/rsync-include-exclude/">rsync の複雑怪奇な exclude と include の適用手順を理解しよう</a> で記事にした。</p>
]]></description>
		</item>

		<item>
			<title>ファイル編集したら即ブラウザー再読込させる LiveReloadX を作った</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/02/27/livereloadx/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/02/27/livereloadx/</guid>
			<pubDate>Wed, 27 Feb 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p><center><img src="http://farm9.staticflickr.com/8100/8509399251_7056f91a11.jpg" width="500" height="294"></center></p>

<p>Web 開発してると、ソースを編集して、ブラウザーをリロードして、という作業の繰り返しになりがちだ。ソースを編集したら、自動でブラウザーをリロードしてくれるような夢のツールがあれば便利そうだ。</p>

<p>この分野では <a href="http://incident57.com/codekit/">CodeKit</a> や <a href="http://livereload.com/">LiveReload</a> などが有名なんだけど、もれなく有料だったり GUI だったりする。そこで、<a href="http://livereload.com/">LiveReload</a> のオープンソースな部分を参考にしつつ、コマンドラインで使える <a href="http://nitoyon.github.com/livereloadx/">LiveReloadX</a> というものを作ってみた。</p>

<p>特長はこんなところ。</p>

<ul>
<li>Node.js を使ってるので Windows/Mac/Linux 問わずに動かせる</li>
<li>開発環境のブラウザーだけでなくスマートフォンのブラウザーもリロードできる</li>
<li>無料</li>
</ul>

<h1>インストール方法</h1>

<p>インストールは超簡単！</p>

<ol>
<li><a href="http://nodejs.org/">Node.js</a> をインストールする。</li>
<li>コマンドラインで <code>npm install -g livereloadx</code> を実行する。</li>
</ol>

<h1>動作原理</h1>

<p><center><img src="http://farm9.staticflickr.com/8099/8509399561_17e6288376.jpg" width="500" height="159"></center></p>

<p>インストールしたら <code>livereloadx</code> コマンドが動くようになる。ただ、それだけではブラウザーはリロードしてくれないので、ちょいと動作原理を説明しておく。</p>

<ol>
<li>コマンドラインで <code>livereloadx path/to/dir</code> を実行すると、LiveReloadX が開始して、次のような処理をする。

<ul>
<li>フォルダー <code>path/to/dir</code> の監視を開始する。</li>
<li>ポート <code>35729</code> で Web サーバーとして動き始める。この Web サーバーは <code>livereload.js</code> を公開しつつ、WebSocket サーバーとしても動く。</li>
</ul></li>
<li>ブラウザーで <code>livereload.js</code> を読み込むと、LiveReloadX サーバーに WebSocket で接続しにいく。</li>
<li><code>path/to/dir</code> 配下のファイルを更新したら、LiveReloadX サーバーはブラウザーに WebSocket で通知を出す。通知を受け取ったブラウザーは再読込する。</li>
</ol>

<p>ということで、ブラウザーに <code>livereload.js</code> を読み込ませる方法が重要になってくる。</p>

<h1>livereload.js の読み込ませ方</h1>

<p>4 通りあるので、好きなやつを選ぶことになる。</p>

<ul>
<li>手動で追加する</li>
<li>ブラウザー拡張をインストールする (PC 版 Safari・Chrome・Firefox のみ).</li>
<li>static モードで実行する</li>
<li>proxy モードで実行する</li>
</ul>

<p>前半の 2 つは LiveReload で提供されてる手段で、後半の 2 つはオリジナルだ。</p>

<h2>手動で追加する</h2>

<p><center><img src="http://farm9.staticflickr.com/8506/8509400159_435002302f.jpg" width="500" height="254"></center></p>

<p>既存の HTML ファイルに次の <code>&lt;script&gt;</code> タグ (JavaScript スニペット) を追加する。それだけ。</p>
<div class="highlight"><pre><code class="html">&lt;script&gt;document.write(&#39;&lt;script src=&quot;http://&#39; + (location.host || &#39;localhost&#39;).split(&#39;:&#39;)[0] +
&#39;:35729/livereload.js?snipver=2&quot;&gt;&lt;/&#39; + &#39;script&gt;&#39;)&lt;/script&gt;
</code></pre></div>
<p>静的な HTML ファイルで開発してる場合とか、動的 HTML だけどテンプレートを編集するだけで済む場合は、この手順が楽だろう。</p>

<h2>ブラウザー拡張をインストールする</h2>

<p><center><img src="http://farm9.staticflickr.com/8252/8509400245_25dbf28c7f.jpg" width="500" height="260"></center></p>

<p>ソースはいじりたくないよ、という場合は <a href="http://feedback.livereload.com/knowledgebase/articles/86242-how-do-i-install-and-use-the-browser-extensions-">How do I install and use the browser extensions? – LiveReload Help &amp; Support</a> からブラウザー拡張を導入するとよい。ただし、対応するブラウザーは PC 版 Safari・Chrome・Firefox のみに限られる。</p>

<p>拡張の LiveReload ツールバーのボタンを押すと、<code>livereload.js</code> が表示中のページに動的に挿入されるようになる。</p>

<h2>static モードで実行する</h2>

<p><center><img src="http://farm9.staticflickr.com/8240/8509400365_6086b6644a.jpg" width="500" height="156"></center></p>

<p>静的なサイトのときには、これが便利かもしれない。<code>-s</code> か <code>--static</code> オプションつきで実行する。</p>
<div class="highlight"><pre><code class="bash">livereloadx -s [-p 35729] [path/to/dir]
</code></pre></div>
<p>static モードでは<strong>静的 Web サーバー</strong>として動作する。</p>

<p>たとえば、<code>http://localhost:35729/foo/</code> にアクセスすると <code>path/to/dir/foo/index.html</code> からファイルを読み取って返してくれる。ついでに、<code>&lt;script&gt;</code> タグを自動で挿入して、ブラウザーが <code>livereload.js</code> を読み込むようにしてくれる。</p>

<h2>proxy モードで実行する</h2>

<p><center><img src="http://farm9.staticflickr.com/8089/8510508898_7c8e065387.jpg" width="500" height="156"></center></p>

<p>HTML をいじりたくないし、ブラウザー拡張も入れたくないし、静的サイトでもないときは、この方法が便利だろう。<code>-y http://example.com/</code> か <code>--proxy http://example.com/</code> オプションをつけて実行する。</p>
<div class="highlight"><pre><code class="text">$ livereloadx -y http://example.com/ [-p 35729] [-l] [path/to/dir]
</code></pre></div>
<p>proxy モードでは<strong>リバース プロキシー</strong>として動作する。</p>

<p>たとえば、<code>http://localhost:35729/foo/</code> にアクセスすると、裏側で <code>http://example.com/foo/</code> からデータを取ってきてクライアントに返す。ついでに、<code>&lt;script&gt;</code> タグを自動で挿入して、ブラウザーが <code>livereload.js</code> を読み込むようにしてくれる。</p>

<p>さらに、<code>-l</code> か <code>--prefer-local</code> フラグをつけて起動すると、最初にローカルのファイルがあるか確認して、あればそっちを返すようになる。稼働中の本番環境のうち、一部の JavaScript とか CSS だけを手元に持ってきて編集しながら検証できて便利だ。</p>

<h1>まとめ</h1>

<p>LiveReloadX を紹介した。Node.js の勉強がてら作っていたのだけど、なかなか便利なツールになったのではないかと思う。</p>

<p>ソースは <a href="https://github.com/nitoyon/livereloadx">nitoyon/livereloadx - GitHub</a>  にあるので、Star や Pull Request してもらえると、とてもうれしい。</p>
]]></description>
		</item>

	</channel>
</rss>
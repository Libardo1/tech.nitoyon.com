<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>てっく煮ブログ</title>
		<link>http://tech.nitoyon.com/ja/blog/index.xml</link>
		<description>All Technology is Boiled in This Site.</description>
		<language>ja</language>
		<copyright>Copyright nitoyon.</copyright>
		<lastBuildDate>Sun, 24 Nov 2013 00:01:21 +0000</lastBuildDate>
		<docs>http://blogs.law.harvard.edu/tech/rss</docs>
		<atom:link href="http://tech.nitoyon.com/ja/blog/index.xml" rel="self" type="application/rss+xml" />









		<item>
			<title>CVS レポジトリを Git に変換した手順とか注意点とか</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/11/20/cvs2git/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/11/20/cvs2git/</guid>
			<pubDate>Wed, 20 Nov 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>この前、10 年以上前に趣味で作っていたフリーソフトについてメールで質問が来た。もはや完全に記憶から消えているだけでなく、いま使っている PC にソースコードもない。何も分からない、答えられない。</p>

<p>そのままでは古いソースコードも成仏しきれない。供養するために、古い HDD を引っ張り出して探したところ、自宅サーバーをやってた HDD の中に CVS レポジトリーが見つかった。せっかくなので、Git に変換して GitHub で公開してみた (<a href="https://github.com/nitoyon/mp3album">その１</a>, <a href="https://github.com/nitoyon/winamp-zipmp3plugin">その２</a>)。これで成仏できるだろう。</p>

<p>そこで、この記事では CVS レポジトリーを Git に移行した手順をまとめておく。レガシーな CVS から Git に移行したい人の参考になるとうれしい。</p>

<h1>git cvsimport の使い方</h1>

<p>Git には <a href="https://www.kernel.org/pub/software/scm/git/docs/git-cvsimport.html">git-cvsimport</a> というコマンドがある。CVS の履歴を Git に変換してくれる。</p>

<p>CVS はファイルごとに履歴を保存する構造になってるんだけど、<code>cvsps</code> というツールを組み合わせることで、同時に変更したファイルを 1 コミットとして扱ってくれるようになる。</p>

<p>大きいレポジトリーだと結構時間かかる。cygwin だと超絶に時間がかかったので、UNIX 上で実行した。Git for Windows には <code>git-cvsimport</code> がない。</p>

<p>自分は次のように実行した。</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">git cvsimport -v -i -R -A author-conv-file.txt \
-d :local:/path/to/CVS &lt;module&gt;
</code></pre></div>
<p>それぞれのパラメータの意味は次の通り。詳しくは <a href="https://www.kernel.org/pub/software/scm/git/docs/git-cvsimport.html">git-cvsimport</a> を参照のこと。</p>

<ul>
<li><code>-v</code>: 出力を verbose にする。</li>
<li><code>-i</code>: インポートだけを行ってチェックアウトしない。</li>
<li><code>-R</code>: 「CVS のリビジョン番号」と「それに対応する Git のコミット」の対応付けを <code>.git/cvs-revisions</code> に出力する。一応生成しておく。</li>
<li><code>-A</code>: ユーザー名の変換テーブル。詳細は後述。</li>
<li><code>-d</code>: CVSROOT のパス。cvs コマンドで <code>-d</code> に指定するやつ。もしくは、環境変数の <code>CVSROOT</code> に指定してるやつ。</li>
<li><code>&lt;module&gt;</code>: モジュール名。サブディレクトリを指定することもできる。</li>
</ul>

<p><code>-d</code> で指定したパスに <code>CVSROOT</code> ディレクトリがないと <code>Expected Valid-requests from server, but got: E Cannot access /path/to/CVS</code> というエラーになる。ダミーでよいので <code>mkdir /path/to/CVS/CVSROOT</code> しておけば回避できた。</p>

<h2>author-conv-file の書き方</h2>

<p>author-conv-file には「CVS のユーザー名」から「Git の Author 名・メールアドレス」への対応を記述していく。</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">user1=User 1 &lt;user1@example.com&gt;
user2=User 2 &lt;user1@example.com&gt; Asia/Tokyo
</code></pre></div>
<p>1.8.1 からはタイムゾーンも指定できるようになっている。それ以前のバージョンだと、すべて UTC でのコミットとなってしまう。</p>

<p>実行が終わったら <code>git log | grep Author: | sort | uniq</code> を実行して、author-conv-file に漏れがないか確認しておくといいだろう。</p>

<h2>cvsps のキャッシュ</h2>

<p>個人的に悩まされたのが、<code>cvsps</code> が結果を <code>~/.cvsps</code> にキャッシュすること。CVS レポジトリーを変更したあとに <code>git cvsimport</code> を実行しても反映されない。そういうときは、<code>rm -rf ~/.cvsps</code> して再実行するとよい。</p>

<h2>文字コードの変換</h2>

<p>いまなら「全部 UTF-8 でやっちゃえ」となるんだけど、CVS 全盛の時代は Windows は ShiftJIS で、UNIX 上では EUC-JP がまだまだ主流だった。</p>

<p>コミットログやファイル名が UTF-8 でない場合は、ちょいとソースコードを修正する必要がある。</p>

<p>以下は 1.7.3.1 の <code>git-cvsimport</code> に対する修正。</p>
<div class="highlight"><pre><code class="diff language-diff" data-lang="diff">--- /usr/local/libexec/git-core/git-cvsimport.bak
+++ /usr/local/libexec/git-core/git-cvsimport
@@ -722,6 +722,11 @@
 sub update_index (\@\@) {
        my $old = shift;
        my $new = shift;
+
+       # file name
+       use Encode qw/decode encode/;
+       $_ = encode(&#39;utf8&#39;, decode(&#39;shift-jis&#39;, $_)) for @$old;
+       $_-&gt;[2] = encode(&#39;utf8&#39;, decode(&#39;shift-jis&#39;, $_-&gt;[2])) for @$new;
+
        open(my $fh, &#39;|-&#39;, qw(git update-index -z --index-info))
                or die &quot;unable to open git update-index: $!&quot;;
        print $fh
@@ -810,6 +816,11 @@
        substr($logmsg,32767) = &quot;&quot; if length($logmsg) &gt; 32767;
        $logmsg =~ s/[\s\n]+\z//;

+       # commit log
+       use Encode qw/encode decode/;
+       $logmsg = encode(&#39;utf8&#39;, decode(&#39;shift-jis&#39;, $logmsg));
+
        if (@skipped) {
            $logmsg .= &quot;\n\n\nSKIPPED:\n\t&quot;;
            $logmsg .= join(&quot;\n\t&quot;, @skipped) . &quot;\n&quot;;
</code></pre></div>
<p>ここではコミットログやファイル名が Shift_JIS だという前提で書いてある。</p>

<p>自動判定したい場合は</p>
<div class="highlight"><pre><code class="diff language-diff" data-lang="diff">+       use Encode::Guess qw/euc-jp shiftjis/;
+       $logmsg = encode(&#39;utf8&#39;, decode(&#39;guess&#39;, $logmsg));
</code></pre></div>
<p>のように書けばいける。</p>

<h2>歴史の書き換え</h2>

<p>push する前に、インポート結果を十分に確認しておきたい。次のような点に注意して作業した。</p>

<p>コミットログを書き換えたいなら <code>git rebase -i</code> でやっちゃう。</p>

<p>不要なファイルがあったら <code>git filter-branch --tree-filter &#39;rm -f passwords.txt&#39; HEAD</code> のようにして消しておく (参照: <a href="http://git-scm.com/book/ja/Git-%E3%81%AE%E3%81%95%E3%81%BE%E3%81%96%E3%81%BE%E3%81%AA%E3%83%84%E3%83%BC%E3%83%AB-%E6%AD%B4%E5%8F%B2%E3%81%AE%E6%9B%B8%E3%81%8D%E6%8F%9B%E3%81%88">Git - 歴史の書き換え</a>)。</p>

<p>一度でも歴史を書き換えたら、commit date が実行時刻になってしまうので、<code>git filter-branch --env-filter &#39;GIT_COMMITTER_DATE=$GIT_AUTHOR_DATE; export GIT_COMMITTER_DATE&#39;</code> で author date にそろえておく (参照: <a href="http://stackoverflow.com/questions/2973996/git-rebase-without-changing-commit-timestamps">git rebase without changing commit timestamps - Stack Overflow</a>)。</p>

<p>このあたりは <code>git-cvsimport</code> の Tips というよりも、Git での歴史書き換えの Tips。</p>

<h1>まとめ</h1>

<p>負の遺産 CVS を捨てて、健全な Git ライフを送ろう！</p>
]]></description>
		</item>

		<item>
			<title>Windows で Jekyll 1.3 を動かすまでの手順</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/11/14/jekyll-win/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/11/14/jekyll-win/</guid>
			<pubDate>Thu, 14 Nov 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p><a href="http://jekyllrb.com/">Jekyll</a> を Windows で動かそうとすると、いくつか難関がある。今回、自分の環境を新しく作り直したキッカケがあったので、導入までの手順をメモしておく。</p>

<p>自分の環境は Windows 8 Pro x64。各種ツールのバージョンは次の通り。</p>

<ul>
<li>Jekyll 1.3.0</li>
<li>Ruby 2.0.0 p247</li>
<li>DevKit 4.7.2-20130224-1432</li>
<li>Python 2.7.6</li>
<li>Pygentize 1.6</li>
</ul>

<p>基本的には <a href="http://www.madhur.co.in/blog/2011/09/01/runningjekyllwindows.html">Running Jekyll on Windows &#8211; Madhur Ahuja</a> の手順に近いけど、Pygments の導入手順などは少し違っているのと、日本語独自の問題についても書いている。</p>

<h1>1. Ruby 環境を整備する</h1>

<p><a href="http://rubyinstaller.org/downloads/">RubyInstaller for Windows</a> から One-Click Ruby のインストーラーと Development Kit を導入する。</p>

<p>Development Kit はネイティブな gem の導入に必要。</p>

<p>今回導入したのは次のバージョン。</p>

<ul>
<li>Ruby 2.0.0-p247 (rubyinstaller-2.0.0-p247-x64.exe)</li>
<li>DevKit-mingw64-64-4.7.2-20130224-1432-sfx.exe</li>
</ul>

<h2>Ruby インストーラーの実行</h2>

<p>まず、Ruby のインストーラーを導入する。デフォルトで <code>C:\Ruby200-x64</code> にインストールされる。</p>

<p>環境変数の <code>PATH</code> に <code>C:\Ruby200-x64\bin</code> を追加しておこう。</p>

<h2>DevKit の導入</h2>

<p><code>DevKit-mingw64-64-4.7.2-20130224-1432-sfx.exe</code> を実行すると、展開先を聞かれる。ここでは <code>C:\RubyDevKit</code> を選択した。</p>

<p>次に設定する。コマンドプロンプトで <code>dk.rb</code> の <code>init</code> と <code>initialize</code> を実行する。</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">c:\RubyDevKit&gt;ruby dk.rb init
[INFO] found RubyInstaller v2.0.0 at C:/Ruby200-x64

Initialization complete! Please review and modify the auto-generated
&#39;config.yml&#39; file to ensure it contains the root directories to all
of the installed Rubies you want enhanced by the DevKit.

c:\RubyDevKit&gt;ruby dk.rb install
[INFO] Updating convenience notice gem override for &#39;C:/Ruby200-x64&#39;
[INFO] Installing &#39;C:/Ruby200-x64/lib/ruby/site_ruby/devkit.rb&#39;
</code></pre></div>
<p>ここまでで Ruby のセットアップは完了。</p>

<h1>2. Jekyll を導入する</h1>

<p>コマンドプロンプトから <code>gem install jekyll</code> を実行する。</p>

<p>次の gem が導入される。</p>

<ul>
<li>classifier-1.3.3</li>
<li>colorator-0.1</li>
<li>commander-4.1.5</li>
<li>fast-stemmer-1.0.2</li>
<li>ffi-1.9.3-x64-mingw32</li>
<li>highline-1.6.20</li>
<li><strong>jekyll-1.3.0</strong></li>
<li>liquid-2.5.4</li>
<li>listen-1.3.1</li>
<li>maruku-0.6.1</li>
<li>posix-spawn-0.3.6</li>
<li>pygments.rb-0.5.4</li>
<li>rake-0.9.6</li>
<li>rb-fsevent-0.9.3</li>
<li>rb-inotify-0.9.2</li>
<li>rb-kqueue-0.2.0</li>
<li>rdoc-4.0.0</li>
<li>redcarpet-2.3.0</li>
<li>safe_yaml-0.9.7</li>
<li>syntax-1.0.0</li>
<li>test-unit-2.0.0.0</li>
<li>yajl-ruby-1.1.0</li>
</ul>

<h2>pygments.rb のダウングレード</h2>

<p>悲しいことに、<code>pygments.rb</code> の 0.5.1 以降は Windows では動作しない。(<a href="https://github.com/tmm1/pygments.rb/pull/90">pygments.rb #90</a> で Pull Request が出ているが、執筆時点でマージされていない)</p>

<p>そのため、導入された <code>pygments.rb</code> をアンインストールして、0.5.0 を入れなおしておく。「Jekyll が依存してる」と文句いわれるけど、気にせずに作業しちゃう。</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">&gt; gem uninstall pygments.rb --version &quot;&gt;0.5.0&quot;
&gt; gem install pygments.rb --version &quot;=0.5.0&quot;
</code></pre></div>
<h2>UTF-8 対策</h2>

<p>HTML や記事に日本語が含まれると、Jekyll の実行時に次のようなエラーが出る。</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">Liquid Exception: invalid byte sequence in Windows-31J in post.md/#excerpt
error: invalid byte sequence in Windows-31J. Use --trace to view backtrace
</code></pre></div>
<p>Windows Ruby にありがちな FAQ で、ググると色々出てくる。</p>

<p><code>set LANG=ja_JP.UTF-8</code> するとよい、と書いてある記事もあったが Ruby 2.0 では効かないらしい。</p>

<p>Ruby 2.0 では環境変数の <code>RUBYOPT</code> を <code>-EUTF-8</code> にしておけば解決した (参考: <a href="http://sugamasao.hatenablog.com/entry/2013/08/24/224521">WindowsでEncoding.default_externalをUTF-8にするには - すがブロ</a>)。</p>

<p>環境変数をいじるのが面倒なら、<code>C:\Ruby200-x64\bin\jekyll.bat</code> の 2 行目あたりに <code>set RUBYOPT=-EUTF-8</code> と書いてもいい。</p>

<p>もしくは、<code>C:\Ruby200-x64\lib\ruby\gems\2.0.0\gems\jekyll-1.3.0\bin\jekyll</code> の冒頭 2 行目に</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">Encoding.default_external = &quot;utf-8&quot;
</code></pre></div>
<p>を追加して回避してもよいだろう。(改行コードが LF のみなので、メモ帳では追加できない点に注意)</p>

<h1>3. Pygments を導入する</h1>

<p>コードのハイライトを行うためには Pygments を導入する。</p>

<h2>Python 2.7</h2>

<p><a href="http://www.python.org/download/">Download Python</a> から 2.7 をダウンロードする。今回導入したのは Python 2.7.6 Windows X86-64 Installer (<code>python-2.7.6.amd64.msi</code>)。</p>

<p>インストーラーを実行してデフォルトの設定でインストールする。インストール先は <code>C:\Python27</code> となる。</p>

<p>環境変数の <code>PATH</code> に <code>C:\Python27</code> と <code>C:\Python27\Scripts</code> を追加しておく (<code>Scripts</code> フォルダーはこのあと自動で作成される)。</p>

<h2>easy_install</h2>

<p>次に、<a href="https://pypi.python.org/pypi/setuptools#windows">setuptools</a> から <a href="https://bitbucket.org/pypa/setuptools/raw/bootstrap/ez_setup.py"><code>ez_setup.py</code></a> をダウンロードする。</p>

<p><code>ez_setup.py</code> を実行する。</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">&gt; python easy_install.py
   :
Installing easy_install-script.py script to C:\Python27\Scripts
Installing easy_install.exe script to C:\Python27\Scripts
Installing easy_install-2.7-script.py script to C:\Python27\Scripts
Installing easy_install-2.7.exe script to C:\Python27\Scripts

Installed c:\python27\lib\site-packages\setuptools-1.3.2-py2.7.egg
Processing dependencies for setuptools==1.3.2
Finished processing dependencies for setuptools==1.3.2
</code></pre></div>
<h2>Pygments</h2>

<p>いよいよ Pygments をインストール！</p>

<p><code>easy_install pygments</code> を実行すればよい。</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">&gt; easy_install pygments
   :
Adding Pygments 1.6 to easy-install.pth file
Installing pygmentize-script.py script to C:\Python27\Scripts
Installing pygmentize.exe script to C:\Python27\Scripts

Installed c:\python27\lib\site-packages\pygments-1.6-py2.7.egg
Processing dependencies for pygments
Finished processing dependencies for pygments
</code></pre></div>
<h1>4. Jekyll が動くか確認する！</h1>

<p>ここまでくれば導入は完了したはず。動作するかテストしてみよう。</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">&gt;jekyll new jekyll-test
New jekyll site installed in path/to/jekyll-test.

&gt;cd jekyll-test

&gt;jekyll serve
Configuration file: path/to/test-site/_config.yml
            Source: path/to/test-site
       Destination: path/to/test-site/_site
      Generating... done.
    Server address: http://0.0.0.0:4000
  Server running... press ctrl-c to stop.```

http://localhost:4000/ を開いて結果が出力されていれば成功。

お疲れ様。
</code></pre></div>]]></description>
		</item>

		<item>
			<title>K-means 法を D3.js でビジュアライズしてみた</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/11/07/k-means/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/11/07/k-means/</guid>
			<pubDate>Thu, 07 Nov 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>クラスタリングの定番アルゴリズム K-means 法（K平均法）の動作原理を理解するために、<a href="http://d3js.org/">D3.js</a> を使って可視化してみました。</p>

<div id="kmeans">
<div><svg></svg></div>
<div><button id="step">ステップ</button> <button id="restart" disabled>最初から</button></div>
<fieldset style="display: inline; margin: .8em 0 1em 0; border: 1px solid #999; padding: .5em">
<div><label for="N">N (ノード数):</label><input type="number" id="N" min="2" max="1000" value="100"></div>
<div><label for="K">K (クラスター数):</label><input type="number" id="K" min="2" max="50" value="5"></div>
<div><button id="reset">新規作成</button></div>
</fieldset>
</div>

<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>

<script src="k-means.js"></script>

<ul>
<li>図をクリックするか [ステップ] ボタンを押すと、1ステップずつ処理を行います</li>
<li>[最初から] ボタンを押すと、最初の状態に戻ります</li>
<li>[新規作成] ボタンを押すと、<i>N</i> (ノード数) と <i>K</i> (クラスタ数) の値で新しく初期化します</li>
<li>古いブラウザーではうまく表示できない可能性があります (IE 10、Firefox 25、Chrome 30 で動作確認しています)</li>
</ul>

<h1>K-Means 法とは</h1>

<p>英語版 Wikipedia の <a href="http://en.wikipedia.org/wiki/K-means_clustering">k-means clustering - Wikipedia, the free encyclopedia</a> の手順に沿って実装しています。</p>

<p>英語版の手順をザックリと書くとこんなイメージになります。</p>

<ol>
<li><em>初期化:</em> <i>N</i> 個のノード (丸印) と <i>K</i> 個のクラスター (×印) を作成する</li>
<li><em>Assignment ステップ:</em> 各ノードを一番近いクラスターに所属させる</li>
<li><em>Update ステップ:</em> クラスターをノードの重心に移動させる</li>
<li>ステップ 2 に戻る</li>
</ol>

<p>最初は 1 の状態で表示していて、クリックするごとに、ステップ 2 とステップ 3 を実行していきます。</p>

<p>ステップを繰り返すにしたがって、クラスターの重心 (×印) が移動しながら、塊ができていく様子を確認できると思います。</p>

<h1>D3.js と ActionScript 3</h1>

<p>ここからはプログラミングの話です。</p>

<p>お気づきの方もいるかもしれませんが、このビジュアライズは 4 年ほど前に ActionScript 3 で作った <a href="/ja/blog/2009/04/09/kmeans-visualise/">クラスタリングの定番アルゴリズム「K-means法」をビジュアライズしてみた</a> の焼き直しです。</p>

<p>同じものを D3.js と ActionScript 3 で実装してみて気づいたことがいくつかあります。</p>

<h2>実装のしやすさ</h2>

<p>ActionScript 版にくらべて、D3.js 版では</p>

<ul>
<li>クラスタが変わるときの色の変化のアニメーション</li>
<li>重心が移動するときの線のアニメーション</li>
<li>新規作成のときのアニメーション</li>
</ul>

<p>を追加しています。</p>

<p>D3.js の <code>data()</code> や <code>enter()</code> といった API を活用すれば、このようなアニメーションが簡単に実現できました。ActionScript で同じことを実現するのは、かなり面倒です。<code>data()</code> や <code>enter()</code> の嬉しいところについては、<a href="/ja/blog/2013/10/24/d3js/">D3.js の Data-Driven な DOM 操作がおもしろい</a> で書いているので、興味があれば読んでください。</p>

<p>ただ、D3.js で作る場合は、<code>data()</code> などの API にあわせてデータ構造を作りあげる必要があるので、少し慣れが必要でした。</p>

<h2>表示速度</h2>

<p>やっぱり Flash は速い。</p>

<p>D3.js 版では、ノードが増えたときのコマ落ちが目立ちます。このあたりは、ブラウザーの将来の進化に期待したいところです。</p>

<h1>まとめ</h1>

<ul>
<li>K means 法をビジュアライズしてみたよ</li>
<li>D3.js 便利</li>
<li>ブラウザーの進化に期待</li>
</ul>

<p>JavaScript のソースは <a href="k-means.js">k-means.js</a> においてます。</p>
]]></description>
		</item>

		<item>
			<title>D3.js の d3.svg.line() を試してみた</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/10/29/d3js-svg-line/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/10/29/d3js-svg-line/</guid>
			<pubDate>Tue, 29 Oct 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>１つ前の記事 <a href="/ja/blog/2013/10/24/d3js/">D3.js の Data-Driven な DOM 操作がおもしろい</a> のサンプルコードではシンプルにするために、座標計算の処理を泥臭く書いていた。</p>

<p>たとえば</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript">  circles.enter()
    .attr(&#39;cx&#39;, function(d, i) { return i * 280 / n + 10; })
</code></pre></div>
<p>のような座標を計算する関数が何箇所かに散らばっていた。</p>

<p>これ、<code>d3.svg.line()</code> を使ったらまとめられるし、便利な <code>interpolate</code> の機能も使えるよ、というのが今回のお話。</p>

<h1>d3.svg.line() の使い方</h1>

<p>たとえば</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript">var line = d3.svg.line()
  .x(function(d, i) { return i; })
  .y(function(d, i) { return d * d; });
</code></pre></div>
<p>としておくことにする。<code>line.x()</code> とすると <code>function(d, i) { return i; }</code> を返してくれるので、関数を再利用してコードが読みやすくなる。<code>line.y()</code> も同様。</p>

<p>さらに、<code>line([5,2,4])</code> のようにして配列を渡すと <code>&quot;M0,25L1,4L2,16&quot;</code> を返す。これは <code>(1, 5*5)</code>、<code>(2, 2*2)</code>, <code>(3, 4*4)</code> を結んだ線を表す SVG である。</p>

<p>ま、これだけならちょっと便利かなぁ、というぐらいだけども、<code>line.interpolate(&quot;cardinal&quot;)</code> を実行しておくと、<code>line([5,2,4])</code> は <code>&quot;M0,25Q0.7999999999999999,4.9,1,4Q1.2,3.1,2,16&quot;</code> を返す。</p>

<p>これは、座標を曲線で結んだ SVG をあらわす。うまいこと計算してくれている。</p>

<h1>今回のサンプル</h1>

<p>というわけで、前回のサンプルを少し改善しつつ、各種の <code>interpolate</code> を試せるようにしたものを置いておく。</p>

<div>
<svg id="sample" width="300" height="300"
  style="background: white; border: .3em solid #ccc;"></svg>
</div>

<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>

<p><button onclick="random()">random</button>
<button onclick="push()">push</button>
<button onclick="pop()">pop</button>
<select id="line-interpolate">
  <option>linear</option>
  <option>linear-closed</option>
  <option>step</option>
  <option>step-before</option>
  <option>step-after</option>
  <option>basis</option>
  <option>basis-open</option>
  <option>basis-closed</option>
  <option>bundle</option>
  <option selected>cardinal</option>
  <option>cardinal-open</option>
  <option>cardinal-closed</option>
  <option>monotone</option>
</select>
<script src="d3js-svg-line.js" charset="utf-8"></script></p>

<h2>使い方</h2>

<ul>
<li>初期状態では 10 個の要素を持った配列を表示している。</li>
<li>横軸が配列のインデックス、縦軸が要素の値 (0～1) をあらわす。</li>
<li>[random] ボタンを押すと、配列の中身がランダムな値で置き換わる。</li>
<li>[push] ボタンを押すと、配列の末尾に要素を追加する。</li>
<li>[pop] ボタンを押すと、配列の末尾から要素を取り除く。</li>
<li>選択欄で <code>interpolate</code> の値を変更できる。</li>
</ul>

<p>ボタンを押すと、アニメーションつきで見た目が変更するのを確認していただけるだろうか (SVG をサポートしてる必要があるので、モダンではないブラウザーでは表示できない)。</p>

<h2>HTML のソース</h2>
<div class="highlight"><pre><code class="html language-html" data-lang="html">&lt;div&gt;
&lt;svg id=&quot;sample&quot; width=&quot;300&quot; height=&quot;300&quot;
  style=&quot;background: white; border: .3em solid #ccc;&quot;&gt;&lt;/svg&gt;
&lt;/div&gt;
&lt;script src=&quot;http://d3js.org/d3.v3.min.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;button onclick=&quot;random()&quot;&gt;random&lt;/button&gt;
&lt;button onclick=&quot;push()&quot;&gt;push&lt;/button&gt;
&lt;button onclick=&quot;pop()&quot;&gt;pop&lt;/button&gt;
&lt;select id=&quot;line-interpolate&quot;&gt;
  &lt;option&gt;linear&lt;/option&gt;
  &lt;option&gt;linear-closed&lt;/option&gt;
  &lt;option&gt;step&lt;/option&gt;
  &lt;option&gt;step-before&lt;/option&gt;
  &lt;option&gt;step-after&lt;/option&gt;
  &lt;option&gt;basis&lt;/option&gt;
  &lt;option&gt;basis-open&lt;/option&gt;
  &lt;option&gt;basis-closed&lt;/option&gt;
  &lt;option&gt;bundle&lt;/option&gt;
  &lt;option&gt;cardinal&lt;/option&gt;
  &lt;option&gt;cardinal-open&lt;/option&gt;
  &lt;option&gt;cardinal-closed&lt;/option&gt;
  &lt;option&gt;monotone&lt;/option&gt;
&lt;/select&gt;
&lt;script src=&quot;d3js-svg-line.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
</code></pre></div>
<h2>d3js-svg-line.js のソース</h2>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript">var svg = d3.select(&quot;svg#sample&quot;)
  .attr(&#39;width&#39;, 300).attr(&#39;height&#39;, 300)
  .style(&#39;display&#39;, &#39;block&#39;);
var polyline = svg.append(&#39;path&#39;)
  .attr(&#39;stroke&#39;, &#39;red&#39;)
  .attr(&#39;stroke-width&#39;, &#39;1&#39;)
  .attr(&#39;fill&#39;, &#39;transparent&#39;);

var values = [];
for (var i = 0; i &lt; 10; i++) {
  values.push(Math.random());
}
d3.select(&#39;#line-interpolate&#39;).on(&#39;change&#39;, update);

function update() {
  var n = values.length;

  var s = d3.select(&#39;#line-interpolate&#39;).node();
  var interpolate = s.options[s.selectedIndex].value;

  var line = d3.svg.line()
    .x(function(d, i) { return (i + 1) * 300 / (n + 1); })
    .y(function(d, i) { return d * 280 + 10; })
    .interpolate(interpolate);

  var circles = svg.selectAll(&#39;circle&#39;).data(values);
  circles.enter()
    .append(&#39;circle&#39;)
    .attr(&#39;cx&#39;, line.x()).attr(&#39;cy&#39;, 0).attr(&#39;r&#39;, 0);
  circles.exit()
    .transition()
    .duration(300)
    .attr(&#39;cy&#39;, 0).attr(&#39;r&#39;, 0)
    .remove();
  circles
    .attr(&#39;fill&#39;, &#39;red&#39;)
    .transition()
    .duration(300)
    .attr(&#39;cx&#39;, line.x())
    .attr(&#39;cy&#39;, line.y())
    .attr(&#39;r&#39;, 6);
  polyline
    .transition()
    .duration(300)
    .attr(&#39;d&#39;, line(values));
}

function random() {
  var n = values.length;
  for (var i = 0; i &lt; n; i++) {
    values[i] = Math.random();
  }
  update();
}

function push() {
  values.push(Math.random());
  update();
}

function pop() {
  values.pop();
  update();
}

update();
</code></pre></div>]]></description>
		</item>

		<item>
			<title>D3.js の Data-Driven な DOM 操作がおもしろい</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/10/24/d3js/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/10/24/d3js/</guid>
			<pubDate>Thu, 24 Oct 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>ここんところ <a href="http://d3js.org/">D3.js</a> を触ってみているんだけど、これがなかなか面白い。</p>

<p><a href="http://d3js.org/"><center><img src="http://farm4.staticflickr.com/3767/10434503954_88b88529ce.jpg" width="500" height="313"></center></a></p>

<p>D3.js は「ビジュアライズ用のライブラリー」だと紹介されがちなんだけども、意外にも D3.js にはグラフを描画する機能がない。</p>

<p><a href="http://d3js.org/">D3.js</a> のトップページには次のように書いてある。</p>

<blockquote>
<p>D3.js はデータからドキュメントを生成するためのライブラリーです。D3 は HTML, SVG, CSS を使ってデータに命を吹き込みます。Web 標準を重要視しているので、独占的なフレームワークに縛られません。強力な<strong>ビジュアライズ用のコンポーネントと data-driven な DOM 操作手順</strong>を組み合わすことで、モダン ブラウザーの能力を最大限に活用できます。</p>

<blockquote>
<p>D3.js is a JavaScript library for manipulating documents based on data. D3 helps you bring data to life using HTML, SVG and CSS. D3’s emphasis on web standards gives you the full capabilities of modern browsers without tying yourself to a proprietary framework, combining <strong>powerful visualization components and a data-driven approach to DOM manipulation</strong>.</p>
</blockquote>
</blockquote>

<p>曰く、</p>

<ul>
<li>ビジュアライズ用のコンポーネント</li>
<li>data-driven な DOM 操作手順</li>
</ul>

<p>がウリらしい。</p>

<p>順番に見ていこう。</p>

<h1>ビジュアライズ用のコンポーネントの役割</h1>

<p>「ビジュアライズ用のコンポーネント」は<strong>「データ」と「チャートの種類」から「どこに描画すればいいか」を計算する</strong>機能だけを実装している。</p>

<h2>バブルチャートの例</h2>

<p><a href="(https://github.com/mbostock/d3/wiki/Gallery)">ギャラリー</a> の <a href="(http://bl.ocks.org/mbostock/4063269)">Bubble Chart</a> をみてみよう。</p>

<p><a href="http://bl.ocks.org/mbostock/4063269"><center><img src="http://farm8.staticflickr.com/7392/10442561554_9e73c2565b.jpg" width="500" height="259"></center></a></p>

<p>このチャートでは <a href="https://github.com/mbostock/d3/wiki/Pack-Layout"><code>d3.layout.pack()</code></a> という Pack Layout コンポーネントを利用している。</p>

<p>この例では、描画するノードの情報を、こんな形の JavaScript 配列をコンポーネントに渡している。</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript">[
  {
    className: &quot;AgglomerativeCluster&quot;,
    packageName: &quot;cluster&quot;,
    value: 3938
  },
  {
    className: &quot;CommunityStructure&quot;,
    packageName: &quot;cluster&quot;,
    value: 3812
  },
  {
    className: &quot;HierarchicalCluster&quot;,
    packageName: &quot;cluster&quot;,
    value: 6714
  },
  //...
]
</code></pre></div>
<p>これを <code>pack.nodes()</code> 関数に渡すと、<code>value</code> の値を元に計算して、ノードの位置情報をこんな感じで返す。</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript">[
  { /* root node の情報 */ },
  {
    className: &quot;AgglomerativeCluster&quot;,
    depth: 1,
    packageName: &quot;cluster&quot;
    parent: { /* root node */ },
    r: 22.159142384561406,
    value: 3938,
    x: 489.9621260527267,
    y: 532.5795625707091
  },
  {
    className: &quot;CommunityStructure&quot;,
    depth: 1,
    packageName: &quot;cluster&quot;,
    parent: { /* root node */ },
    r: 21.80175917979169,
    value: 3812,
    x: 535.3554715791261,
    y: 532.5795625707091
  },
  {
    className: &quot;&quot;HierarchicalCluster&quot;&quot;,
    depth: 1,
    packageName: &quot;cluster&quot;,
    parent: { /* root node */ },
    r: 28.933819019424202,
    value: 6714,
    x: 513.070926102582,
    y: 485.410700287188
  },
  // ...
]
</code></pre></div>
<p>いろんなプロパティーが追加されているけど、表示位置 (<code>x</code>, <code>y</code>) と半径 (<code>r</code>) の情報が返ってきている点に注目！</p>

<p>このように、ビジュアライズ用のコンポーネントは「データ」と「チャートの種類」から「どこに描画すればいいか」を計算するだけである。</p>

<h2>描画するには...</h2>

<p>この情報をどう画面に落とし込むかは実装側に任されている。</p>

<p>と聞くと、面倒そうに思えるかもしれないけど、<a href="(http://bl.ocks.org/mbostock/4063269)">Bubble Chart</a> のソースを見ると、描画処理はたったの 15 行。</p>

<p>それだけ簡単に描画できてしまうのは、D3.js の「data-driven な DOM 操作手順」を使って SVG を生成しているのが大きい。</p>

<h1>Data-Driven な DOM 操作を実感してみよう</h1>

<p><a href="http://d3js.org/">D3.js</a> には jQuery ライクな DOM 操作やイベント・アニメーション関係の API が用意されてる。jQuery を使ったことがある人なら簡単にマスターできるだろう。</p>

<p>jQuery にはないユニークな機能が <code>data()</code>・<code>enter()</code>・<code>exit()</code> 関数である。この関数の使い方を簡単なサンプルでみていこう。</p>

<p>JavaScript 上にこんな配列が定義されているとする。</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript">var shiritori = [&#39;りんご&#39;, &#39;ゴリラ&#39;, &#39;ラッパ&#39;];
</code></pre></div>
<p>HTML には入れ物の <code>&lt;ul&gt;</code> タグだけを用意しておく。</p>
<div class="highlight"><pre><code class="html language-html" data-lang="html">&lt;ul id=&quot;shiritori_list&quot;&gt;
&lt;/ul&gt;
</code></pre></div>
<p><code>&lt;ul&gt;</code> タグの中に <code>shiritori</code> 配列の中身を表示してみよう、というのがお題である。</p>

<h2>DOM の作成処理は data()＋enter()</h2>

<p>配列の中身を <code>&lt;ul&gt;</code> に追加するには、D3.js では次のように書く。</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript">// ul#shiritori_list を選択
d3.select(&#39;ul#shiritori_list&#39;)
  // その下の &lt;li&gt; を列挙
  .selectAll(&#39;li&#39;)
  // それぞれに shiritori 配列の要素を割り当てる
  .data(shiritori)
  // data より &lt;li&gt; が少ない場合は、足りない分について
  .enter()
  // &lt;li&gt; を追加する
  .append(&#39;li&#39;)
  // &lt;li&gt; の中身の文字を設定する
  .text(function(d, i) { return (i + 1) + &#39;番目は&#39; + d; });
</code></pre></div>
<p>これを実行すると、HTML はこうなる (なりそうですよね？　ね？)。</p>
<div class="highlight"><pre><code class="html language-html" data-lang="html">&lt;ul id=&quot;shiritori_list&quot;&gt;
  &lt;li&gt;1番目はりんご&lt;/li&gt;
  &lt;li&gt;2番目はゴリラ&lt;/li&gt;
  &lt;li&gt;3番目はラッパ&lt;/li&gt;
&lt;/ul&gt;
</code></pre></div>
<p>再度同じ JavaScript 処理を走らせるとどうなるだろう。<code>&lt;li&gt;</code> は 6 個になるだろうか。答えは「ならない」だ。</p>

<p>というのも、<code>enter()</code> 以降の処理は「<code>shiritori</code> 配列に対応する <code>&lt;li&gt;</code> がないとき」のみ実行される。「<code>&lt;li&gt;</code> の個数 ≦ <code>shiritori</code> 配列の要素数」である限りは何度実行しても <code>enter()</code> 以降は実行されない。</p>

<p>では、<code>shiritori.push(&#39;パイナップル&#39;)</code> として配列側を増やしてから、再度、上の JavaScript を走らせてみるとどうなるだろう。</p>

<p>そうすると、新規追加分の <code>&#39;パイナップル&#39;</code> に対してだけ、<code>enter()</code> 以降の処理が実行される。つまり、HTML は</p>
<div class="highlight"><pre><code class="html language-html" data-lang="html">&lt;ul id=&quot;shiritori_list&quot;&gt;
  &lt;li&gt;1番目はりんご&lt;/li&gt;
  &lt;li&gt;2番目はゴリラ&lt;/li&gt;
  &lt;li&gt;3番目はラッパ&lt;/li&gt;
  &lt;li&gt;4番目はパイナップル&lt;/li&gt;
&lt;/ul&gt;
</code></pre></div>
<p>となる。</p>

<p><code>enter()</code> は配列の増加分に対して、DOM を生成してくれるわけだ。</p>

<h2>DOM の削除処理は data()＋exit()</h2>

<p>次は、<code>shiritori</code> 配列が HTML より小さくなったときに対応しよう。</p>

<p><code>exit()</code> で削除方法を書く。</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript">// ul#shiritori_list を選択
d3.select(&#39;ul#shiritori_list&#39;)
  .select(&#39;ul#shiritori_list&#39;)
  // その下の &lt;li&gt; を列挙
  .selectAll(&#39;li&#39;)
  // それぞれに shiritori 配列の要素を割り当てる
  .data(shiritori)
  // data の数よりも多い &lt;li&gt; については
  .exit()
  // 削除する
  .remove();
</code></pre></div>
<p>はい。これで終わり。</p>

<p><code>shiritori</code> が減ってないときは何も起こらないし、<code>shiritori.pop();</code> してから実行すると末尾の <code>&lt;li&gt;</code> は消える。<code>shiritori = [];</code> してから実行すると <code>&lt;li&gt;</code> は消えてなくなる。</p>

<h2>DOM の更新処理は data()</h2>

<p>最後に更新処理。</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript">// ul#shiritori_list を選択
d3.select(&#39;ul#shiritori_list&#39;)
  // その下の &lt;li&gt; を列挙
  .selectAll(&#39;li&#39;)
  // それぞれに shiritori 配列の要素を割り当てる
  .data(shiritori)
  // &lt;li&gt; の中身の文字を設定する
  .text(function(d, i) { return (i + 1) + &#39;番目は&#39; + d; });
</code></pre></div>
<p><code>enter()</code> や <code>exit()</code> なしにすれば、更新時の処理になる。</p>

<p>データが与えられたときに、それぞれの要素をどのように表示すべきかを記述している。配列を書き換えて、この処理を実行すると、中身の文字が適切に更新される。</p>

<p>ここでは <code>text()</code> しか使ってないが、jQuery 的な <code>attr()</code> や <code>style()</code> を活用すれば、柔軟な指定が可能である。</p>

<h2>全部まとめる</h2>

<p>生成・削除・更新の処理をまとめてみる。</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript">function update_shiritori() {
  var s = d3.select(&#39;ul#shiritori_list&#39;)
    .selectAll(&#39;li&#39;)
    .data(shiritori);

  // 作成
  s.enter().append(&#39;li&#39;);

  // 削除
  s.exit().remove();

  // 更新
  s.text(function(d, i) { return (i + 1) + &#39;番目は&#39; + d; });
}
</code></pre></div>
<p>(「作成」のところで <code>text()</code> を実行しなくなっているが、そのあとの「更新」のところでまとめて設定できるのでご安心を)</p>

<p>完成したソースを改めて見てみると、</p>

<ul>
<li>作成: 増えたデータに対して DOM を追加</li>
<li>削除: 減ったデータに対して DOM を削除</li>
<li>更新: データに対応する表示に更新</li>
</ul>

<p>という処理がシンプルに書けているのが嬉しい。</p>

<p>同じような書き方を jQuery でやるのは難しい。たぶん「毎回 DOM ツリーを作り直す」という富豪的な手順をとると思う。それだと効率が悪いし、次の例にあるような増減に関係したアニメーションを実現するのは困難である。</p>

<h1>Data-Driven なアニメーション</h1>

<p>今度は、少し色気を加えて、アニメーションさせる。</p>

<div>
<svg id="sample2" width="300" height="300" style="background: white; border: .3em solid #ccc;"></svg>
</div>

<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>

<script src="d3js-enter-exit.js" charset="utf-8"></script>

<p><button style="padding: .5em .8em" onclick="change()">random</button>
<button style="padding: .5em .8em" onclick="add()">push</button>
<button style="padding: .5em .8em" onclick="del()">pop</button></p>

<h2>使い方</h2>

<ul>
<li>初期状態では 10 個の要素を持った配列を表示している。</li>
<li>横軸が配列のインデックス、縦軸が要素の値 (0～1) をあらわす。</li>
<li>[random] ボタンを押すと、配列の中身がランダムな値で置き換わる。</li>
<li>[push] ボタンを押すと、配列の末尾に要素を追加する。</li>
<li>[pop] ボタンを押すと、配列の末尾から要素を取り除く。</li>
</ul>

<p>ボタンを押すと、アニメーションつきで見た目が変更するのを確認していただけるだろうか (SVG をサポートしてる必要があるので、モダンではないブラウザーでは表示できない)。</p>

<h2>コンソールからの変更にも対応</h2>

<p>このページを開いている状態であれば、JavaScript コンソールで直接</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript">values = [0.5, 0, 1];
update();
</code></pre></div>
<p>と入力しても、アニメーションつきで配列が反映されるはずだ。</p>

<h2>更新部分のソースコード</h2>

<p>では、その <code>update()</code> 関数をみてみよう。</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript">function update() {
  // 配列の個数を n に代入
  var n = values.length;

  // &lt;svg&gt; の中の &lt;circle&gt; を列挙して、values を割り当てる
  var circles = d3.select(&quot;svg#sample2&quot;)
    .selectAll(&#39;circle&#39;).data(values);

  // 作成: 足りない &lt;circle&gt; を追加する
  circles.enter()
    .append(&#39;circle&#39;)
    .attr(&#39;fill&#39;, &#39;red&#39;)
    .attr(&#39;cx&#39;, function(d, i) { return i * 280 / n + 10; })
    .attr(&#39;cy&#39;, 0).attr(&#39;r&#39;, 0);

  // 削除: 余分な &lt;circle&gt; はアニメーションつきで削除
  circles.exit()
    .transition()
    .duration(300)
    .attr(&#39;cy&#39;, 0).attr(&#39;r&#39;, 0)
    .remove();

  // 更新: アニメーションで正しい位置とサイズに移動
  circles
    .transition()
    .duration(300)
    .attr(&#39;cx&#39;, function(d, i) { return i * 280 / n + 10; })
    .attr(&#39;cy&#39;, function(d, i) { return d * 280 + 10; })
    .attr(&#39;r&#39;, 6);

  // 線の位置も調整する
  d3.select(&#39;svg#sample2 polyline&#39;)
    .transition()
    .duration(300)
    .attr(&#39;points&#39;, values.map(function(d, i) {
      return (i * 280 / n + 10) + &#39; &#39; + (d * 280 + 10);
    }).join(&#39;,&#39;));
}
</code></pre></div>
<p>画面の描画は SVG で行っている。</p>

<p>削除と更新のときに <code>transition()</code> でアニメーションを指定してる点に注目。これがアニメーションの肝である。</p>

<p>円の大きさのアニメーションを例に説明する。</p>

<p>「追加」のときには <code>&lt;circle&gt;</code> の半径を <code>0</code> で初期化している。そのあとの「更新」で <code>6</code> にしてる。その結果、追加時には徐々に大きくなりながら画面に現れる。</p>

<p>ソースが長くなって、多少複雑になったが、「追加」「削除」「更新」の基本は変わっていない。</p>

<h1>まとめ</h1>

<p><a href="http://d3js.org/">D3.js</a> の Data-Driven な DOM 操作を説明した。入力されたデータに対して、「追加」「削除」「更新」の処理を分けて書くことで、驚くほどシンプルに記述できることが分かった。</p>

<p>基礎が分かったら、<a href="(https://github.com/mbostock/d3/wiki/Gallery)">ギャラリー</a> と <a href="(https://github.com/mbostock/d3/wiki/API-Reference)">API リファレンス</a> を見比べれば、いろんな使い方が分かってくることだろう。あと、SVG の知識も必要にはなってくる。</p>

<p>D3.js は「表示機能がない」という異色のビジュアライズ用のライブラリーだけども、表示処理を自由に操れるということは、見た目のカスタマイズをやりやすくなる。この手のライブラリーで一番苦労するのが、ちょっとしたカスタマイズをやりにくいところなので、こういう設計は実はありがたいのかもしれない。</p>
]]></description>
		</item>

	</channel>
</rss>
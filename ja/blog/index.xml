<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>てっく煮ブログ</title>
		<link>http://tech.nitoyon.com/ja/blog/index.xml</link>
		<description>All Technology is Boiled in This Site.</description>
		<language>ja</language>
		<copyright>Copyright nitoyon.</copyright>
		<lastBuildDate>Thu, 07 Jan 2016 03:05:43 +0000</lastBuildDate>
		<docs>http://blogs.law.harvard.edu/tech/rss</docs>
		<atom:link href="http://tech.nitoyon.com/ja/blog/index.xml" rel="self" type="application/rss+xml" />


		<item>
			<title>Go 言語でアニメーション GIF を作成する</title>
			<link>http://tech.nitoyon.com/ja/blog/2016/01/07/go-animated-gif-gen/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2016/01/07/go-animated-gif-gen/</guid>
			<pubDate>Thu, 07 Jan 2016 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>Golang でアニメーション GIF を作る手順を 3 通り紹介します。</p>

<ul>
<li>フレームごとの画像から生成</li>
<li>ビデオから生成</li>
<li>Go 言語で最初から生成</li>
</ul>

<h1>フレームごとの画像から生成</h1>

<p>こんな GIF 画像があったとします (<a href="http://qiita.com/mattn/items/b7889e3c036b408ae8bd">ここ</a> より拝借)。</p>

<p><img src="/ja/blog/2016/01/07/go-animated-gif-gen/g1.gif" width="200" height="200">
<img src="/ja/blog/2016/01/07/go-animated-gif-gen/g2.gif" width="200" height="200">
<img src="/ja/blog/2016/01/07/go-animated-gif-gen/g3.gif" width="200" height="200"></p>

<p>変換結果はこんな感じ。</p>

<p><center><img src="/ja/blog/2016/01/07/go-animated-gif-gen/gopher.gif" width="200" height="200"></center></p>

<p>生成するためのコードはこんな感じ。</p>
<div class="highlight"><pre><code class="language-go" data-lang="go">package main

import &quot;image&quot;
import &quot;image/gif&quot;
import &quot;os&quot;

func main() {
    files := []string{&quot;g1.gif&quot;, &quot;g2.gif&quot;,&quot;g3.gif&quot;, &quot;g2.gif&quot;}

    // 各フレームの画像を GIF で読み込んで outGif を構築する
    outGif := &amp;gif.GIF{}
    for _, name := range files {
        f, _ := os.Open(name)
        inGif, _ := gif.Decode(f)
        f.Close()

        outGif.Image = append(outGif.Image, inGif.(*image.Paletted))
        outGif.Delay = append(outGif.Delay, 0)
    }

    // out.gif に保存する
    f, _ := os.OpenFile(&quot;out.gif&quot;, os.O_WRONLY|os.O_CREATE, 0600)
    defer f.Close()
    gif.EncodeAll(f, outGif)
}
</code></pre></div>
<p>注意したいポイントは次の通り。</p>

<ul>
<li>フレームの GIF を順番に <code>gif.Decode</code> で読み込んでいる。JPEG から生成するには、GIF への変換処理を実装する必要がある (<a href="https://github.com/srinathh/goanigiffy">goanigiffy</a> では <code>gif.Encode</code> と <code>gif.Decode</code> を呼んで変換している)。</li>
<li>GIF アニメーションを生成するには <code>gif.EncodeAll</code> を呼ぶ。</li>
</ul>

<h1>ビデオから生成</h1>

<p><a href="http://www.mplayerhq.hu/">MPlayer</a> を使って各フレームの画像を抽出してから、<a href="https://github.com/srinathh/goanigiffy">goanigiffy</a> で GIF アニメーションを生成する (詳しくは <a href="http://srinathh.github.io/opensource/goanigiffy/">GoAniGiffy</a>  を参照)。</p>

<h1>Go 言語で最初から生成</h1>

<p>こんな感じのものを作ってみた。</p>

<p><center><img src="/ja/blog/2016/01/07/go-animated-gif-gen/rgb.gif" width="240" height="240"></center></p>

<p>各フレームの画像を Go 言語で描画して <code>[]*image.Paletted</code> を作って、<code>gif.EncodeAll</code> に渡している。</p>
<div class="highlight"><pre><code class="language-go" data-lang="go">    var images []*image.Paletted
    var delays []int

    // 20 個の画像を生成して円を描く
    for step := 0; step &lt; 20; step++ {
        img := image.NewPaletted(image.Rect(0, 0, w, h), palette)
        images = append(images, img)
        delays = append(delays, 0)

        // 描画処理 (長いので省略)
    }

    // rgb.gif に保存する
    f, _ := os.OpenFile(&quot;rgb.gif&quot;, os.O_WRONLY|os.O_CREATE, 0600)
    defer f.Close()
    gif.EncodeAll(f, &amp;gif.GIF{
        Image: images,
        Delay: delays,
    })
</code></pre></div>
<p>全体のコードはこんな感じ。</p>
<div class="highlight"><pre><code class="language-go" data-lang="go">package main

import (
    &quot;image&quot;
    &quot;image/color&quot;
    &quot;image/gif&quot;
    &quot;math&quot;
    &quot;os&quot;
)

type Circle struct {
    X, Y, R float64
}

func (c *Circle) Brightness(x, y float64) uint8 {
    var dx, dy float64 = c.X - x, c.Y - y
    d := math.Sqrt(dx*dx+dy*dy) / c.R
    if d &gt; 1 {
        return 0
    } else {
        return 255
    }
}

func main() {
    var w, h int = 240, 240
    var hw, hh float64 = float64(w / 2), float64(h / 2)
    circles := []*Circle{&amp;Circle{}, &amp;Circle{}, &amp;Circle{}}

    var palette = []color.Color{
        color.RGBA{0x00, 0x00, 0x00, 0xff},
        color.RGBA{0x00, 0x00, 0xff, 0xff},
        color.RGBA{0x00, 0xff, 0x00, 0xff},
        color.RGBA{0x00, 0xff, 0xff, 0xff},
        color.RGBA{0xff, 0x00, 0x00, 0xff},
        color.RGBA{0xff, 0x00, 0xff, 0xff},
        color.RGBA{0xff, 0xff, 0x00, 0xff},
        color.RGBA{0xff, 0xff, 0xff, 0xff},
    }

    var images []*image.Paletted
    var delays []int
    steps := 20
    for step := 0; step &lt; steps; step++ {
        img := image.NewPaletted(image.Rect(0, 0, w, h), palette)
        images = append(images, img)
        delays = append(delays, 0)

        θ := 2.0 * math.Pi / float64(steps) * float64(step)
        for i, circle := range circles {
            θ0 := 2 * math.Pi / 3 * float64(i)
            circle.X = hw - 40*math.Sin(θ0) - 20*math.Sin(θ0+θ)
            circle.Y = hh - 40*math.Cos(θ0) - 20*math.Cos(θ0+θ)
            circle.R = 50
        }

        for x := 0; x &lt; w; x++ {
            for y := 0; y &lt; h; y++ {
                img.Set(x, y, color.RGBA{
                    circles[0].Brightness(float64(x), float64(y)),
                    circles[1].Brightness(float64(x), float64(y)),
                    circles[2].Brightness(float64(x), float64(y)),
                    255,
                })
            }
        }
    }

    f, _ := os.OpenFile(&quot;rgb.gif&quot;, os.O_WRONLY|os.O_CREATE, 0600)
    defer f.Close()
    gif.EncodeAll(f, &amp;gif.GIF{
        Image: images,
        Delay: delays,
    })
}
</code></pre></div>
<p>以上です。</p>
]]></description>
		</item>

		<item>
			<title>Go 言語でソースコードから画像生成する</title>
			<link>http://tech.nitoyon.com/ja/blog/2015/12/31/go-image-gen/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2015/12/31/go-image-gen/</guid>
			<pubDate>Thu, 31 Dec 2015 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>Go 言語には画像生成する image パッケージが標準で入っている。imagemagick や GD を導入する必要がないので、気軽に画像を生成できて便利そうだったので試してみた。</p>

<p>ただ、標準ではピクセル単位で色を設定することしかできないので、線を引いたり色を塗ったりするには、何らかのライブラリーに頼る必要がある。</p>

<p>今回は、ライブラリーには頼らず、標準で提供されている機能だけでできることを試してみた。</p>

<h1>一番簡単な例</h1>

<p>簡単な画像を生成する例は次の通り。1つ点を打つだけの例。</p>
<div class="highlight"><pre><code class="language-go" data-lang="go">package main

import &quot;image&quot;
import &quot;image/color&quot;
import &quot;image/png&quot;
import &quot;os&quot;

func main() {
    // 100×50 の画像を作成する
    img := image.NewRGBA(image.Rect(0, 0, 100, 50))

    // (2, 3) に赤い点をうつ
    img.Set(2, 3, color.RGBA{255, 0, 0, 255})

    // out.png に保存する
    f, _ := os.OpenFile(&quot;out.png&quot;, os.O_WRONLY|os.O_CREATE, 0600)
    defer f.Close()
    png.Encode(f, img)
}
</code></pre></div>
<h1>もっと複雑な例</h1>

<p>こんな画像を生成してみる。</p>

<p><center><img src="rgb1.png" width="280" height="240"></center></p>

<p>コードはこうなった。</p>
<div class="highlight"><pre><code class="language-go" data-lang="go">package main

import (
    &quot;fmt&quot;
    &quot;image&quot;
    &quot;image/color&quot;
    &quot;image/png&quot;
    &quot;math&quot;
    &quot;os&quot;
)

type Circle struct {
    X, Y, R float64
}

func (c *Circle) Brightness(x, y float64) uint8 {
    var dx, dy float64 = c.X - x, c.Y - y
    d := math.Sqrt(dx*dx+dy*dy) / c.R
    if d &gt; 1 {
        return 0
    } else {
        return 255
    }
}

func main() {
    var w, h int = 280, 240
    var hw, hh float64 = float64(w / 2), float64(h / 2)
    r := 40.0
    θ := 2 * math.Pi / 3
    cr := &amp;Circle{hw - r*math.Sin(0), hh - r*math.Cos(0), 60}
    cg := &amp;Circle{hw - r*math.Sin(θ), hh - r*math.Cos(θ), 60}
    cb := &amp;Circle{hw - r*math.Sin(-θ), hh - r*math.Cos(-θ), 60}

    m := image.NewRGBA(image.Rect(0, 0, w, h))
    for x := 0; x &lt; w; x++ {
        for y := 0; y &lt; h; y++ {
            c := color.RGBA{
                cr.Brightness(float64(x), float64(y)),
                cg.Brightness(float64(x), float64(y)),
                cb.Brightness(float64(x), float64(y)),
                255,
            }
            m.Set(x, y, c)
        }
    }

    f, err := os.OpenFile(&quot;rgb.png&quot;, os.O_WRONLY|os.O_CREATE, 0600)
    if err != nil {
        fmt.Println(err)
        return
    }
    defer f.Close()
    png.Encode(f, m)
}
</code></pre></div>
<p><code>Circle</code> 構造体を定義して、円の中に入っているかどうかを判定する処理をメソッドとして定義している。</p>

<p>ちょっとしたテクニックとして、色を決定する部分は次のようにしている。</p>
<div class="highlight"><pre><code class="language-go" data-lang="go">c := color.RGBA{
    cr.Brightness(float64(x), float64(y)),
    cg.Brightness(float64(x), float64(y)),
    cb.Brightness(float64(x), float64(y)),
    255,
}
</code></pre></div>
<p>赤い色の中のときは赤色成分は <code>255</code>、外のときは <code>0</code> としている。他の成分も同じ。</p>

<h1>周辺をぼかしてみる</h1>

<p>色がくっきりしすぎているので、画像の周りをぼかしてみた。</p>

<p><center><img src="rgb2.png" width="280" height="240"></center></p>

<p>円の中のときに <code>return 255</code> としていた部分を書きかえるだけでできた。</p>
<div class="highlight"><pre><code class="language-go" data-lang="go">func (c *Circle) Brightness(x, y float64) uint8 {
    var dx, dy float64 = c.X - x, c.Y - y
    d := math.Sqrt(dx*dx+dy*dy) / c.R
    if d &gt; 1 {
        // 円の外のとき
        return 0
    } else {
        // 円の中のとき
        return uint8((1 - math.Pow(d, 5)) * 255)
    }
}
</code></pre></div>
<p><code>math.Pow</code> で 5 乗しているのは、ぼけすぎないようにするための工夫。</p>
]]></description>
		</item>

		<item>
			<title>Visual Studio Code は JavaScript 開発が超絶便利になる可能性を秘めている！</title>
			<link>http://tech.nitoyon.com/ja/blog/2015/11/20/try-vscode/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2015/11/20/try-vscode/</guid>
			<pubDate>Fri, 20 Nov 2015 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>クロスプラットフォームでオープンソースな IDE 環境、<a href="https://code.visualstudio.com/">Visual Studio Code</a> が公開されたので試してみた。</p>

<p>拡張を入れなくても、デフォルトで JavaScript の「自動 Lint」「Grunt、Gulp 連携」「デバッグ」が動いた。なんだかすごく便利そうな予感。</p>

<p>Windows 環境で起動してみたらこんな画面だった。</p>

<p><center><img src="https://farm6.staticflickr.com/5728/22827535010_6c3f9d80da_z_d.jpg" width="500" height="384"></center></p>

<p>なんか黒いが、色は好みにカスタマイズできるし、プリセットからも選べる。</p>

<h1>フォルダーを開くことから始まる</h1>

<p>Visual Studio Code にはプロジェクトの概念はない。</p>

<p>[File] &gt; [Open Folder] からフォルダーを開けばよい。</p>

<p>ためしに、過去に作った Node.js 製の <a href="https://github.com/nitoyon/livereloadx">livereloadx</a> のフォルダーを開いてみた。</p>

<p><center><img src="https://farm1.staticflickr.com/684/22525086774_635323dd04.jpg" width="500" height="372"></center></p>

<p>左側にツリーが表示されている。プロジェクト内のファイルを開くにはツリー上でクリックしてもいいし、<code>Ctrl+P</code> を押せば、ファイル名でインクリメンタル検索できる (上の図では <code>fi</code> と入力しているので、<code>filter.js</code> や <code>config.js</code> が引っかかってる)。</p>

<p>ファイル内の文字列で検索するには、左の虫眼鏡を押すか、<code>Ctrl+Shift+F</code> から。</p>

<h1>自動 Lint</h1>

<p>左下の警告マークのところに 4 と出てるのでクリックしてみると、<code>Buffer</code> とか <code>__dirname</code> が見つからないといわれた。</p>

<p><center><img src="https://farm6.staticflickr.com/5661/22755770339_70279498fa.jpg" width="500" height="326"></center></p>

<p>警告をクリックして、電球マークをクリックすると、「<code>node.d.ts</code> をダウンロードする」というオプションがでてきた。</p>

<p><center><img src="https://farm6.staticflickr.com/5724/22729696698_2a9cd7fd7f.jpg" width="500" height="126"></center></p>

<p><code>d.ts</code> は TypeScript の型定義ファイル。これの Node.js 用を自動的に落とせるようだ。</p>

<p>落とすと警告は減った。が・・・本当に対処したほうがいいやつが出てきた・・・。</p>

<p><center><img src="https://farm1.staticflickr.com/703/22827902400_6bcc58719d.jpg" width="500" height="231"></center></p>

<p>ESLint と JSHint に<a href="https://code.visualstudio.com/docs/languages/javascript#_javascript-linters-eslint-jshint">対応している</a>らしい。</p>

<h1>Git 連携！</h1>

<p>コードを修正すると、左側の Git マークのところに数字が！</p>

<p>Git マークを押すと、最後のコミットから変更されたファイルが出てくる。<code>git status</code> の GUI 版みたいな感じ。</p>

<p><center><img src="https://farm1.staticflickr.com/762/23159649771_89618bc4da.jpg" width="500" height="357"></center></p>

<p>ファイルを選択すると差分が分かるし、＋マークを押すと <code>git add</code> するし、矢印を押すと変更を破棄できる。上の部分にメッセージを書くとコミットできる。</p>

<p>Git フレンドリー！</p>

<h1>Grunt, Gulp 連携</h1>

<p><code>Ctrl+Shift+T</code> を押すと、何も設定してないのに単体テストが走った!!</p>

<p><center><img src="https://farm6.staticflickr.com/5671/22729591857_d052424b76.jpg" width="500" height="391"></center></p>

<p>右側に単体テストの結果が表示されている。</p>

<p>理由は <code>Gruntfile.js</code> に <code>test</code> というタスクが登録してあるから。Visual Studio Code さんは、Grunt や Gulp、Jake のタスクを自動的に解釈してくれているのだ。</p>

<p>他にも <code>build</code> というタスクがあれば、<code>Ctrl+Shift+B</code> でビルドが走るらしい。カッコイイ。</p>

<p>もちろん、それ以外のタスクも開始できる。</p>

<p><code>F1</code> から <code>Run Task</code> を入力すると、実行できるタスクの一覧が出てくる。ためしに、<code>watch</code> タスクを選択すると、IDE 内において「編集したら、Lint して単体テスト、結果を表示」というフローが実現できた。カッコイイ。</p>

<p><center><img src="https://farm1.staticflickr.com/741/22828175870_7aa3f707a3.jpg" width="500" height="391"></center></p>

<h1>デバッグ!!!</h1>

<p>コードの適当なところに <code>F9</code> でブレークポイントを設定して、<code>F5</code> でデバッグを開始してみる。</p>

<p><center><img src="https://farm1.staticflickr.com/772/22827919780_706feaecf0.jpg" width="500" height="134"></center></p>

<p>「Node.js と Mono のどっちをデバッグする？」と聞かれた。<a href="https://marketplace.visualstudio.com/vscode/Debuggers">拡張</a>を入れたら他の言語もデバッグできるらしい。</p>

<p>ここでは Node.js を選ぶ。</p>

<p><code>.vscode/launch.json</code> が開くので、ここで何をデバッグするか設定する。</p>

<p><center><img src="https://farm1.staticflickr.com/581/22729605137_caeedb1cca.jpg" width="500" height="316"></center></p>

<p><code>program</code> のところで開始する JS ファイルを指定してみた。</p>

<p>再度、F5 でデバッグを始める。</p>

<p><center><img src="https://farm1.staticflickr.com/768/23134119082_5caca8673f.jpg" width="500" height="357"></center></p>

<p>ブレークポイントで止まった。</p>

<p>左上の Variables にはローカル変数やクロージャー内の変数の値が出てくる。左下にはスタックトレースがある。</p>

<p><code>F10</code> でステップオーバー、<code>F11</code> でステップイン、<code>Shift+F11</code> でステップアウトできるのは Visual Studio と同じ。</p>

<h1>他にも機能はたくさん</h1>

<p>まだまだ確認しきれていないが、機能はたくさんあるようだ。</p>

<ul>
<li>TypeScript なら変数名の変更やシンボル名での検索にも対応してるらしい。</li>
<li>コードスニペットは、特定の文字を入力して、Tab を押したら定型文を挿入してくれるので便利そう。</li>
<li>CSS (Sass, Less) にも対応してる。Lint するし、<code>Ctrl+Shift+O</code> でシンボルに飛べる。</li>
<li>この記事の Markdown を Visual Studio Code で書いているが、<code>Ctrl+V</code> でプレビューできる。</li>
</ul>

<p>言語ごとに何ができるかは、<a href="https://code.visualstudio.com/docs/languages/overview">ドキュメント</a> の LANGUAGES の中をみると一通り書いてある。</p>

<p>エディターとしての機能はまだ確認しきれていない。Windows なら日本語は問題なく通る。折り返しできない (?) のが、今この記事を書いていて不便に感じる。動作はサクサクしている。</p>

<p>(追記) Workspace Settings から <code>&quot;editor.wrappingColumn&quot;</code> の値を変えたら、折り返し幅も変わった。</p>

<h1>雑感</h1>

<p>ここまでの機能がデフォルトで有効になっている、というのはなかなかの衝撃であった。</p>

<p>ほめちぎりすぎたので、最後に悪いところも書いておく。</p>

<p>現状の Visual Studio Code は、メインメニューやコンテキストメニューが状況に応じて変化しない。便利な機能を使うためには、ショートカットキーを覚えるのが前提になっている。ドキュメントを読まないと何ができるのか見当つかないし、ショートカットを覚えるコストも高い。</p>

<p><a href="https://code.visualstudio.com/docs/">公式のドキュメント</a>はよくできているので、一通り読めば分かるんだけど、言語ごとに使える機能に違いがあるので、そのあたりもややこしい。</p>

<p>自分は Visual Studio を普段使いしてるので、慣れてるショートカットキーがそのまま使えて、手触りはとてもよかった。</p>
]]></description>
		</item>

		<item>
			<title>Object.observe の死 (ECMAScript の提案取り下げ、V8 からも削除予定)</title>
			<link>http://tech.nitoyon.com/ja/blog/2015/11/18/death-of-oo/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2015/11/18/death-of-oo/</guid>
			<pubDate>Wed, 18 Nov 2015 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>1年前の記事 <a href="/ja/blog/2014/07/18/data-binding/">JavaScript フレームワークがデータバインディングを実現する４通りの手法</a> では、<code>Object.observe()</code> について次のように説明した。</p>

<ul>
<li>JavaScript オブジェクトが変更されたときにコールバックを呼んでくれる API</li>
<li>データバインディングの実装が簡単になる</li>
<li>Google Chrome には実装済み</li>
<li>ECMAScript 7 に提案中</li>
<li>提案が通れば MV* フレームワークの実装がシンプルになってハッピー</li>
</ul>

<p>将来を期待されていた <code>Object.observe()</code> であったが、2015 年 11 月頭、ES Discuss メーリングリストへの <a href="https://esdiscuss.org/topic/an-update-on-object-observe">An update on Object.observe</a> という投稿で、ECMAScript からの提案が取り下げられて、V8 エンジンからも年内に削除される予定であることが表明された。</p>

<h1>Object.observe() に何があったのか</h1>

<p>メーリングリストへの投稿をざっくりと訳してみた。</p>

<blockquote>
<p>3年前、Rafael Weinstein、Erik Arvidsson、私 (Adam Klein) で、データバインディングを実現するための API を設計し始めた。V8 上のブランチでプロトタイプを作成したあと、V8 チームに正式版を開発することを認めてもらった。さらに、Object.observe (以下、&quot;O.o&quot; と表記) を ES7 標準に提案しつつ、Polymer チームと協力して O.o を使ってデータバインディングを実装した。</p>

<p>3年後、世界は大きく変わった。Ember や Angular といったフレームワークは O.o に興味を示したものの、既存のモデルを O.o のモデルに発展させるのは難しかった。Polymer は 1.0 をリリースするにあたりゼロから書き直されたが、そこでは O.o は使われなかった。さらに、React のような、データバインディングでミュータブルなものを避けようとする処理モデルが人気を博している。</p>

<p>関係者との議論の末、Object.observe の提案を TC39 (現在、ES 仕様策定のステージ 2) から取り下げることにした。また、今年の終わりまでには V8 でのサポートを終了したいと考えている (<a href="https://www.chromestatus.com/metrics/feature/popularity">chromestatus.com</a> によると、Chrome がアクセスしたページのうち 0.0169% でしか O.o は利用されていない)。</p>

<p>O.o を使っていた開発者は、<a href="https://github.com/MaxArt2501/object-observe">object-observe</a> のような polyfill や <a href="https://github.com/polymer/observe-js">observe-js</a> のようなラッパーライブラリーを使うことを検討してほしい。</p>
</blockquote>

<p><code>Object.observe()</code> は他のフレームワークで使われることもなかったし、Polymer でも使われなくなってしまったので、ECMAScript への提案を取り下げる、ということのようだ。</p>

<h1>Polymer 1.0 のデータバインディング実現方法</h1>

<p>Polymer が <code>Object.observe()</code> を使わなくなった理由については、Polymer の開発にも関わっている Brian Chin さんから <a href="https://esdiscuss.org/topic/an-update-on-object-observe">スレッド</a> 内に次のような<a href="https://esdiscuss.org/topic/an-update-on-object-observe#content-4">コメントがでている</a>。</p>

<blockquote>
<p>O.o はプロパティーを変更したあと、非同期でコールバックが呼ばれるのがイケてなかった。Polymer 1.0 ではプロパティーを変更したら、すぐに変更が UI に反映されるので、利用者にも分かりやすくなっている。</p>
</blockquote>

<p>モデルを書きかえた瞬間に、UI に反映されるようにしたかった、というのがメインの理由のようだ。</p>

<p>「じゃ、Polymer は <code>Object.observe()</code> の代わりに何を使ってるの？」という質問に対しては、次のような<a href="https://esdiscuss.org/topic/an-update-on-object-observe#content-2">回答</a>が出ている。</p>

<blockquote>
<p>getter/setter を定義して、DOM イベントで伝搬させてるよ。詳しくは polymer-project.org を見てね。たとえば <a href="https://www.polymer-project.org/1.0/docs/devguide/properties.html#change-callbacks">ここ</a> とか <a href="https://www.polymer-project.org/1.0/docs/devguide/data-binding.html#change-notification-protocol">ここ</a> だよ</p>
</blockquote>

<p>ざっと上記のページを見た感じでは、次のような感じでデータバインディングに使うプロパティーを宣言しておくらしい。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  Polymer({
    is: &#39;custom-element&#39;,
    properties: {
      someProp: {
        type: String,
        notify: true
      }
    }
  });
</code></pre></div>
<p>スレッドには、他にも「ブラウザーでは使われないかもしれないけど、Node.js のエコシステムには大きな影響があるかもしれないから、そんなに急に削除しないでくれ」と Node.js の中の人が書き込んでいたり、「Firefox の <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/watch">Object.watch()</a> はデバッガーで使われてるからすぐに削除されることはないはず」といった書き込みがあったりして興味深い。</p>

<h1>まとめ</h1>

<p><code>Object.observe()</code> は ECMAScript 7 に入ることはなくなったので、他のブラウザーに 実装される可能性はなくなったし、Google Chrome でも近い将来、使えなくなるだろう。</p>
]]></description>
		</item>

		<item>
			<title>JavaScript フレームワークがデータバインディングを実現する４通りの手法</title>
			<link>http://tech.nitoyon.com/ja/blog/2014/07/18/data-binding/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2014/07/18/data-binding/</guid>
			<pubDate>Fri, 18 Jul 2014 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>最近流行りの JavaScript MV* フレームワークは、どれもデータバインディングをサポートしているが、実現方法はフレームワークによって異なる。</p>

<p>この記事では、各種フレームワークが<strong>どのようにモデルの変更を検知しているか</strong>を次の 4 つのパターンに分類して紹介する。</p>

<ol>
<li>モデル クラス方式 (Ember.js、Backbone.js、Ractive.js、Knockout.js など)</li>
<li>力ずく方式 (AngualrJS)</li>
<li>モデル書き換え方式 (Vue.js)</li>
<li>Object.observe 方式 (Polymer)</li>
</ol>

<p>パターン名は私が勝手に名づけたものだけど、このへんの雰囲気が理解できれば、フレームワークごとの個性が分かるだろうし、利用イメージもわきやすいんじゃないかと思っている。</p>

<h1>1. モデル クラス方式</h1>

<p>「モデルとして扱えるのはフレームワークが用意したモデル クラスのインスタンスだけ」という制約を課すのがこの方式。</p>

<p>たとえば、Ember.js では <code>{title: &quot;てっく煮&quot;}</code> という情報をデータバインディングで利用しようと思ったら、次のようにしてモデル クラスのインスタンスを作る必要がある。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">var a = Ember.Object.create({title: &quot;てっく煮&quot;})
console.log(a.get(&#39;title&#39;)); // てっく煮
</code></pre></div>
<p>モデルを変更するには <code>set()</code> メソッドを使う。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">a.set(&#39;title&#39;, &#39;!!!!&#39;);
console.log(a.get(&#39;title&#39;)); // !!!!
</code></pre></div>
<p>当然、フレームワーク側はモデルの値が変更されたことを検知できる。検知したら、あとはフレームワークは新しい値に応じて DOM を書き換えればよい。とてもシンプルな構造だ。</p>

<p>使う側の視点でみると、<code>get()</code> や <code>set()</code> を呼ぶのが面倒だし、ラッパーの API は JavaScript の <code>Object</code> や <code>Array</code> と扱い方が違うし、さらに、既存のモデルがある場合は流用できない (作成・取得・変更処理を全部置き換える必要がある) し・・・、と不便な印象がある。</p>

<p>これ以降の方式は、ネイティブな <code>Object</code> や <code>Array</code> などをモデルとして扱えるように工夫している。</p>

<h2>この方式を採用するフレームワークが多い</h2>

<p>現時点においては、この方式を採用するフレームワークが多数派である。</p>

<p><a href="http://qiita.com/tekkoc/items/eb5ab65524c3e5b4a11c">Backbone.jsなどのライブラリのgetter, setterがダサい理由と、その解消方法 - Qiita</a> によると、Backbone.js、Knockout.js、Ractive.js も同じ方式を採用しているらしい。</p>

<blockquote>
<p>Backbone.js と Ractive.js は <code>get(&quot;hoge&quot;)</code> や <code>set(&quot;hoge&quot;, value)</code> という形式。
Knockout.js は少しマシで <code>hoge()</code> で取得し <code>hoge(value)</code> で設定する形式。</p>
</blockquote>

<h1>2. 力ずく方式</h1>

<p>お次は <a href="(https://angularjs.org/)">AngularJS</a> が採用しているヤツを説明しよう。英語では &quot;dirty check&quot; と呼んでいる。</p>

<p>AngularJS はネイティブな <code>Object</code> や <code>Array</code> をモデルとして渡せるし、独自クラスのオブジェクトだって渡せる。</p>

<p>たとえば、モデルが <code>{title: &#39;てっく煮&#39;}</code> だったとしよう。モデルはネイティブなオブジェクトなので、変更をプッシュ通知で受け取るのは諦めている。</p>

<p>そんな前提なので、AngularJS は <strong>何かあるごとに</strong> <code>title</code> の値が変化したかどうかを自力でチェックする。変化してれば DOM を書き換える。オブジェクトの参照が変わってしまうこともあるので、「前回の値」はディープコピーして覚えている。</p>

<p>とても力技なので処理にはオーバーヘッドがある。ソースコードも複雑になっている。</p>

<h2>「何かあるごとに」はいつか？</h2>

<p>さて、さきほど「何かあるごとに」と書いたが、前回の値と今の値を比較するタイミングはいつだろうか。</p>

<p>正解は「AngularJS 経由で JavaScript のコードを実行したとき」である。</p>

<p>たとえば、ボタンのクリックイベントに関しては <code>&lt;button ng-click=&quot;foo()&quot;&gt;</code> のように書くと、AngularJS 経由で <code>foo()</code> が呼ばれる。<code>setTimeout()</code> の処理であれば、<code>$timeout</code> を使えば AngularJS 経由でコールバックが呼ばれる。</p>

<p>コールバックを読んだとき、モデルの値は変更されるかもしれないし、実際には変更されないかもしれない。変更されたか調べるために、呼び終わったあとに、力ずくで調べるのだ。</p>

<p>直接 DOM イベントを監視するようなときには AngularJS を経由させるのは難しい。そういうときには <code>$scope.$apply()</code> に関数を渡すと、関数を呼んだあとに力ずくの比較処理をやってくれる。</p>

<p>AngularJS を使う側の視点からすると、モデルへの変更を HTML に確実に反映させるには、<code>ng-click</code> や <code>$timeout</code>、<code>$scope.$apply()</code> など使って AngularJS 経由でモデルを変更する必要がある。</p>

<h2>力ずく方式のまとめ</h2>

<ul>
<li><code>Object</code> や <code>Array</code> や独自クラスのインスタンスをモデルにできる</li>
<li>比較処理がトリガーされるかどうかを意識する必要がある</li>
<li>比較処理のオーバーヘッドがある</li>
</ul>

<h1>3. モデル書き換え方式</h1>

<p>こちらは <a href="http://vuejs.org/">Vue.js</a> が採用している方式である。</p>

<p>Vue.js もネイティブな <code>Object</code> や <code>Array</code> をモデルとして渡せる。</p>

<p>たとえば、オブジェクトのキーの変更を検知するために、キーを (ECMAScript 5 的な) プロパティーに書き換える。配列の変更を検知するために、<code>Array.prototype</code> を書き換えて <code>push()</code> メソッドなどを置き換える。</p>

<p>AngularJS のように力ずくの比較は行わないので動作は速いのが利点。Vue.js のサイトでも <a href="http://vuejs.org/perf/">他のフレームワークより速いこと</a> を自慢している。</p>

<p>一方の弱点は、次の通り。</p>

<ul>
<li>モデルとして受け取ったオブジェクトを書き換えてしまう</li>
<li>完全に変更を検知できない (完全に検知できないので、一部の変更処理については、<code>$set()</code> や <code>$add()</code> といったメソッドを使う必要がある。ラッパー オブジェクト的な要素が残っているといえる)。</li>
</ul>

<p>詳しくは <a href="/ja/blog/2014/06/30/vue-js-hook/">Vue.js が data に渡した値を激しく書き換える件について</a> に書いたので見てほしい。</p>

<h1>4. Object.observe() 方式</h1>

<p>現在、ECMAScript には「オブジェクトの変更を検知する」という機能を持つ <code>Object.observe()</code> というメソッドが提案されていて、仕様決定に先立って <a href="http://www.chromestatus.com/features/6147094632988672">Google Chrome 36 ではデフォルトで有効</a> になっている。</p>

<p>ためしに Google Chrome 36 の JavaScript コンソールで使ってみる。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">&gt; a = {foo: 1}
&gt; Object.observe(a, function(changes) { console.log(changes); })
&gt; a.foo = 3
  [Object]
      0: Object
          name: &quot;foo&quot;
          object: Object
              foo: 3
          oldValue: 1
          type: &quot;update&quot;
&gt; a.bar = 10
  [Object]
      0: Object
          name: &quot;bar&quot;
          object: Object
              bar: 10
              foo: 3
          type: &quot;add&quot;
</code></pre></div>
<p>まさにデータバインディングで使ってくれといっているようなメソッドである。</p>

<p><a href="(http://www.polymer-project.org/)">Polymer</a> は <code>Object.observe()</code> を前提としている。さらに、先ほどから紹介していた各種ライブラリーについても、AngularJS は 2.0 での対応を<a href="http://blog.angularjs.org/2014/03/angular-20.html">検討している</a> し、Vue.js は v0.11.x で<a href="https://github.com/yyx990803/vue/issues/78">対応予定</a> となっている。</p>

<p>ECMAScript に <code>Object.observe()</code> が取り込まれれば、ここまで紹介したようなややこしいデータバインディングの仕組みは不要となる。まさに、データバインディングのための API であるが、ECMAScript 6 にも入っておらず、すべてのブラウザーで使えるようになるには時間がかかりそうだ。
<code>Object.observe()</code> については以下のページが詳しかった。</p>

<ul>
<li><a href="http://d.hatena.ne.jp/jovi0608/20121206/1354762082">次世代JavaScriptでデータバインディング： Object.observe() を試す - ぼちぼち日記</a></li>
<li><a href="http://www.html5rocks.com/en/tutorials/es7/observe/">Data-binding Revolutions with Object.observe() - HTML5 Rocks</a></li>
</ul>

<h1>まとめ</h1>

<p>MV* フレームワークが「どのようにモデルの変更を検知しているか」を 4 通り紹介した。</p>

<ul>
<li>オブジェクト指向的なモデル クラスを使う方式が主流。</li>
<li><a href="(https://angularjs.org/)">AngularJS</a> や <a href="http://vuejs.org/">Vue.js</a> はネイティブな値をモデルとして扱うために頑張っている。</li>
<li><code>Object.observe()</code> が使えるようになれば、フレームワークの苦しみが減る。<a href="(http://www.polymer-project.org/)">Polymer</a> はそこを見据えている。</li>
</ul>
]]></description>
		</item>

	</channel>
</rss>
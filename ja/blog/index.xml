<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>てっく煮ブログ</title>
		<link>http://tech.nitoyon.com/ja/blog/index.xml</link>
		<description>All Technology is Boiled in This Site.</description>
		<language>ja</language>
		<copyright>Copyright nitoyon.</copyright>
		<lastBuildDate>Mon, 10 Dec 2012 00:38:01 +0000</lastBuildDate>
		<docs>http://blogs.law.harvard.edu/tech/rss</docs>
		<atom:link href="http://tech.nitoyon.com/ja/blog/index.xml" rel="self" type="application/rss+xml" />









		<item>
			<title>Lightroom 4 では 5.1ch の動画は音なしになっちゃう話</title>
			<link>http://tech.nitoyon.com/ja/blog/2012/12/10/lightroom-5.1ch-mts/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2012/12/10/lightroom-5.1ch-mts/</guid>
			<pubDate>Mon, 10 Dec 2012 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>Lightroom は 4.0 から動画編集ができるようになって便利になっている。動画編集といっても、ざっくりした色合いの修正と開始位置・終了位置の変更ぐらいで、本当にカジュアルな修正にのみ対応している。ザッと撮った動画を、ザッと編集して、ザッと Flickr や Facebook にアップロードできるので重宝している。</p>

<p>最近、新しいビデオカメラ <a href="http://www.amazon.co.jp/SONY-HD%E3%83%93%E3%83%87%E3%82%AA%E3%82%AB%E3%83%A1%E3%83%A9-Handycam-HDR-CX590V-%E3%83%9C%E3%83%AB%E3%83%89%E3%83%BC%E3%83%96%E3%83%A9%E3%82%A6%E3%83%B3/dp/B006WX5P36%3FSubscriptionId%3DAKIAJTLVJPAVA2KR4PJA%26tag%3Dnitoyoncom-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3DB006WX5P36">SONY HDビデオカメラ Handycam HDR-CX590V ボルドーブラウン</a> を購入した。</p>

<div class="hatena-asin-detail">
  <a href="http://www.amazon.co.jp/SONY-HD%E3%83%93%E3%83%87%E3%82%AA%E3%82%AB%E3%83%A1%E3%83%A9-Handycam-HDR-CX590V-%E3%83%9C%E3%83%AB%E3%83%89%E3%83%BC%E3%83%96%E3%83%A9%E3%82%A6%E3%83%B3/dp/B006WX5P36%3FSubscriptionId%3DAKIAJTLVJPAVA2KR4PJA%26tag%3Dnitoyoncom-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3DB006WX5P36"><img src="http://ecx.images-amazon.com/images/I/41KN5L1OGHL._SL160_.jpg" class="hatena-asin-detail-image" alt="SONY HDビデオカメラ Handycam HDR-CX590V ボルドーブラウン" title="SONY HDビデオカメラ Handycam HDR-CX590V ボルドーブラウン"></a>
  <div class="hatena-asin-detail-info">
    <p class="hatena-asin-detail-title"><a href="http://www.amazon.co.jp/SONY-HD%E3%83%93%E3%83%87%E3%82%AA%E3%82%AB%E3%83%A1%E3%83%A9-Handycam-HDR-CX590V-%E3%83%9C%E3%83%AB%E3%83%89%E3%83%BC%E3%83%96%E3%83%A9%E3%82%A6%E3%83%B3/dp/B006WX5P36%3FSubscriptionId%3DAKIAJTLVJPAVA2KR4PJA%26tag%3Dnitoyoncom-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3DB006WX5P36">SONY HDビデオカメラ Handycam HDR-CX590V ボルドーブラウン</a></p>
    <ul>

      <li>出版社/メーカー: ソニー</li>
      <li>発売日: 2012-01-20</li>
      <li>メディア: エレクトロニクス</li>
      <li><a href="http://www.amazon.co.jp/review/product/B006WX5P36%3FSubscriptionId%3DAKIAJTLVJPAVA2KR4PJA%26tag%3Dnitoyoncom-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D5143%26creativeASIN%3DB006WX5P36">Amazon のレビューを見る</a></li>
    </ul>
  </div>
  <div class="hatena-asin-detail-foot"></div>
</div>


<p>デフォルト設定 (AVCHD 1440i、5.1ch) で動画を撮って、Lightroom に取り込んでみたところ、「音声が再生されない」という問題に出会った。Windows Media Player では音がでるので、ファイル自体には問題がなさそうだ。Lightroom は AVCHD に対応しているので、Lightroom でも再生できるはずなのだが・・・。</p>

<h1>問題は 5.1ch の音声にあった</h1>

<p>調べてみると <a href="http://feedback.photoshop.com/photoshop_family/topics/no_sound_audio_when_playing_mts_video">Lightroom: No sound/audio when playing mts video</a> という公式フォーラムの文章が出てきた。Adobe の中の人からの回答がでていて、ざっくり訳すと次のようになる。</p>

<blockquote><p>Lightroom はライセンス上の制限から、ドルビー デジタル オーディオの 2ch 以下にのみ対応している。
そのため、ドルビー デジタル オーディオ 5.1ch のファイルを再生すると音なしになるのは、期待通りの動作である。</p></blockquote>

<p>ためしに 2ch で録音してみると、Lightroom でも再生できた (Lightroom 4.2 で試験)。</p>

<h1>5.1ch の音声をステレオに変換する方法</h1>

<p>Lightroom が 5.1ch のビデオをサポートしてくれれば一番いいのだけど、現時点では、Lightroom で扱いたければステレオ (2ch) で動画を撮ったほうがよいだろう。</p>

<p>既に、5.1ch で撮っちゃったビデオがある場合は、2ch にダウンコンバートするしかない。各 OS ごとに色んなソフトがあるのだろうけど、ここではクロスプラットフォームな ffmpeg でステレオ音声に変換する方法を紹介しておく。</p>

<p>コマンドラインから次のように実行すればよい。</p>

<pre><code>ffmpeg -i input.mts -vcodec copy -acodec ac3 -ac 2 output.mts
</code></pre>

<p>この方法で変換して、Lightroom でも音声つきで再生＆編集できることを確認している。</p>

<p>上のコマンドについて簡単に解説しておく。</p>

<ul>
<li><code>-vcodec copy</code> としているので、動画部分はそのままになる (再エンコードは発生しない)。音声のみの変換なので、短時間で実行は完了する。</li>
<li>元々の音声のコーデックが AC-3 (ドルビーデジタル) ということを前提として <code>-acodec ac3</code> と指定している。</li>
<li><code>-ac 2</code> で出力のチャンネル数が <code>2</code> (ステレオ) になるように指定している。</li>
</ul>


<p>おしまい。</p>

<div class="hatena-asin-detail">
  <a href="http://www.amazon.co.jp/Adobe-Photoshop-Lightroom-Windows-Macintosh%E7%89%88/dp/B007E921HU%3FSubscriptionId%3DAKIAJTLVJPAVA2KR4PJA%26tag%3Dnitoyoncom-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3DB007E921HU"><img src="http://ecx.images-amazon.com/images/I/51QMvYSTH7L._SL160_.jpg" class="hatena-asin-detail-image" alt="Adobe Photoshop Lightroom 4 Windows/Macintosh版 特別提供版" title="Adobe Photoshop Lightroom 4 Windows/Macintosh版 特別提供版"></a>
  <div class="hatena-asin-detail-info">
    <p class="hatena-asin-detail-title"><a href="http://www.amazon.co.jp/Adobe-Photoshop-Lightroom-Windows-Macintosh%E7%89%88/dp/B007E921HU%3FSubscriptionId%3DAKIAJTLVJPAVA2KR4PJA%26tag%3Dnitoyoncom-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3DB007E921HU">Adobe Photoshop Lightroom 4 Windows/Macintosh版 特別提供版</a></p>
    <ul>

      <li>出版社/メーカー: アドビシステムズ</li>
      <li>発売日: 2012-03-16</li>
      <li>メディア: DVD-ROM</li>
      <li><a href="http://www.amazon.co.jp/review/product/B007E921HU%3FSubscriptionId%3DAKIAJTLVJPAVA2KR4PJA%26tag%3Dnitoyoncom-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D5143%26creativeASIN%3DB007E921HU">Amazon のレビューを見る</a></li>
    </ul>
  </div>
  <div class="hatena-asin-detail-foot"></div>
</div>

]]></description>
		</item>

		<item>
			<title>iPhone では &lt;IFRAME&gt; 内のテキストをコピーできない</title>
			<link>http://tech.nitoyon.com/ja/blog/2012/12/06/iphone-iframe/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2012/12/06/iphone-iframe/</guid>
			<pubDate>Thu, 06 Dec 2012 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>いまさらだけど、<a href="/ja/blog/2012/04/20/uncopyable/">絶対にコピペできない文章を作ったったwwww</a> が iPhone 対応できていなかったので調べてみた。</p>

<p>「対応できていない」というのは、iPhone では、長押しして選択したら「コピー」のメニューは出るんだけども、「コピー」を選んでも、クリップボードには入らない、という状態だった。「コピーすると別の文字になる」ことを楽しんでもらうコンテンツなのに、クリップボードに入らないのでは面白さがまったく伝わらない。</p>

<p>ということで、原因を調べようと条件を変えて試してみると、Web フォントは関係なかった。別ドメインの <code>&lt;IFRAME&gt;</code> かどうかも関係なかった。単に「iPhone では <code>&lt;IFRAME&gt;</code> の中身をコピーできない」だけだった (iPhone 3GS で試験)。コピーできるようにする方法があるのかもしれないけど、いろいろと検索しても見つからなかった。</p>

<p>実験用に従来の <code>&lt;IFRAME&gt;</code> 版の「コピペできない文章」を貼り付けておくので、iPhone の人は実験してみてほしい。</p>

<iframe src="/misc/js/uncopyable/" width="100%" height="500"></iframe>


<p>本家の <a href="/ja/blog/2012/04/20/uncopyable/">絶対にコピペできない文章を作ったったwwww</a> のほうは、<code>&lt;IFRAME&gt;</code> を使わない形に修正したので、現在は iPhone でも楽しめるようになったはずである。</p>

<p>そもそも、<code>&lt;IFRAME&gt;</code> を使っていたのは、はてなダイアリーだと、スマホでアクセスすると CSS が適用されない touch 版に飛ばされるからで、これを回避するために Google ガジェットで逃げていたのが原因だった。<code>&lt;IFRAME&gt;</code> でも Android では楽しめていたので、一定の成果はあったと思う。</p>
]]></description>
		</item>

		<item>
			<title>「いいね！」ボタンは XFBML 版を設置して Facebook に最適化すべき</title>
			<link>http://tech.nitoyon.com/ja/blog/2012/11/28/xfbml-like/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2012/11/28/xfbml-like/</guid>
			<pubDate>Wed, 28 Nov 2012 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>Facebook の「いいね！」ボタンはどれも同じ見た目に見えますが、実は XFBML 版と IFRAME 版の２種類があります。</p>

<p>IFRAME 版のほうが設置が簡単なので、IFRAME 版を使っているサイトも多いようですが、実は、XFBML 版にしたほうが Facebook で話題が拡散しやすくなるのでオススメです。</p>

<h1>XFBML 版と IFRAME 版の違い</h1>

<p>拡散しやすくなる理由はどこにあるのでしょうか。</p>

<p>XFBML 版と IFRAME 版、どちらも見た目は一緒です。違いは<strong>ボタンを押したときの挙動</strong>にあります。</p>

<h2>IFRAME 版の「いいね!」ボタンを押してみる</h2>

<p>押した状態になって終わりです。</p>

<center><img src="http://farm9.staticflickr.com/8062/8221298498_d8a512177f_o.png" width="512" height="108"></center>


<p>「いいね！」を押した時点では、自分のタイムラインはこうなっています。</p>

<center><img src="http://farm9.staticflickr.com/8343/8220217893_6cc999af73.jpg" width="500" height="233"></center>


<p>右側の最近のアクティビティが増えています。もうちょっと下にある「いいね！」一覧も増えますが、あまり目立ってません。</p>

<h2>XFBML 版の「いいね!」ボタンを押してみる</h2>

<p>押した状態になるところまでは同じだけど、<strong>コメント入力用のポップアップ</strong>が出てきます。</p>

<center><img src="http://farm9.staticflickr.com/8490/8220218239_9dac837d8b_o.png" width="500" height="268"></center>


<p>コメントを入力して投稿してみると、タイムラインはこうなります。</p>

<center><img src="http://farm9.staticflickr.com/8341/8220217817_3e24175903.jpg" width="500" height="323"></center>


<p>通常の投稿としてタイムラインに表示されましたね。</p>

<p>単に「いいね！」したときに比べて、目立つようになりました。</p>

<h2>じゃ、ニュースフィードはどうなる？</h2>

<p>自分のタイムラインは分かったので、友達のニュースフィードではどうでしょうか。</p>

<p>Facebook の<a href="https://developers.facebook.com/docs/reference/plugins/like/">開発者向けドキュメント</a>には</p>

<blockquote><p>If users do add a comment, the story published back to Facebook is given more prominence.</p>

<blockquote><p>もしユーザーがコメントしたら、コメント内容は Facebook に反映されて、さらに目立つようになります。</p></blockquote></blockquote>

<p>と書いてあります (日本訳は私によるもの)。</p>

<p>コメントがついていれば、コメントつきで友人のニュースフィードに表示されるので、友人の興味を引きやすくなります。</p>

<p>ただ、効果はそれだけではありません。「いいね！」したページがニュースフィードに表示される条件は、経験的に</p>

<ul>
<li>「いいね！」した人の人数</li>
<li>「いいね！」した人の仲のよさ</li>
<li>コメントの有無</li>
</ul>


<p>が関係しているように思います。</p>

<p>たとえば、仲のよい人が「いいね！」するとニュースフィードに表示されるけど、疎遠気味な人が「いいね！」しても表示されません。ただ、疎遠気味な人でも２人が同時に「いいね！」すると表示される、といった具合です。</p>

<p>この経験則が正しいとすれれば、コメントつきで「いいね！」したときには、より多くの友達のニュースフィードに表示されることになります。</p>

<h2>XFBML 版のほうがうれしい理由をまとめる</h2>

<p>サイト運営者は、「いいね！」したときにコメント入力してもらえれば、より多く友人に伝わるので、自分のサイトへの流入数が増えてハッピー。</p>

<p>Facebook ユーザーの立場からも、コメントを入力して面白さを友達に伝えられるし、より多くの友達に伝わってハッピー。コメントを入力したくないなら閉じればよいだけ。</p>

<p>XFBML 版なら、みんなハッピー！</p>

<h1>XFBML 版にするにはどうするのよ？</h1>

<p>XFBML 版にしたくなりました？　その前に、自分のサイトで使ってるのが XFBML 版なのか IFRAME 版なのかを確認しなきゃいけません。</p>

<p>「いいね！」ボタンを押してみれば分かるのですが、押さずに確認したいケースもあるかもしれません。</p>

<h2>ボタンを押さずに XFBML 版かどうか確認する方法</h2>

<p>HTML のソースを見ましょう。</p>

<p>「いいね！」ボタンの位置のソースが</p>

<ul>
<li>IFRAME 版 → <code>&lt;iframe&gt;</code> タグ</li>
<li>XFBML 版 → <code>&lt;div class="fb-like"&gt;</code> か <code>&lt;fb:like&gt;</code></li>
</ul>


<p>となっています。</p>

<p>たとえば、はてなダイアリーのソースを見てみると…</p>

<center><img src="http://farm9.staticflickr.com/8197/8221298276_f6975f6316_o.png" width="558" height="191"></center>


<p>はい、IFRAME 版ですね。</p>

<h2>XFBML 版を埋め込む手順</h2>

<p>自分が使ってるのが IFRAME 版だと判明したなら、XFBML 版に置き換えてみましょう。</p>

<p>WordPress などは XFBML 版での埋め込みに対応しているプラグインも多いようなので、ここでは、独自に埋め込みする方法を書いておきます。</p>

<p>独自に埋め込む場合は、<a href="https://developers.facebook.com/docs/reference/plugins/like/">開発者向けドキュメント</a> の [Step1 - Get Like Button Code] から埋め込みコードを取得します。</p>

<ol>
<li>[URL to like] に URL を入力する。</li>
<li>[Send Button] のチェックを外す。</li>
<li>[Layout style] を [button_count] か [box_count] に設定する。</li>
<li>[Get Code] をクリックする。</li>
</ol>


<p>これで設置するためのコードが表示されます。</p>

<center><img src="http://farm9.staticflickr.com/8490/8224358818_e5c1111096.jpg" width="500" height="366"></center>


<p>コードには「HTML5」「XFBML」「IFRAME」「URL」の４種類がありますが、「HTML5」「XFBML」が XFBML 版です (ややこしいですね…)。</p>

<p>「XFBML」は <code>&lt;html&gt;</code> タグに名前空間を追加しなきゃいけないのが少し面倒なので、それが嫌なら「HTML5」を使うといいんじゃないでしょうか。</p>

<p>「HTML5」と「XFBML」のどちらも JavaScript の埋め込みが必要です。非同期な埋め込みコードになってるので、Facebook のサーバーの応答が遅かったとしても、自サイトのレンダリングを阻害する心配はありません。</p>

<h1>まとめ</h1>

<p>XFBML 版の「いいね！」ボタンを設置したほうがお得かもしれないよ、という話をしました。</p>

<p>Facebook つながりで宣伝。このブログの Facebook ページを作りました。更新情報などを Facebook で配信していくので、興味がある人はぜひ「いいね！」してください。</p>

<div class="fb-like-box" data-href="http://www.facebook.com/TechNiBlogJa" data-width="310" data-show-faces="true" data-stream="false" data-header="true"></div>


<h2>補足</h2>

<p>本文中では触れませんでしたが、IFRAME 版でもポップアップを表示するケースはあります。スタンダード スタイル (「いいね！」した人のアイコンを表示する大きいモード) のときです。ただ、個別の記事に対して大きい「いいね！」ボタンを設置しているケースはほとんど見たことないので、本文中での説明は省略しました。</p>

<p>また、XFBML 版でも、親タグで <code>overflow: hidden</code> にしてると、コメントのポップアップは表示されません。このブログでは、<code>float</code> でソーシャルボタンを横に並べて、Compass の <code>clearfix</code> ミックスインで <code>float</code> 解除していたのですが、この、<code>clearfix</code> ミックスインには <code>overflow: hidden</code> が含まれていたので、しばらく悩まされました。結局、<code>pie-clearfix</code> ミックスインを使って回避しました。皆様もお気をつけください。</p>
]]></description>
		</item>

		<item>
			<title>Flickr の Set 内の写真一覧を更新する Ruby スクリプトを作った</title>
			<link>http://tech.nitoyon.com/ja/blog/2012/11/06/flickr-auto-update/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2012/11/06/flickr-auto-update/</guid>
			<pubDate>Tue, 06 Nov 2012 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>身内向けの写真ブログを Flickr を使ってやってます。</p>

<p>非公開で写真をアップロードして、Set の Guest Pass 機能と組み合わせて、URL を知ってる人だけが Set の写真を見られる、という形で運営してます。</p>

<p>さて、Set に写真を追加していけば更新できるわけですが、毎回 Flickr を開いて作業するのが面倒になってきました。Set 内の写真が増えてくると、UI がもっさりしてくるのも嫌でした。</p>

<p>となれば、Flickr の API を使って、スクリプトで自動処理したくなるのがプログラマ心情でございます。</p>

<h1>さっそく作った</h1>

<p>ということで、Flickr の API とにらめっこしながら作ってみました。</p>

<div class="highlight"><pre><code class="ruby">require &#39;flickraw&#39;
require &#39;date&#39;
require &#39;set&#39;

# load conf and set API key and access token
# (ex)
# { &quot;api_key&quot;: &quot;xxxxxxx&quot;,
#  &quot;shared_secret&quot;: &quot;xxxxx&quot;,
#  &quot;access_token&quot;: &quot;xxxxxxx&quot;,
#  &quot;access_secret&quot;: &quot;xxxxxx&quot;
# }
conf = nil
open(&#39;flickr.conf&#39;) { |f|
  conf = JSON.load(f)
}

FlickRaw.api_key = conf[&#39;api_key&#39;]
FlickRaw.shared_secret = conf[&#39;shared_secret&#39;]
flickr.access_token = conf[&#39;access_token&#39;]
flickr.access_secret = conf[&#39;access_secret&#39;]


def get_set_id_by_name(set_name)
  res = flickr.photosets.getList
  for set in res
    if set.title == set_name
      return set.id
    end
  end
  nil
end

def get_photos_in_a_set(photoset_id)
  page = 1
  pages = 1
  photo_ids = []
  while page &lt;= pages
    res = flickr.photosets.getPhotos :photoset_id =&gt; photoset_id.to_s,
                                     :page =&gt; page.to_s
    photo_ids.concat res.photo.map { |photo| photo.id }

    page = res.page.to_i + 1
    pages = res.pages.to_i
  end
  { :id =&gt; res.id,
    :primary =&gt; res.primary, 
    :photo =&gt; photo_ids }
end

def log(str)
  puts &quot;#{Time.now} #{str}&quot;
end


def main(cur_set_id)
  # get set &#39;YYYY-MM-DD&#39;
  new_set_name = Date::today.to_s
  new_set_id = get_set_id_by_name(new_set_name)
  if new_set_id.nil?
    log(&quot;set #{new_set_name} not found&quot;)
    exit
  end
  log(&quot;set #{new_set_name} found: #{new_set_id}&quot;)

  # Get set information
  cur_set = get_photos_in_a_set(cur_set_id)
  new_set = get_photos_in_a_set(new_set_id)
  log(&quot;current set has #{cur_set[:photo].length} photos&quot;)
  if new_set[:photo].length == 0
    log(&quot;no photo&quot;)
    exit
  end
  log(&quot;add #{new_set[:photo].length} photo(s) to it&quot;)

  # Create new photo_ids
  cur_photos_set = Set.new(cur_set[:photo])
  photos = cur_set[:photo].dup
  log(&quot;current photos: #{photos.join(&#39;,&#39;)}&quot;)
  modified = false
  for photo in new_set[:photo]
    if cur_photos_set.include? photo
      log(&quot;skip photo #{photo}&quot;)
    else
      log(&quot;add photo #{photo}&quot;)
      photos.unshift(photo) 
      modified = true
    end
  end
  log(&quot;new photos: #{photos.join(&#39;,&#39;)}&quot;)

  if modified
    log(&quot;editPhotos start&quot;)
    res = flickr.photosets.editPhotos :photoset_id =&gt; cur_set[:id],
                                      :primary_photo_id =&gt; cur_set[:primary],
                                      :photo_ids =&gt; photos.join(&quot;,&quot;)
    log(&quot;editPhotos finished&quot;)
  else
    log(&quot;editPhots skipped&quot;)
  end

  # delete set
  log(&quot;delete photoset start&quot;)
  flickr.photosets.delete :photoset_id =&gt; new_set_id
  log(&quot;delete photoset finished&quot;)
end


if ARGV.length &lt; 1
  log(&quot;set_id not specified&quot;)
  log(&quot;ruby flickr_update.rb [set_id]&quot;)
  exit
end

begin
  main(ARGV[0])
rescue SystemExit
rescue Exception =&gt; e
  log(&quot;exception #{e.inspect}\n#{e.backtrace.join(&quot;\n&quot;)}&quot;)
end
</code></pre>
</div>


<h2>使い方</h2>

<p>あらかじめ、写真をプライベートでアップロードしておきます。</p>

<p>たとえば、2012年11月06日に公開したい写真は、<code>2012-11-06</code> という Set に入れておきます。</p>

<p>その状態で、シェルから</p>

<div class="highlight"><pre><code class="bash">$ ruby update_flickr.rb [set_id]
</code></pre>
</div>


<p>のように実行してやると、<code>2012-11-06</code> というセット内の写真を列挙して、コマンドライン引数で指定した <code>[set_id]</code> のセットの先頭に追加してくれます。作業が完了すれば <code>2012-11-06</code> というセットは消えます。</p>

<p>あとは、この処理を cron に突っ込んで、一日一回実行するようにしておけば自動化完了です。めでたし。</p>

<h2>ライブラリは FlickRaw を利用</h2>

<p>Flickr API を叩くためのライブラリは、<a href="https://github.com/hanklords/flickraw/">FlickRaw</a> を使ってます。</p>

<p><code>access_token</code> と <code>access_secret</code> は公式のドキュメントに書いてある通りにやれば取得できました。</p>

<p>そのあとは、Flickr の API のドキュメントを眺めながら書くだけでした。<a href="http://www.flickr.com/services/api/explore/flickr.photos.getRecent">Flickr Api Explorer</a> を使えば、ブラウザー上で API の動作試験ができるのが楽でした。</p>

<h1>Flickr への公開は Lightroom で</h1>

<p>ちなみに、写真の現像から Flickr での公開までは、Lightroom を使ってます。</p>

<p>Lightroom にデフォルトでついてくる Flickr の公開サービス機能を使えば、Lightroom の上で Flickr にアップロードが完了します。</p>

<p>Lightroom の Tips としては、Flickr を [対象コレクション] に指定しておけば、[B] キーでアップロードするかどうかを選択できて楽です。</p>

<div class="hatena-asin-detail">
  <a href="http://www.amazon.co.jp/Adobe-Photoshop-Lightroom-Windows-Macintosh%E7%89%88/dp/B007E921HU%3FSubscriptionId%3DAKIAJTLVJPAVA2KR4PJA%26tag%3Dnitoyoncom-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3DB007E921HU"><img src="http://ecx.images-amazon.com/images/I/51QMvYSTH7L._SL160_.jpg" class="hatena-asin-detail-image" alt="Adobe Photoshop Lightroom 4 Windows/Macintosh版 特別提供版" title="Adobe Photoshop Lightroom 4 Windows/Macintosh版 特別提供版"></a>
  <div class="hatena-asin-detail-info">
    <p class="hatena-asin-detail-title"><a href="http://www.amazon.co.jp/Adobe-Photoshop-Lightroom-Windows-Macintosh%E7%89%88/dp/B007E921HU%3FSubscriptionId%3DAKIAJTLVJPAVA2KR4PJA%26tag%3Dnitoyoncom-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3DB007E921HU">Adobe Photoshop Lightroom 4 Windows/Macintosh版 特別提供版</a></p>
    <ul>

      <li>出版社/メーカー: アドビシステムズ</li>
      <li>発売日: 2012-03-16</li>
      <li>メディア: DVD-ROM</li>
      <li><a href="http://www.amazon.co.jp/review/product/B007E921HU%3FSubscriptionId%3DAKIAJTLVJPAVA2KR4PJA%26tag%3Dnitoyoncom-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D5143%26creativeASIN%3DB007E921HU">Amazon のレビューを見る</a></li>
    </ul>
  </div>
  <div class="hatena-asin-detail-foot"></div>
</div>


<h1>まとめ</h1>

<p>自動化万歳、API を公開してるサービス万歳。</p>
]]></description>
		</item>

		<item>
			<title>Ruby の Liquid でテンプレートに値を渡すパターン４つ</title>
			<link>http://tech.nitoyon.com/ja/blog/2012/10/29/liquid-drop/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2012/10/29/liquid-drop/</guid>
			<pubDate>Mon, 29 Oct 2012 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>今日は Ruby のテンプレート エンジン Liquid において、コードとテンプレートの間でデータをやり取りする方法についてまとめておく。</p>

<p>Liquid のバージョンは 2.3.0 で確認しているが、執筆時点で最新の 2.4.1 でも変わってないようにみえる。</p>

<h1>Hash を渡すパターン</h1>

<p>まずは、Liquid のサイトにも載ってる一番単純なハッシュを渡すパターン。</p>

<div class="highlight"><pre><code class="ruby">require &#39;liquid&#39;

template = Liquid::Template.parse(&quot;hi {{name}}&quot;)
puts template.render( &#39;name&#39; =&gt; &#39;nitoyon&#39; ) # =&gt; hi nitoyon
</code></pre>
</div>


<p>分かりやすい。そのまま。</p>

<h1>to_liquid を実装するパターン</h1>

<p>自分で作ったクラスのインスタンスを Liquid に渡したい場合もあるだろう。この場合、<code>to_liquid</code> メソッドを実装してやる必要がある。</p>

<div class="highlight"><pre><code class="ruby">require &#39;liquid&#39;

class Person
  def initialize
    @name = &quot;nitoyon&quot;
  end

  def to_liquid
    { &#39;name&#39; =&gt; @name }
  end
end

template = Liquid::Template.parse(&quot;hi {{person.name}}&quot;)
puts template.render( &#39;person&#39; =&gt; Person.new ) # =&gt; hi nitoyon
</code></pre>
</div>


<p>Liquid の処理としては、オブジェクトを参照するときには、あらかじめ <code>to_liquid</code> メソッドを呼ぶ仕組みになっているようだ。実際に、Liquid を <code>require</code> すると、裏側では <code>liquid/extensions.rb</code> によって <code>String#to_liquid</code> などのメソッドが定義されている。</p>

<p>もし、<code>to_liquid</code> を定義していないと、</p>

<pre><code>hi Liquid error: undefined method `to_liquid' for 
#&lt;Person:0x46a400 @name="nitoyon"&gt;
</code></pre>

<p>のようなエラーになってしまう。</p>

<p><code>to_liquid</code> を独自実装するパターンを使うと、テンプレート側から <code>Person</code> のメソッドを呼ぶことはできない。それをやりたいなら、次に説明する <code>Liquid::Drop</code> を使うとよい。</p>

<h1>Drop を使うパターン</h1>

<p><code>Liquid::Drop</code> を継承してやることで、テンプレート側からメソッドを呼べるようになる。</p>

<div class="highlight"><pre><code class="ruby">class Person &lt; Liquid::Drop
  attr_accessor :name
  def initialize
    @name = &quot;nitoyon&quot;
  end
  def NAME
    @name.upcase
  end
end

template = Liquid::Template.parse(&quot;hi {{person.name}}&quot;)
puts template.render({&#39;person&#39; =&gt; Person.new })  # =&gt; hi nitoyon

template = Liquid::Template.parse(&quot;hi {{person.NAME}}&quot;)
puts template.render({&#39;person&#39; =&gt; Person.new })  # =&gt; hi NITOYON
</code></pre>
</div>


<p>これはとても便利だが、いくつか注意すべき点がある。</p>

<p>まず、引数付きのメソッドを呼ぶことはできない。引数に対処したかったら、テンプレートから <code>name_param1_param2</code> のようにして参照しておいて、後述の <code>before_method</code> でがんばってパースしろ、というポリシーのようだ。</p>

<p>もう１つ。別ライブラリが提供するオブジェクトを Liquid に渡したいことがある。このとき、<code>Liquid::Drop</code> を継承させるのは不可能だ。かといって、<code>to_liquid</code> で内部構造をいちいちハッシュに変換するのも面倒だ。</p>

<p>そんなケースに対処するために Drop 化させるクラス <code>ToDrop</code> を作ってみたので、次のパターンとして紹介する。</p>

<h1>Drop 化させるパターン</h1>

<p>gem かなんかで、こんなクラスが提供されているものと仮定する。</p>

<div class="highlight"><pre><code class="ruby">module Foo
  class Person
    attr_accessor :name
    def initialize
      @name = &quot;nitoyon&quot;
    end
    def NAME
      @name.upcase
    end
  end
end
</code></pre>
</div>


<p>外部ライブラリーのクラスなのでいじりたくないけど、このクラスのインスタンスをテンプレートに渡して、 <code>name</code> や <code>NAME</code> メソッドを叩きたいものとする。</p>

<p>そういうときは、次のような <code>ToDrop</code> クラスを定義しておけばよい。</p>

<div class="highlight"><pre><code class="ruby">class ToDrop &lt; Liquid::Drop
  def initialize(obj)
    @obj = obj
  end
  def before_method(method)
    if method &amp;&amp; method != &#39;&#39; &amp;&amp; @obj.class.public_method_defined?(method.to_s.to_sym)
      @obj.send(method.to_s.to_sym)
    end
  end
end
</code></pre>
</div>


<p>使い方は簡単。<code>to_liquid</code> で <code>ToDrop.new(self)</code> を返す処理を実装してやるだけだ。これだけで期待の動作となっている。</p>

<div class="highlight"><pre><code class="ruby">module Foo
  class Person
    def to_liquid
      ToDrop.new(self)
    end
  end
end

template = Liquid::Template.parse(&quot;hi {{person.name}}&quot;)
puts template.render({&#39;person&#39; =&gt; Foo::Person.new }) # =&gt; hi nitoyon

template = Liquid::Template.parse(&quot;hi {{person.NAME}}&quot;)
puts template.render({&#39;person&#39; =&gt; Foo::Person.new }) # =&gt; hi NITOYON
</code></pre>
</div>


<p>この <code>ToDrop</code> が今回、わたしが作成した魔法のクラスで、任意のオブジェクトを <code>Liquid::Drop</code> を継承したときと同じ動作にしてくれる。</p>

<p><code>ToLiquid</code> クラスでは <code>Liquid::Drop#before_method</code> メソッドを実装している。このメソッドは <code>Drop</code> のメソッドミッシングのような役割を担っている。<code>ToDrop#before_method</code> では、ラップ対象のオブジェクトに public メソッドがあるかどうか調べて、あるならばそれを呼ぶよう実装している。</p>

<p>言葉で説明しても分かりにくいのだけど、<code>Liquid::Drop</code> クラスのソース <a href="https://github.com/Shopify/liquid/blob/master/lib/liquid/drop.rb">drop.rb</a> と見比べてもらうとイメージは沸きやすいと思う。<code>Liquid::Drop</code> のソースをよく見ると Liquid と密接に関わっているわけではなく、<code>alias :[] :invoke_drop</code> とすることで、<code>[]</code> を使った参照をメソッド呼び出しに置き換えているだけ、というヘルパークラスなのが興味深い。</p>

<h1>まとめ</h1>

<p>Liquid に値を渡すためのパターンを 4 つ紹介した。<code>Liquid::Drop</code> を継承すればテンプレート側からメソッドを呼べるし、継承関係に手が出しにくいときには拙作の <code>ToDrop</code> クラスを使えば便利だよ、という話をした。</p>
]]></description>
		</item>

	</channel>
</rss>
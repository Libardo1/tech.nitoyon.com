<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>てっく煮ブログ</title>
		<link>http://tech.nitoyon.com/ja/blog/index.xml</link>
		<description>All Technology is Boiled in This Site.</description>
		<language>ja</language>
		<copyright>Copyright nitoyon.</copyright>
		<lastBuildDate>Tue, 09 Jul 2013 01:42:40 +0000</lastBuildDate>
		<docs>http://blogs.law.harvard.edu/tech/rss</docs>
		<atom:link href="http://tech.nitoyon.com/ja/blog/index.xml" rel="self" type="application/rss+xml" />









		<item>
			<title>Windows でも git difftool --dir-diff でシンボリックリンクを使う方法</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/07/09/symlink-dir-diff-on-windows/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/07/09/symlink-dir-diff-on-windows/</guid>
			<pubDate>Tue, 09 Jul 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p><code>git difftool --dir-diff</code> が便利だよ、という話を <a href="/ja/blog/2013/07/02/git-dir-diff/">git difftool --dir-diff が便利すぎて泣きそうです</a> で書きましたが、１つ宿題が残っていました。Windows では一時ファイルがワーキング ディレクトリーへのシンボリックリンクにならないので、Unix や Mac に比べて、少しだけ不便だよ、という話です。</p>

<p>そこで、Windows でもシンボリックリンクを使えるようにしちゃおう、というのがこのエントリーの趣旨でございます。</p>

<h1>Windows 向けの応急処置パッチ</h1>

<p>Git for Windows 1.8.3 で動作確認しています。OS は Windows 7 (64 ビット)。</p>

<p><code>C:\Program Files (x86)\Git\libexec\git-core\git-difftool</code> のパッチがこちら。</p>
<div class="highlight"><pre><code class="diff language-diff" data-lang="diff">--- git-difftool    Sun Jun  2 11:28:06 2013
+++ git-difftool    Tue Jul  9 00:42:02 2013
@@ -283,7 +283,7 @@
            exit_cleanup($tmpdir, 1);
        }
        if ($symlinks) {
-           symlink(&quot;$workdir/$file&quot;, &quot;$rdir/$file&quot;) or
+           !system(&quot;git&quot;, &quot;mklink&quot;, &quot;$workdir/$file&quot;, &quot;$rdir/$file&quot;) or
            exit_cleanup($tmpdir, 1);
        } else {
            copy(&quot;$workdir/$file&quot;, &quot;$rdir/$file&quot;) or
@@ -448,7 +448,7 @@
    my $indices_loaded = 0;

    for my $file (@worktree) {
-       next if $symlinks &amp;&amp; -l &quot;$b/$file&quot;;
+       next if $symlinks;
        next if ! -f &quot;$b/$file&quot;;

        if (!$indices_loaded) {
</code></pre></div>
<p>適当な場所に保存して、GitBash を管理者権限で起動して適用してやります。</p>
<div class="highlight"><pre><code class="console language-console" data-lang="console">$ cd /c/Program\ Files\ \(x86\)/Git/libexec/git-core/
$ patch &lt; ~/git-difftool.patch
patching file `git-difftool&#39;
</code></pre></div>
<p>さらに、<code>C:\Program Files (x86)\Git\libexec\git-core\git-mklink</code> を作ります。</p>
<div class="highlight"><pre><code class="sh language-sh" data-lang="sh">#!/bin/sh

cmd.exe /c &quot;mklink \&quot;$2\&quot; \&quot;$1\&quot;&quot; &gt; /dev/null
</code></pre></div>
<p>(このスクリプトは <code>/tmp/</code> といった msys 内のパスを Windows のパスに変換するために必要)</p>

<h1>使い方</h1>

<p>最初に、<code>.gitconfig</code> に difftool の設定をしておきます。<a href="http://winmerge.org/">WinMerge</a> を利用するには次のようにしておきます。</p>
<div class="highlight"><pre><code class="ini language-ini" data-lang="ini">[diff]
    tool = winmerge
[difftool winmerge]
    path = C:/Program Files (x86)/WinMerge/winmergeu.exe
    cmd = \&quot;C:/Program Files (x86)/WinMerge/winmergeu.exe\&quot; -r -u \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot;
</code></pre></div>
<p>GitBash を管理者権限で起動して、次のように実行します (Windows ではシンボリックリンクを作成するには管理者権限が必要)。</p>
<div class="highlight"><pre><code class="console language-console" data-lang="console">$ git difftool -d --symlinks [&lt;commit&gt; [&lt;commit&gt;]]
</code></pre></div>
<p>ついでに <code>.gitconfig</code> にエイリアスを定義しておくと便利でしょう。</p>
<div class="highlight"><pre><code class="ini language-ini" data-lang="ini">[alias]
    d = difftool -d --symlinks
</code></pre></div>
<p>どうぞご利用ください。</p>
]]></description>
		</item>

		<item>
			<title>git difftool --dir-diff が便利すぎて泣きそうです</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/07/02/git-dir-diff/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/07/02/git-dir-diff/</guid>
			<pubDate>Tue, 02 Jul 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p><center><img src="http://farm3.staticflickr.com/2869/9194395890_e02e5eae04_o.jpg" width="550" height="244"></center></p>

<p>Git の 1.7.11 から <code>git difftool</code> コマンドに <code>--dir-diff</code> というオプションが追加されたのですが、これがライフ チェンジングだと思ったので紹介します。</p>

<p><code>--dir-diff</code> 登場以前の <code>git difftool</code> は「ファイルごとに順番に差分を表示していく」ことしかできず、使い勝手はいまいちでした。それが、<code>--dir-diff</code> オプションの登場で状況が一変したわけです。</p>

<h1>こんな感じの使い心地だよ</h1>

<p>ある Git レポジトリーで <code>dir1/a.txt</code> と <code>dir2/c.txt</code> を編集したとしましょう。</p>

<p>この状態で <code>git difftool --dir-diff</code> または <code>git difftool -d</code>  を実行してみると・・・。</p>

<p><center><img src="http://farm6.staticflickr.com/5339/9190948901_e8af0e9b5d.jpg" width="500" height="366"></center></p>

<p>はい、差分のあるファイルが一覧で表示されました。</p>

<p>(difftool に WinMerge を設定して、メニューから [ツリー表示] を有効にしたときの表示例です。設定方法は後述します)</p>

<h2>個別のファイルの diff を見る</h2>

<p><code>a.txt</code> を選択すると、新しいタブが開いて、<code>a.txt</code> の差分が表示されます。</p>

<p><center><img src="http://farm6.staticflickr.com/5477/9193747196_ebd8033182.jpg" width="500" height="366"></center></p>

<p>カラフルに色分けされているし、ショートカットキーで前後の差分に移動できるので便利です (WinMerge の場合は Alt + ↑ と Alt + ↓)。</p>

<p>当然、タブを移動して差分一覧に戻れば、<code>c.txt</code> の差分も表示できます。</p>

<p>コマンドラインの <code>git diff</code> に比べて、</p>

<ul>
<li>確認するファイルを選びやすい</li>
<li>差分間の移動がキーボードでやりやすい</li>
<li>ファイル全体が表示されているので、差分から前後に好きなだけたどっていける</li>
</ul>

<p>といったところが嬉しいですね。</p>

<p>おっと、ここまでなら、GUI な Git クライアントでも同じようなことはできますね。便利なのはこの次です。</p>

<h2>ファイル編集も！</h2>

<p>なんと、右側のファイルを編集して保存すると、<strong>ワーキング ディレクトリーに反映される</strong>のです (ただし、右側のファイルがワーキング ディレクトリーのファイルと同じ内容のときのみ)。</p>

<p>これがとてつもなく便利です。</p>

<p>差分を見ながら、「この差分は不要」とか「typo 発見」とか気づいたときに、その場で修正ができちゃうわけです。</p>

<h2>比較対象は無限大</h2>

<p><code>git difftool</code> で比較対象を指定する方法は <code>git diff</code> とまったく同じです。</p>

<p>たとえば、<code>git difftool -d master...topic</code> として、トピックブランチでの変更点をまとめて閲覧したりもできるわけです。<code>git difftool -d --cached</code> としてインデックスとの差分を確認できるわけです。任意のコミット間の差分も確認できるわけです。タグがうってあれば、特定のバージョン間の差分も確認できるわけです</p>

<p>うれしいですね。</p>

<h1>裏側で起こっていること</h1>

<p><code>git difftool -d</code> を実行したときに、裏側で何が起こっているのでしょうか。</p>

<p>内部的に <code>git diff</code> を呼び出して、出てきたファイルを一時ディレクトリーにチェックアウトしています。</p>

<p>たとえば、先ほどの例でいうと</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">Temp/git-difftool.VoxJJ/
    left/
        dir1/
            a.txt
        dir2/
            c.txt
    right/
        dir1/
            a.txt
        dir2/
            c.txt
</code></pre></div>
<p>といった構造になります。中身が同一なファイルはチェックアウトされないので、大きなレポジトリーでも安心です。</p>

<p>さらに、Mac や Linux では、<code>right</code> のファイルがワーキング ディレクトリーと同じなら、「ワーキング ディレクトリーへのシンボリックリンク」になっています。その結果、<code>right</code> のファイルを書き換えると、即時にワーキング ディレクトリーに反映されるわけです。</p>

<p>Windows の場合は、difftool を終了したときに、ワーキング ディレクトリーに一時ファイルを書き戻す動作になっています。ちょっと不便なので、シンボリックリンクを使うように改造したいところです。(追記) 改造しました!! <a href="/ja/blog/2013/07/09/symlink-dir-diff-on-windows/">Windows でも git difftool --dir-diff でシンボリックリンクを使う方法</a></p>

<h1>使えるようにするまでの準備</h1>

<p>便利なのは分かってもらえたと思うので、使えるように準備してみましょう！</p>

<h2>最新の git-difftool を取得しておく</h2>

<p>先ほど書いた通り、<code>git difftool --dir-diff</code> は 1.7.11 から追加されています。ただ、最近になっていくつか大きなバグが修正されているので、なるべく新しいヤツ (Linux なら 1.8.3、Windows なら 1.8.3.2 ) を利用するのがオススメです。</p>

<p>Git 全体を更新するのが面倒な場合は、git-difftool だけを</p>

<ul>
<li><a href="https://github.com/git/git/blob/master/git-difftool.perl">GitHub (git/git-difftool.perl at master)</a></li>
</ul>

<p>から落としてきて、<code>libexec/git-core/git-difftool</code> に上書きすれば、よほど古いバージョンじゃなければ動く・・・と思います。</p>

<h2>difftool の設定: WinMerge 篇</h2>

<p>Windows で WinMerge を使う場合は、<code>.gitconfig</code> に次のように書きます (Git for Windows の場合)。</p>
<div class="highlight"><pre><code class="ini language-ini" data-lang="ini">[diff]
    tool = winmerge
[difftool winmerge]
    path = C:/Program Files (x86)/WinMerge/winmergeu.exe
    cmd = \&quot;C:/Program Files (x86)/WinMerge/winmergeu.exe\&quot; -r -u \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot;
</code></pre></div>
<p>インストール先が異なる場合は適宜修正してください。</p>

<p>コマンドライン オプションの意味は次の通りです。</p>

<ul>
<li><code>-r</code>: 再帰的に比較する</li>
<li><code>-u</code>: 最近開いた一覧に追加しない</li>
</ul>

<p>人によっては <code>-e</code> を追加して ESC で WinMerge を閉じられるようにしているようですが、複数タブを開いてるときに ESC を押して WinMerge が閉じてしまうと困るので私は設定していません。</p>

<h2>difftool の設定: meld 篇</h2>

<p>Mac や Linux で meld を利用する場合は、<code>.gitconfig</code> に次のように書きます。</p>
<div class="highlight"><pre><code class="ini language-ini" data-lang="ini">[diff]
    tool = meld
</code></pre></div>
<p>簡単ですね。</p>

<p>Git 本体に meld のコマンドラインオプションの情報が入ってるので、これで動くようです。</p>

<p>(手元に Mac がないので動作確認はできませんでしたが、<a href="http://stackoverflow.com/questions/2006032/view-differences-of-branches-with-meld#answer-12815806">git - View differences of branches with meld? - Stack Overflow</a> に同じ手順が書いてあって、プラス評価がついてるので正しいはずです)</p>

<p>Pro Git には <a href="http://git-scm.com/book/ja/Git-%E3%81%AE%E3%82%AB%E3%82%B9%E3%82%BF%E3%83%9E%E3%82%A4%E3%82%BA-Git-%E3%81%AE%E8%A8%AD%E5%AE%9A#%E5%A4%96%E9%83%A8%E3%81%AE%E3%83%9E%E3%83%BC%E3%82%B8%E3%83%84%E3%83%BC%E3%83%AB%E3%81%8A%E3%82%88%E3%81%B3-Diff-%E3%83%84%E3%83%BC%E3%83%AB">P4Merge を使う手順</a> が書いてあるんだけど、P4Merge はディレクトリーの比較に対応してないので、<code>--dir-diff</code> には活用できません。</p>

<h2>エイリアスを設定する</h2>

<p>このあたりは好みですが、<code>.gitconfig</code> でエイリアスを設定しておくと便利でしょう。</p>
<div class="highlight"><pre><code class="ini language-ini" data-lang="ini">[alias]
    d = difftool -d
    dc = difftool -d --cached
    dp = difftool -d HEAD~
</code></pre></div>
<p><code>git d &lt;branch&gt;</code> とか <code>git d HEAD</code> のように入力するだけで、difftool が <code>--dir-diff</code> で立ち上がるようになります。</p>

<h1>まとめ</h1>

<p><code>difftool --dir-diff</code> で快適な Git 生活を！</p>
]]></description>
		</item>

		<item>
			<title>Node.js 0.12 では yield が使えるのでコールバック地獄にサヨナラできる話</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/06/27/node-yield/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/06/27/node-yield/</guid>
			<pubDate>Thu, 27 Jun 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>Node.js の次のメジャーバージョン 0.12 で <code>yield</code> が使えるようになります。</p>

<p>そのおかげで、JavaScript のコールバック地獄に光が差し込むのです。ああ、さようなら、コールバック地獄。</p>

<h1>7 年ごしで実現した yield</h1>

<p>2006 年、Firefox 2 のリリースと同時に <code>yield</code> は JavaScript 界に<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/New_in_JavaScript/1.7">登場</a>しました。随分と前の話ですね。</p>

<p>登場した当時は JavaScript 界隈でけっこう話題になっていました。</p>

<ul>
<li><a href="http://d.hatena.ne.jp/amachang/20060805/1154743229">JavaScript 1.7 の yield が凄すぎる件について - IT戦記</a></li>
<li><a href="http://piro.sakura.ne.jp/latest/blosxom/webtech/javascript/2006-08-07_yield.htm">Latest topics &gt; JavaScript 1.7のyield文ってなんじゃらほ - outsider reflex</a></li>
<li><a href="http://nanto.asablo.jp/blog/2006/08/12/481381">JavaScript 1.7 の新機能: Days on the Moon</a></li>
</ul>

<p>登場したときにはインパクト大きかったものの、結局 Firefox でしか使えない <code>yield</code> さんは忘れ去られていたわけです。</p>

<p>それがここにきて、<a href="http://wiki.ecmascript.org/doku.php?id=harmony:generators">ECMAScript 6 に yield が入る</a>ことが決定して、V8 に実装されました。となれば、V8 を使ってる Node.js でも自動的に利用できるようになった、という流れであります。</p>

<p>7 年の月日を経て、日の目を見たわけで胸が熱くなります。何はともあれ、Node.js の次のバージョンに <code>yield</code> がやってくるのであります。ヤァヤァヤァ。</p>

<h1>さようなら！ コールバック地獄</h1>

<p>ということで、Node.js の話です。</p>

<p>脱出する前に、皆さんに地獄を見てもらいましょう。</p>

<h2>これが地獄絵図だ！</h2>

<p>サンプルとして、簡単なスクリプトを書いてみました。</p>
<div class="highlight"><pre><code class="js language-js" data-lang="js">var fs = require(&#39;fs&#39;);

// カレント ディレクトリーのファイル一覧を取得する
fs.readdir(&#39;.&#39;, function(err, files) {
    // 先頭のファイルの中身を読み取る
    fs.readFile(files[0], &#39;utf-8&#39;, function(err, data) {
        // 読み取った結果を出力する
        console.log(data);
    });
});
</code></pre></div>
<p>ああ、美しきコールバック地獄。たった 3 つの処理をするだけなのに、コールバックが 2 つもあるわけです。</p>

<p>といっても、Node.js には <code>fs.readdirSync()</code> や <code>fs.readFileSync()</code> といった同期処理をする関数も用意されておりますが、コールバック地獄を再現するために、あえて非同期版を使っております。</p>

<h2>Deferred にすがりつく</h2>

<p>こういうコールバック地獄から逃げるための今までの定石は Deferred だったわけです。jQuery にも実装されてるアレです。</p>

<p>Node.js で Deferred といえば <a href="https://github.com/kriskowal/q">Q</a> が有名らしいので、Q を使って書き直してみました。</p>
<div class="highlight"><pre><code class="js language-js" data-lang="js">var fs = require(&#39;fs&#39;);
var Q = require(&#39;q&#39;);

Q.nfcall(fs.readdir, &#39;.&#39;)
.then(function(files) {
    return Q.nfcall(fs.readFile, files[0], &#39;utf-8&#39;);
})
.then(function(data) {
    console.log(data);
})
.done();
</code></pre></div>
<p>確かにコールバックの階層は押さえられたのですが、かえって読みにくくなったようにも感じます。Deferred をマスターしてしまえば極楽なのかもしれませんが、Deferred は学習コストがそこそこ高いと思うわけです。</p>

<p>また、コードもいまいちすっきりしません。<code>then()</code> でコールバックを繋げるために deferred を返しているのが、何とも読みにくい構造になっています。</p>

<p>Deferred にすがりつくと、一見、幸せになりそうなんだけど、数ヶ月後にソースを読んだときに、ただのコールバック地獄よりも一層深い奈落の底に叩き落される恐れすらあるわけです。</p>

<h2>yield の恩恵を体験する</h2>

<p>で、<code>yield</code> です。</p>

<p>生で <code>yield</code> を扱うのは面倒なので、ライブラリーの力を借りましょう。</p>

<p>Node.js 界で数々の著名モジュールを作ってる TJ Holowaychuk (visionmedia) さんが、さっそく <code>yield</code> を活用するための <a href="https://github.com/visionmedia/co/">co</a> というモジュールを作ってるので使わせてもらいます。</p>

<p>こうなるんだぜ。</p>
<div class="highlight"><pre><code class="js language-js" data-lang="js">var co = require(&#39;co&#39;);
var fs = require(&#39;fs&#39;);

co(function *() {
  var files = yield co.wrap(fs.readdir)(&#39;.&#39;);
  var data = yield co.wrap(fs.readFile)(files[0], &#39;utf-8&#39;);
  console.log(data);
});
</code></pre></div>
<p>同期処理っぽく書いていますが、実はコールバック地獄版と同じ処理になっています。</p>

<p>それぞれの処理で失敗したときには例外が飛ぶので、エラー処理もばっちりです。</p>

<p>ああ、幸せですね。夢が広がりんぐです。いままで面倒だった非同期処理がとっても気楽に書けるのであります。C# の <code>await</code> みたいなことができます。</p>

<p>あ、いちおう細かな点について触れときます。</p>

<ul>
<li>上のソースを実行するには、<a href="http://jenkins.nodejs.org/html/nightlies.html">Node.js の Nightlies builds</a> から v0.11 のバイナリーを拾ってきて、<code>node --harmony-generators foo.js</code> として実行する必要がある。</li>
<li>co の最新のソース (<a href="https://github.com/visionmedia/co/commit/5bd0169604e82c8f9900ad7b6edf95a5cb23df53">co@5bd0169</a>) は 48 行目の <code>gen.send(res);</code> でエラーになるので、<code>gen.next(res);</code> に書き換える必要がある。</li>
</ul>

<h1>yield について簡単に説明するよ</h1>

<p>いちおう <code>yield</code> が何か、という話を簡単に触れておきます。詳しくは <a href="http://wiki.ecmascript.org/doku.php?id=harmony:generators">harmony:generators [ES Wiki]</a> を見てください (ちょっと情報が古いようですが…)。</p>

<p>シンプルな例を書いてみました。</p>
<div class="highlight"><pre><code class="js language-js" data-lang="js">function* N() {
    console.log(&quot;start&quot;);
    yield 1;
    console.log(&quot;after 1&quot;);
    yield 2;
    console.log(&quot;after 2&quot;);
    return 3;
}
</code></pre></div>
<p>まず、<code>yield</code> を使う関数は <code>function</code> ではなく <code>function*</code> で宣言します。(Firefox の先行実装と少し違います)</p>

<p>で、この関数を呼んでみます。</p>
<div class="highlight"><pre><code class="js language-js" data-lang="js">var g = N();
console.log(g);
// {}
</code></pre></div>
<p><code>function*</code> な関数を呼んでも、関数の処理は始まりません。変わりに関数の処理を開始させるためのジェネレーターが返ってきます。</p>

<p>では、ジェネレーターを使ってみましょう。ジェネレーターの <code>next()</code> を呼ぶと、関数の処理を開始できます。</p>
<div class="highlight"><pre><code class="js language-js" data-lang="js">console.log(g.next());
// start
// { value: 1, done: false }
</code></pre></div>
<p><code>yield</code> は <code>return</code> みたいなもので戻り値を返します。ここでは、戻り値の <code>1</code> が <code>value</code> として返ってきています。</p>

<p><code>yield</code> と <code>return</code> の違い、それは、<code>yield</code> は続きから処理を再開できるところにあります。そう、<code>g.next()</code> を呼べばね。</p>
<div class="highlight"><pre><code class="js language-js" data-lang="js">console.log(g.next());
// after 1
// { value: 2, done: false }
</code></pre></div>
<p><code>after 1</code> から処理が再開して、<code>2</code> を返して、再び、関数は中断しました。もう一度 <code>g.next()</code> を呼んでみます。</p>
<div class="highlight"><pre><code class="js language-js" data-lang="js">console.log(g.next());
// after 2
// { value: 3, done: true }
</code></pre></div>
<p><code>return</code> で関数が終わったので、<code>done</code> が <code>true</code> になりました。(この戻り値も Firefox の先行実装と異なります)</p>

<p>こんな感じで、<code>yield</code> を使えば、関数の処理を途中で中断しておくことができます。で、上の co を使ったサンプルを見たら・・・なんとなく実現できそうな気がしてきましたか？</p>

<h1>まとめ</h1>

<ul>
<li>ECMAScript 6 に <code>yield</code> が入った → V8 に実装 → Node.js 0.12 で使える</li>
<li><code>yield</code> を使えばコールバック地獄から脱出できる。</li>
<li>この記事では <a href="https://github.com/visionmedia/co/">co</a> を紹介したけど、便利ライブラリーはまだまだ登場しそう。</li>
</ul>
]]></description>
		</item>

		<item>
			<title>Jekyll で --watch の代わりに Grunt を使ってみるテスト</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/06/25/jekyll-grunt/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/06/25/jekyll-grunt/</guid>
			<pubDate>Tue, 25 Jun 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>このブログでは <a href="https://github.com/mojombo/jekyll">Jekyll</a> を使ってることは何度か書いたのだけど、いままで記事を書くときには <code>jekyll --auto</code> を実行した状態で書いていた。このようにしておくと、ファイルを書き換えたら自動的にサイトをビルドしてくれるようになる。ただ、このコマンドを実行してると CPU がグオーンと音を上げ始め、クアッドコアで CPU 使用率 25% に達するという地球に優しくない状態であった。</p>

<p>原因を調べてみると <code>directory_watcher</code> モジュールが犯人だった。このモジュールは、監視対象のディレクトリー配下の全ファイルに対して、毎秒、<code>File::Stat()</code> を実行する、という富豪的実装になっている。もちろん、ファイルの数が少ないときには問題なく動くんだけども、ファイルの数が増えると CPU を浪費してしまう。</p>

<p>たとえば、このサイトの場合、600 個以上の記事があって、Jekyll が 900 個のファイルを生成する。しかも、<code>.git</code> フォルダーの下には 5,000 個程度のファイルがある。ひどいことに、Jekyll 0.12 までのバージョンは、これらのファイルすべてを監視対象にする。毎秒 6,500 個のファイルを stat するわけだから、当然、CPU は振り切る。</p>

<p>Jekyll 1.0 になって、コマンドも <code>jekyll build --watch</code> に変わって、<code>_site</code> (サイトの出力先) や <code>.git</code> が監視対象から外れたので、パフォーマンスはだいぶ改善した。それでも自分の環境で常時 10% ぐらい CPU を消費し続けている。</p>

<p>ということで、<code>--watch</code> (もしくは <code>--auto</code>) オプションの代わりに、流行の <a href="http://gruntjs.com/">Grunt</a> を使ってみることにした。</p>

<h1>Grunt の設定ファイル</h1>

<p>使っているバージョンやプラグインは次の通り。</p>

<ul>
<li>Jekyll 1.0.3</li>
<li>Grunt 0.4.1

<ul>
<li><code>grunt-shell-spawn</code> プラグイン</li>
<li><code>grunt-contrib-watch</code> プラグイン</li>
</ul></li>
</ul>

<p>最初は、<code>grunt-shell-spawn</code> ではなく <code>grunt-jekyll</code> を使ってたんだけど、<code>grunt-jekyll</code> は Jekyll を実行中の途中経過を表示してくれないので使うのをやめた。</p>

<p>Grunt の使い方については <a href="http://gruntjs.com/getting-started">Getting started - Grunt</a> を見たほうが早いだろうから、ここでは <code>package.json</code> と <code>Gruntfile.js</code> を紹介する。</p>

<h2>package.json</h2>
<div class="highlight"><pre><code class="json language-json" data-lang="json">{
  &quot;name&quot;: &quot;tech-ni&quot;,
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;devDependencies&quot;: {
    &quot;grunt&quot;: &quot;~0.4.1&quot;,
    &quot;grunt-shell-spawn&quot;: &quot;~0.2.4&quot;,
    &quot;grunt-contrib-watch&quot;: &quot;~0.4.4&quot;
  }
}
</code></pre></div>
<h2>Gruntfile.js</h2>
<div class="highlight"><pre><code class="js language-js" data-lang="js">module.exports = function(grunt) {
  grunt.initConfig({
    pkg: grunt.file.readJSON(&#39;package.json&#39;),
    shell: {
      jekyll: {
        command: &#39;jekyll build&#39;,
        options: {
          async: false
        }
      }
    },
    watch: {
      jekyll: {
        files: [&#39;_posts/**/*.md&#39;, &#39;_layout/*.html&#39;, &#39;_includes/*.html&#39;],
        tasks: [&#39;shell:jekyll&#39;]
      }
    }
  });

  grunt.loadNpmTasks(&#39;grunt-shell-spawn&#39;);
  grunt.loadNpmTasks(&#39;grunt-contrib-watch&#39;);

  grunt.registerTask(&#39;default&#39;, [&#39;shell:jekyll&#39;]);
};
</code></pre></div>
<p>(Jekyll 0.12 までを使用している場合は、<code>jekyll build</code> を <code>jekyll</code> で置き換えるべし)</p>

<h1>使い方</h1>

<p><code>grunt watch</code> を実行すると、ファイルの監視を始める。記事や HTML が編集されたら、<code>jekyll build</code> が実行されるようになっている。</p>

<p>しかし、Jekyll で監視するよりも CPU 消費量は小さいが・・・0 ではない・・・!?　と、ここで調べてみて気づいたんだけども、Grunt の watch は、ネイティブ API の <code>fs.watch()</code> を使ってファイルを監視していない!!!　<code>gaze</code> モジュールを使って定期的にファイルを stat しているだけだった。</p>

<p>これでは Ruby の <code>directory_watcher</code> と同じである。</p>

<p>どうやら、Node.js の <code>fs.watch()</code> は Mac OS でファイル名を取れなかった過去があるなど、歴史的に不安定であり、結局、stat で独自に監視する、という手順が一般的になったようだ。なんという罠。</p>
]]></description>
		</item>

		<item>
			<title>ブログのタグ機能が復活したよ</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/06/17/blog-tag/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/06/17/blog-tag/</guid>
			<pubDate>Mon, 17 Jun 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>昨年 9 月に<a href="/ja/blog/2012/09/20/moved-completed/">はてなダイアリーから引っ越した</a>ときにタグ機能が消えてしまっていたのですが、このたび、重い腰をあげて復活させました。</p>

<p>たとえばこの記事の場合、上側の日付の右にタグが 2 つあることにお気づきいただけるでしょうか。タグ名をクリックすると、そのタグがついた記事の一覧が表示できますよ。</p>

<p>ついでに、既存のタグも整理しています。統廃合したり、無意味なものを消したり。整理した結果がこの<a href="/ja/blog/tags/">タグ一覧</a>。</p>

<p><center><img src="http://farm8.staticflickr.com/7325/9056245193_eccb68e139.jpg" width="500" height="225"></center></p>

<p>トップページの記事一覧にもタグを表示するようにしました。</p>

<p><center><img src="http://farm8.staticflickr.com/7387/9055850365_dafbc8f937.jpg" width="500" height="348"></center></p>

<h1>Jekyll のタグ機能をカスタマイズ</h1>

<p><a href="/ja/blog/2012/09/20/moved-completed/">以前に書いた</a>とおり、このブログの出力には <a href="https://github.com/mojombo/jekyll/">Jekyll</a> を使っています。Jekyll 本体には、記事に<a href="/en/blog/2013/04/17/jekyll-pluralize/">タグを設定する機構</a>は用意されているのですが、タグの記事一覧を出力する機能がなくて、自前で実装する必要があります。</p>

<p>そこで、<a href="https://github.com/BlackBulletIV/blackbulletiv.github.com/">blackbulletiv.github.com</a> さんの <a href="https://github.com/BlackBulletIV/blackbulletiv.github.com/blob/master/_plugins/tags_categories.rb">tags_categories.rb</a> を参考にしつつ、「日本語タグだけど URL は英語」「複数ブログ対応」といったあたりを実現するために、いろいろと手をいれてカスタマイズしています。</p>

<p>詳しくは、</p>

<ul>
<li><a href="https://github.com/nitoyon/tech.nitoyon.com/blob/master/_plugins/tags.rb">tags.rb</a></li>
<li><a href="https://github.com/nitoyon/tech.nitoyon.com/blob/master/_plugins/filters/tag_filter.rb">tag_filter.rb</a></li>
<li><a href="https://github.com/nitoyon/tech.nitoyon.com/blob/master/_config.yml">_config.yml</a></li>
</ul>

<p>あたりを見れば雰囲気が分かると思います。</p>

<h1>この後の野望</h1>

<p>このあとやってみたいことは・・・</p>

<ul>
<li>サイト内検索:<br>あると便利なのは間違いないし、検索向け AdSense というのがあるらしい。</li>
<li>サムネール:<br>各記事にサムネールを設定して、それを利用したデザインになると嬉しい。</li>
<li>Web フォント:<br>フラットなデザインが流行しつつあるので、Web フォントを使ったアイコンの利用率も増えてきそう。</li>
<li>2 カラム化:<br>スクロールすると固定するカラムには興味ある。せっかく 1 カラム化したのだけど・・・。</li>
<li>Jekyll 1.0 対応:<br>いつのまにか正式版が出ていたらしい。何が便利になったのか、まだ追えていない。</li>
</ul>

<p>そんなことより、もっと頻繁に記事を書けよ、という感じではありますが・・・。</p>
]]></description>
		</item>

	</channel>
</rss>
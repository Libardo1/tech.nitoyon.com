<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>てっく煮ブログ</title>
		<link>http://tech.nitoyon.com/ja/blog/index.xml</link>
		<description>All Technology is Boiled in This Site.</description>
		<language>ja</language>
		<copyright>Copyright nitoyon.</copyright>
		<lastBuildDate>Sat, 30 Aug 2014 23:13:21 +0000</lastBuildDate>
		<docs>http://blogs.law.harvard.edu/tech/rss</docs>
		<atom:link href="http://tech.nitoyon.com/ja/blog/index.xml" rel="self" type="application/rss+xml" />


		<item>
			<title>JavaScript フレームワークがデータバインディングを実現する４通りの手法</title>
			<link>http://tech.nitoyon.com/ja/blog/2014/07/18/data-binding/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2014/07/18/data-binding/</guid>
			<pubDate>Fri, 18 Jul 2014 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>最近流行りの JavaScript MV* フレームワークは、どれもデータバインディングをサポートしているが、実現方法はフレームワークによって異なる。</p>

<p>この記事では、各種フレームワークが<strong>どのようにモデルの変更を検知しているか</strong>を次の 4 つのパターンに分類して紹介する。</p>

<ol>
<li>モデル クラス方式 (Ember.js、Backbone.js、Ractive.js、Knockout.js など)</li>
<li>力ずく方式 (AngualrJS)</li>
<li>モデル書き換え方式 (Vue.js)</li>
<li>Object.observe 方式 (Polymer)</li>
</ol>

<p>パターン名は私が勝手に名づけたものだけど、このへんの雰囲気が理解できれば、フレームワークごとの個性が分かるだろうし、利用イメージもわきやすいんじゃないかと思っている。</p>

<h1>1. モデル クラス方式</h1>

<p>「モデルとして扱えるのはフレームワークが用意したモデル クラスのインスタンスだけ」という制約を課すのがこの方式。</p>

<p>たとえば、Ember.js では <code>{title: &quot;てっく煮&quot;}</code> という情報をデータバインディングで利用しようと思ったら、次のようにしてモデル クラスのインスタンスを作る必要がある。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">var a = Ember.Object.create({title: &quot;てっく煮&quot;})
console.log(a.get(&#39;title&#39;)); // てっく煮
</code></pre></div>
<p>モデルを変更するには <code>set()</code> メソッドを使う。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">a.set(&#39;title&#39;, &#39;!!!!&#39;);
console.log(a.get(&#39;title&#39;)); // !!!!
</code></pre></div>
<p>当然、フレームワーク側はモデルの値が変更されたことを検知できる。検知したら、あとはフレームワークは新しい値に応じて DOM を書き換えればよい。とてもシンプルな構造だ。</p>

<p>使う側の視点でみると、<code>get()</code> や <code>set()</code> を呼ぶのが面倒だし、ラッパーの API は JavaScript の <code>Object</code> や <code>Array</code> と扱い方が違うし、さらに、既存のモデルがある場合は流用できない (作成・取得・変更処理を全部置き換える必要がある) し・・・、と不便な印象がある。</p>

<p>これ以降の方式は、ネイティブな <code>Object</code> や <code>Array</code> などをモデルとして扱えるように工夫している。</p>

<h2>この方式を採用するフレームワークが多い</h2>

<p>現時点においては、この方式を採用するフレームワークが多数派である。</p>

<p><a href="http://qiita.com/tekkoc/items/eb5ab65524c3e5b4a11c">Backbone.jsなどのライブラリのgetter, setterがダサい理由と、その解消方法 - Qiita</a> によると、Backbone.js、Knockout.js、Ractive.js も同じ方式を採用しているらしい。</p>

<blockquote>
<p>Backbone.js と Ractive.js は <code>get(&quot;hoge&quot;)</code> や <code>set(&quot;hoge&quot;, value)</code> という形式。
Knockout.js は少しマシで <code>hoge()</code> で取得し <code>hoge(value)</code> で設定する形式。</p>
</blockquote>

<h1>2. 力ずく方式</h1>

<p>お次は <a href="(https://angularjs.org/)">AngularJS</a> が採用しているヤツを説明しよう。英語では &quot;dirty check&quot; と呼んでいる。</p>

<p>AngularJS はネイティブな <code>Object</code> や <code>Array</code> をモデルとして渡せるし、独自クラスのオブジェクトだって渡せる。</p>

<p>たとえば、モデルが <code>{title: &#39;てっく煮&#39;}</code> だったとしよう。モデルはネイティブなオブジェクトなので、変更をプッシュ通知で受け取るのは諦めている。</p>

<p>そんな前提なので、AngularJS は <strong>何かあるごとに</strong> <code>title</code> の値が変化したかどうかを自力でチェックする。変化してれば DOM を書き換える。オブジェクトの参照が変わってしまうこともあるので、「前回の値」はディープコピーして覚えている。</p>

<p>とても力技なので処理にはオーバーヘッドがある。ソースコードも複雑になっている。</p>

<h2>「何かあるごとに」はいつか？</h2>

<p>さて、さきほど「何かあるごとに」と書いたが、前回の値と今の値を比較するタイミングはいつだろうか。</p>

<p>正解は「AngularJS 経由で JavaScript のコードを実行したとき」である。</p>

<p>たとえば、ボタンのクリックイベントに関しては <code>&lt;button ng-click=&quot;foo()&quot;&gt;</code> のように書くと、AngularJS 経由で <code>foo()</code> が呼ばれる。<code>setTimeout()</code> の処理であれば、<code>$timeout</code> を使えば AngularJS 経由でコールバックが呼ばれる。</p>

<p>コールバックを読んだとき、モデルの値は変更されるかもしれないし、実際には変更されないかもしれない。変更されたか調べるために、呼び終わったあとに、力ずくで調べるのだ。</p>

<p>直接 DOM イベントを監視するようなときには AngularJS を経由させるのは難しい。そういうときには <code>$scope.$apply()</code> に関数を渡すと、関数を呼んだあとに力ずくの比較処理をやってくれる。</p>

<p>AngularJS を使う側の視点からすると、モデルへの変更を HTML に確実に反映させるには、<code>ng-click</code> や <code>$timeout</code>、<code>$scope.$apply()</code> など使って AngularJS 経由でモデルを変更する必要がある。</p>

<h2>力ずく方式のまとめ</h2>

<ul>
<li><code>Object</code> や <code>Array</code> や独自クラスのインスタンスをモデルにできる</li>
<li>比較処理がトリガーされるかどうかを意識する必要がある</li>
<li>比較処理のオーバーヘッドがある</li>
</ul>

<h1>3. モデル書き換え方式</h1>

<p>こちらは <a href="http://vuejs.org/">Vue.js</a> が採用している方式である。</p>

<p>Vue.js もネイティブな <code>Object</code> や <code>Array</code> をモデルとして渡せる。</p>

<p>たとえば、オブジェクトのキーの変更を検知するために、キーを (ECMAScript 5 的な) プロパティーに書き換える。配列の変更を検知するために、<code>Array.prototype</code> を書き換えて <code>push()</code> メソッドなどを置き換える。</p>

<p>AngularJS のように力ずくの比較は行わないので動作は速いのが利点。Vue.js のサイトでも <a href="http://vuejs.org/perf/">他のフレームワークより速いこと</a> を自慢している。</p>

<p>一方の弱点は、次の通り。</p>

<ul>
<li>モデルとして受け取ったオブジェクトを書き換えてしまう</li>
<li>完全に変更を検知できない (完全に検知できないので、一部の変更処理については、<code>$set()</code> や <code>$add()</code> といったメソッドを使う必要がある。ラッパー オブジェクト的な要素が残っているといえる)。</li>
</ul>

<p>詳しくは <a href="/ja/blog/2014/06/30/vue-js-hook/">Vue.js が data に渡した値を激しく書き換える件について</a> に書いたので見てほしい。</p>

<h1>4. Object.observe() 方式</h1>

<p>現在、ECMAScript には「オブジェクトの変更を検知する」という機能を持つ <code>Object.observe()</code> というメソッドが提案されていて、仕様決定に先立って <a href="http://www.chromestatus.com/features/6147094632988672">Google Chrome 36 ではデフォルトで有効</a> になっている。</p>

<p>ためしに Google Chrome 36 の JavaScript コンソールで使ってみる。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">&gt; a = {foo: 1}
&gt; Object.observe(a, function(changes) { console.log(changes); })
&gt; a.foo = 3
  [Object]
      0: Object
          name: &quot;foo&quot;
          object: Object
              foo: 3
          oldValue: 1
          type: &quot;update&quot;
&gt; a.bar = 10
  [Object]
      0: Object
          name: &quot;bar&quot;
          object: Object
              bar: 10
              foo: 3
          type: &quot;add&quot;
</code></pre></div>
<p>まさにデータバインディングで使ってくれといっているようなメソッドである。</p>

<p><a href="(http://www.polymer-project.org/)">Polymer</a> は <code>Object.observe()</code> を前提としている。さらに、先ほどから紹介していた各種ライブラリーについても、AngularJS は 2.0 での対応を<a href="http://blog.angularjs.org/2014/03/angular-20.html">検討している</a> し、Vue.js は v0.11.x で<a href="https://github.com/yyx990803/vue/issues/78">対応予定</a> となっている。</p>

<p>ECMAScript に <code>Object.observe()</code> が取り込まれれば、ここまで紹介したようなややこしいデータバインディングの仕組みは不要となる。まさに、データバインディングのための API であるが、ECMAScript 6 にも入っておらず、すべてのブラウザーで使えるようになるには時間がかかりそうだ。
<code>Object.observe()</code> については以下のページが詳しかった。</p>

<ul>
<li><a href="http://d.hatena.ne.jp/jovi0608/20121206/1354762082">次世代JavaScriptでデータバインディング： Object.observe() を試す - ぼちぼち日記</a></li>
<li><a href="http://www.html5rocks.com/en/tutorials/es7/observe/">Data-binding Revolutions with Object.observe() - HTML5 Rocks</a></li>
</ul>

<h1>まとめ</h1>

<p>MV* フレームワークが「どのようにモデルの変更を検知しているか」を 4 通り紹介した。</p>

<ul>
<li>オブジェクト指向的なモデル クラスを使う方式が主流。</li>
<li><a href="(https://angularjs.org/)">AngularJS</a> や <a href="http://vuejs.org/">Vue.js</a> はネイティブな値をモデルとして扱うために頑張っている。</li>
<li><code>Object.observe()</code> が使えるようになれば、フレームワークの苦しみが減る。<a href="(http://www.polymer-project.org/)">Polymer</a> はそこを見据えている。</li>
</ul>
]]></description>
		</item>

		<item>
			<title>Vue.js が data に渡した値を激しく書き換える件について</title>
			<link>http://tech.nitoyon.com/ja/blog/2014/06/30/vue-js-hook/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2014/06/30/vue-js-hook/</guid>
			<pubDate>Mon, 30 Jun 2014 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>最近、JavaScript の MV* フレームワークの中で <a href="http://vuejs.org/">Vue.js</a> が少しずつ注目を浴びてきているようであります。</p>

<ul>
<li><a href="http://www.infiniteloop.co.jp/blog/2014/06/5min_vuejs/">5分でわかるVue.jsと、jQueryで頑張ってはいけない理由 | 株式会社インフィニットループ技術ブログ</a></li>
<li><a href="http://qiita.com/icoxfog417/items/49f7301be502bc2ad897">Vue.jsから手軽に始めるJavaScriptフレームワーク - Qiita</a></li>
<li><a href="http://mizchi.hatenablog.com/entry/2014/02/13/153742">軽量でパワフルなデータバインディングMVVM, vue.jsで遊んでみた - mizchi&#39;s blog</a></li>
</ul>

<p>そんなわけで、自分も Vue.js (v0.10.5) を触ってみたのですが、<code>data</code> で渡した値を激しく書き換えるところに面食らったので記事にしておきます。</p>

<h1>自作クラスのオブジェクトを Vue.js に渡すと壊される</h1>

<p>何らかのビジネスロジックを持ったモデルを作って、それを Vue.js のデータバインディングで HTML に反映しようすると破綻します。</p>

<p>簡単な例として、よくある <code>Animal</code> クラスを作ったとしましょう。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">function Animal(name) {
  this.name = name;
};
Animal.prototype.say = function() {
  console.log(this.name);
};

var dog = new Animal(&#39;dog&#39;);
dog.bark(); // I&#39;m a dog
</code></pre></div>
<p>まぁ、当然動きます。</p>

<p>では、<code>dog</code> をデータバインディングで HTML に表示してみます。</p>
<div class="highlight"><pre><code class="language-html" data-lang="html">&lt;body&gt;
&lt;p&gt;{{animal.name}}&lt;/p&gt;
&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
function Animal(name) {
  this.name = name;
};
Animal.prototype.bark = function() {
  console.log(&quot;I&#39;m a &quot; + this.name);
};

var dog = new Animal(&#39;dog&#39;);
dog.bark(); // I&#39;m a dog

new Vue({
  el: &quot;body&quot;,
  data: { animal: dog }
});
&lt;/script&gt;
&lt;/body&gt;
</code></pre></div>
<p>期待通り、<code>{{animal.name}}</code> の部分が <code>dog</code> になります。</p>

<p>JavaScript コンソールにて、<code>dog.name = &quot;dog!!!&quot;</code> とすると、HTML は <code>dog!!!</code> に書き換わります。ちゃんと動いてるようにみえますね。</p>

<p>しかし・・・JavaScript コンソールで <code>dog.bark()</code> と入力すると・・・。</p>

<p><center><img src="https://farm4.staticflickr.com/3912/14348658487_b188ef6abc_o.png" width="477" height="195"></center></p>

<p>さっきまで動いていたコードが動かなくなりました・・・。恐怖！</p>

<h2>激しく書き換えられた犬と書き換えられる前の猫</h2>

<p>Vue.js では、data に渡した値を書き換えます。激しく書き換えます。</p>

<p>ためしに、dog を表示してみます。</p>

<p><center><img src="https://farm4.staticflickr.com/3901/14348658407_745e69d963_o.png" width="411" height="149"></center></p>

<p>ははは。プロトタイプ (<code>__proto__</code>) が別のオブジェクトになってしまっていますよ。<code>bark()</code> がなくてエラーになるのも無理はありません。</p>

<p>ちなみに、普通にインスタンス化した猫はこうなってますよ。当たり前だけども、<code>bark()</code> あります。</p>

<p><center><img src="https://farm4.staticflickr.com/3842/14533637664_2e67ac0ca8_o.png" width="410" height="104"></center></p>

<p><a href="http://vuejs.org/">Vue.js</a> さんは、<code>new Vue()</code> の <code>data</code> に渡した値を書き換えてしまうのです。恐ろしい子！</p>

<h2>なぜにあなたは書き換える？</h2>

<p>Vue.js は <code>data</code> に変更が加わったことを検知するために、data の値を書き換えているようです。</p>

<p>たとえば、<code>dog.name</code> というキーは ECMAScript 5 のプロパティーに置き換えられます。<code>get name</code> と <code>set name</code> が定義されてますね。</p>

<p><center><img src="https://farm4.staticflickr.com/3901/14348658407_745e69d963_o.png" width="411" height="149"></center></p>

<p>このようにすることで、<code>dog.name</code> が書き換えられた瞬間に <code>set name</code> が呼ばれるので、Vue.js はデータの書き換えを検知するわけでございます。</p>

<p>じゃ、なんで prototype まで置き換えるのか。</p>

<p><a href="http://vuejs.org/guide/list.html">Displaying a List - vue.js</a> によると、ECMAScript 5 ではキーの追加・削除は検知できないので、<code>$add</code> と <code>$delete</code> を使ってくれ、ということのようです (ざっくりと日本語訳してみた)。</p>

<blockquote>
<p>In ECMAScript 5 there is no way to detect when a new property is added to an Object, or when a property is deleted from an Object. To counter for that, observed objects will be augmented with two methods: $add(key, value) and $delete(key). These methods can be used to add / delete properties from observed objects while triggering the desired View updates.</p>

<blockquote>
<p>ECMAScript 5 では、Object に対するプロパティーの追加や削除を検出する方法がないんだぜ。だから、監視対象の Object には $add(key, value) と $delete(key) の 2 つのメソッドを追加するんだよ。このメソッドを使ってプロパティーを追加・削除すると、View への反映をトリガーできるんだぜ。</p>
</blockquote>
</blockquote>

<p><code>$add</code> と <code>$delete</code> を追加するのには、そういう理由があったわけですね。</p>

<p>さて、自作のクラスを渡せないのは明らかにバグっぽいので修正したいところではあります。</p>

<p>(追記) よくよく公式ドキュメントの <a href="http://vuejs.org/api/instantiation-options.html#data">Instantiation Options - vue.js</a> を読んでみると</p>

<blockquote>
<p>The object must be JSON-compliant (no circular references)</p>

<blockquote>
<p><code>data</code> に渡すオブジェクトは JSON の仕様に従っていて、循環参照してないものにしてね</p>
</blockquote>
</blockquote>

<p>とあるので、自作クラスのオブジェクトを渡せないのは仕方ないようです。</p>

<h1>Array も激しく書き換える</h1>

<p>Vue.js が激しく書き換えるのは Object だけではありません。配列も猛烈に書き換えます。</p>

<p>そのことは、ドキュメントの <a href="http://vuejs.org/guide/list.html">Displaying a List - vue.js</a> からも伝わってきます (先ほどと同じくざっくりと日本語訳してる)。</p>

<blockquote>
<p>Under the hood, Vue.js intercepts an observed Array&#39;s mutating methods (<code>push()</code>, <code>pop()</code>, <code>shift()</code>, <code>unshift()</code>, <code>splice()</code>, <code>sort()</code> and <code>reverse()</code>) so they will also trigger View updates.</p>

<p>You should avoid directly setting elements of a data-bound Array with indices, because those changes will not be picked up by Vue.js. Instead, use the agumented <code>$set()</code> method.</p>

<blockquote>
<p>内部的に、Vue.js は Array の状態を変更するメソッド (<code>push()</code>, <code>pop()</code>, <code>shift()</code>, <code>unshift()</code>, <code>splice()</code>, <code>sort()</code> and <code>reverse()</code>) の呼び出しを監視して、View が更新されるように処理をしてるんだぜ。</p>

<p>インデックスを指定しての値を変更すると Vue.js が検知できないのでやめてほしいよ。その代り、<code>$set()</code> メソッドってのを用意したから、こっちを使ってほしいんだぜ。</p>
</blockquote>
</blockquote>

<p>まぁ、こんな感じで、扱うには少し工夫が必要であります。</p>

<h1>data に渡した Object が console.log() で見にくい問題の対処方法</h1>

<p><code>data</code> に渡した値を <code>console.log()</code> すると getter, setter の山になるわけで、値がどうなっているかを確認しにくいですね。</p>

<p>これをなんとかするには <code>JSON.stringify</code> を使う回避方法が <a href="http://vuejs.org/api/instantiation-options.html#data">Instantiation Options - vue.js</a> にて示されております。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">var vm = new Vue({
  el: &quot;body&quot;,
  data: {
    animal: { name: &quot;foo&quot; }
  }
});

console.log(JSON.stringify(vm.$data));
// {&quot;animal&quot;:{&quot;name&quot;:&quot;foo&quot;}} 
</code></pre></div>
<p>やや面倒だし、巨大なデータを渡したときは見つけるのが大変そうであります。そんなときは、さらに <code>JSON.parse()</code> で Object に変換すればよい。</p>

<p>面倒だから、Object に復元する関数でも作っておくとよいでしょう。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">function deepCopy(o) {
  return JSON.parse(JSON.stringify(o));
}

console.log(deepCopy(vm.$data));
</code></pre></div>
<h1>Object.observe に期待</h1>

<p>こんな面倒なことになっているのも、Vue.js が ECMAScript 5 の世界で頑張っているからです。</p>

<p>ECMAScript に提案されている <code>Object.observe()</code> が使える世界になれば、Object や Array の置き換えも不要になるし、Vue.js の設計もシンプルになることでしょう。</p>

<p><a href="http://vuejs.org/">Vue.js</a> の <a href="https://github.com/yyx990803/vue/issues/78">ロードマップ</a> には 0.11 で <code>Object.observe()</code> が使えるなら使うようにする、と書いてあります。</p>

<h1>まとめ</h1>

<ul>
<li><a href="http://vuejs.org/">Vue.js</a> はオブジェクトの監視を行うために、Object のキーをプロパティーに置き換えたり、<code>Array.push()</code> を置き換えたりする</li>
<li>この努力は ECMAScript 5 の限界ゆえ</li>
<li>ECMAScript に <code>Object.observe()</code> がやってきたら、<a href="http://vuejs.org/">Vue.js</a> の実装もシンプルになるし、もっと楽な API になる</li>
</ul>
]]></description>
		</item>

		<item>
			<title>Ruby で HTTPS 接続するときの証明書で悩んだ話</title>
			<link>http://tech.nitoyon.com/ja/blog/2014/05/30/ruby-https-cert/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2014/05/30/ruby-https-cert/</guid>
			<pubDate>Fri, 30 May 2014 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>flickr の API が HTTPS のみになるというので、<a href="/ja/blog/2012/11/06/flickr-auto-update/">以前作ったスクリプト</a>に手を入れようとしたら無駄に手こずったので、ググって得た知見をメモしておく。</p>

<h1>Ruby 1.8 系で証明書を検証しない問題</h1>

<p>上記のスクリプトは、さくらのレンタルサーバーにて Ruby で動かしている。</p>

<p>2014 年にどうかという話だけど、Ruby のバージョンは 1.8.7 である・・・。</p>

<p>Net::HTTP で https に接続したら</p>

<blockquote>
<p>warning: peer certificate won&#39;t be verified in this SSL session</p>
</blockquote>

<p>という警告が出てきて困ったので調べてみた。</p>

<p>つかったコードはこんなやつ。</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">require &#39;net/https&#39;
https = Net::HTTP.new(&#39;www.google.com&#39;, 443)
https.use_ssl = true
https.start { |h|
}
</code></pre></div>
<h2>警告が出る理由</h2>

<p>Ruby 1.8 の時点では上記のようなコードで HTTPS 接続したときには、デフォルトでは証明書を検証しないポリシーになっていた。</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">    unless @ssl_context.verify_mode
      warn &quot;warning: peer certificate won&#39;t be verified in this SSL session&quot;
      @ssl_context.verify_mode = OpenSSL::SSL::VERIFY_NONE
    end
</code></pre></div>
<p>(<a href="https://github.com/ruby/ruby/blob/v1_8_7/lib/net/http.rb#L563-566">https://github.com/ruby/ruby/blob/v1_8_7/lib/net/http.rb#L563-566</a> より)</p>

<p>デフォルトで証明書検証しないというのは罠なので、そのことを教えようとしている warning のようだ。</p>

<h2>警告を消す方法</h2>

<p>上のコードをみたら分かる通り、明示的にポリシーを指定すれば警告は消える。</p>

<ul>
<li>証明書を検証したい場合: <code>https.verify_mode = OpenSSL::SSL::VERIFY_PEER</code> を追加する</li>
<li>証明書を検証したくない場合: <code>https.verify_mode = OpenSSL::SSL::VERIFY_NONE</code> を追加する</li>
</ul>

<h2>1.9 系で変わってる</h2>

<p>ちなみに、「デフォルトでは証明書を検証しない」という挙動は、1.9 系では<a href="https://github.com/ruby/ruby/commit/c6920177f3e561f779f54534e511f0c9f0de6edd">修正されている</a>。</p>

<h1>ルート証明書どうするの問題</h1>

<p>証明書を検証する設定にしたら、「証明書の検証に失敗したぜ」というような例外がでるようになった。</p>

<blockquote>
<p>OpenSSL::SSL::SSLError: SSL_connect returned=1 errno=0 state=SSLv3 read server certificate B: certificate verify failed</p>
</blockquote>

<p>これはどうも、自分の環境にルート証明書が正しく入ってないっぽい。</p>

<p>いかんせんレンタルサーバーなので、何ともできない。仕方がないので、どこかからルート証明書を取ってくることにした。</p>

<p>ググると <a href="http://curl.haxx.se/docs/caextract.html">http://curl.haxx.se/docs/caextract.html</a> が有名っぽい。cURL の人が mozilla.org のデータを PEM 形式に変換してくれているヤツ。</p>

<p>ここにある cacert.pem を拾ってきて、<code>ca_file</code> に cacert.pem のパスを指定すればおしまい。</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">require &#39;net/https&#39;
https = Net::HTTP.new(&#39;www.google.com&#39;, 443)
https.use_ssl = true
https.verify_mode = OpenSSL::SSL::VERIFY_PEER
https.ca_file = &#39;/path/to/cacert.pem&#39;
https.start { |h|
}
</code></pre></div>
<h1>まとめ</h1>

<p>新しい OS を新規セットアップした場合はたぶんまったく問題にならないであろうことに苦しめられつつ、以上の無駄な知見を得た。</p>

<p>flickr の更新用に使っていた flickraw というライブラリーは <code>verify_mode</code> や <code>ca_file</code> を指定するオプションがなかったので、<a href="https://github.com/hanklords/flickraw/pull/75">「追加してね」という pull request</a> を投げたらマージしてもらえた。めでたし。</p>

<p>あと、<a href="http://www.happytrap.jp/blogs/2010/02/23/2919/">Ruby 「warning: peer certificate won&#8217;t be verified in this SSL session」 | HAPPY*TRAP</a> が非常に役に立った。ありがたや。</p>
]]></description>
		</item>

		<item>
			<title>D3.js で自作クラスにイベント発行機能を追加する</title>
			<link>http://tech.nitoyon.com/ja/blog/2014/04/02/d3-event-dispatch/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2014/04/02/d3-event-dispatch/</guid>
			<pubDate>Wed, 02 Apr 2014 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>D3.js を使っていると、自作クラスのイベント発行も D3.js を使いたくなる。そんなときには <a href="https://github.com/mbostock/d3/wiki/Internals#d3_dispatch"><code>d3.dispatch</code></a> を使うとよい。</p>

<h1>使う側の実装</h1>

<p>イメージしやすいように、最初に使う側のコードを示しておく。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">var myButton = new MyButton(d3.select(&quot;button&quot;));
myButton.on(&quot;myclick&quot;, function(e) {
  alert(e.name); // MyEvent
  console.log(this, e); // MyButton, { name: &quot;MyEvent&quot;, MouseEvent }
});
</code></pre></div>
<p>こんな感じで、自作の <code>MyButton</code> クラスで <code>myclick</code> イベントを発行したい。</p>

<h1>MyButton の実装</h1>

<p>では、さっそく <code>MyButton</code> の実装。最初はコンストラクターから。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">function MyButton(selector) {
  // ボタンがクリックされたときに onClick を呼ぶ
  selector.on(&#39;click&#39;, this.onClick.bind(this));

  // myclick イベントを発行する dispatcher を作成
  this.dispatcher = d3.dispatch(&quot;myclick&quot;);
}
</code></pre></div>
<p><code>d3.dispatch</code> の引数に「発行したいイベント名」を渡して、dispatcher オブジェクトを取得している。複数のイベントを出す場合は <code>d3.dispatch(&quot;event1&quot;, &quot;event2&quot;);</code> のようにする。</p>

<p>dispatcher オブジェクトには次の 2 種類のメソッドが定義される。</p>

<ul>
<li>イベントを発行するためのメソッド (イベント名と同じ名前)</li>
<li>イベントを監視するための <code>on(type, listener)</code></li>
</ul>

<h2>イベント発行処理</h2>

<p>イベントの発行処理からみていこう。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">MyButton.prototype.onClick = function() {
  this.dispatcher.myclick.call(this, {
    name: &quot;MyEvent&quot;,
    event: d3.event
  });
};
</code></pre></div>
<p>ボタンがクリックされたときに <code>myclick</code> イベントを発行している。今回は <code>myclick</code> イベントと名付けたので、<code>dispatcher.myclick()</code> を実行すれば、<code>myclick</code> イベントが発火する。引数はそのままリスナーに渡される。</p>

<p><code>Function.call()</code> を使っているのは、リスナー側で <code>this</code> が <code>dispatcher</code> ではなく <code>MyButton</code> にしたいから。</p>

<h2>on の実装</h2>

<p>次に <code>MyButton.prototype.on()</code> の実装。こちらは、単純に <code>dispatcher.on()</code> に中継している。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">MyButton.prototype.on = function() {
  return this.dispatcher.on.apply(this.dispatcher, arguments);
};
</code></pre></div>
<p>単純に中継しているだけなので、もっと簡略化して書けそうである。そう、<a href="https://github.com/mbostock/d3/wiki/Internals#d3_rebind"><code>d3.rebind</code></a> を使えばね。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">function MyButton(selector) {
  selector.on(&#39;click&#39;, this.onClick.bind(this));
  this.dispatcher = d3.dispatch(&quot;myclick&quot;);

  // !!! ここが追加 !!!
  d3.rebind(this, this.dispatcher, &quot;on&quot;);
}
</code></pre></div>
<p>コンストラクターに 1 行追加したおかげで、<code>MyButton.prototype.on()</code> が不要になった。コードは短くなったが、<code>d3.rebind()</code> の学習コストが増えたので微妙なところではある。</p>

<p>ちなみに、<code>d3.rebind()</code> は 11 行の短い関数。上で手で書いたのとだいたい同じ動作になるのが分かるはず。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">d3.rebind = function(target, source) {
  var i = 1, n = arguments.length, method;
  while (++i &lt; n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
  return target;
};
function d3_rebind(target, source, method) {
  return function() {
    var value = method.apply(source, arguments);
    return value === source ? target : value;
  };
}
</code></pre></div>
<p>これで目的は完遂。めでたし。</p>

<p>完成後の全体のソースコードを貼っておく。</p>
<div class="highlight"><pre><code class="language-html" data-lang="html">&lt;!DOCTYPE html&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;script src=&quot;http://d3js.org/d3.v3.min.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;body&gt;
&lt;button&gt;click me&lt;/button&gt;

&lt;script&gt;
function MyButton(selector) {
  selector.on(&#39;click&#39;, this.onClick.bind(this));
  this.dispatcher = d3.dispatch(&quot;myclick&quot;);
  d3.rebind(this, this.dispatcher, &quot;on&quot;);
}

MyButton.prototype.onClick = function() {
  this.dispatcher.myclick.call(this, {
    name: &quot;MyEvent&quot;,
    event: d3.event
  });
};

var myButton = new MyButton(d3.select(&quot;button&quot;));
myButton.on(&quot;myclick&quot;, function(e) {
  alert(e.name); // MyEvent
  console.log(this, e); // MyButton, { name: &quot;MyEvent&quot;, MouseEvent }
});
&lt;/script&gt;
&lt;/body&gt;
</code></pre></div>
<h1>複数イベント登録の罠</h1>

<p>D3.js のイベントで厄介な点は、1 つのイベント名に複数のイベントを登録できないところ。新しいイベントを登録したら、古いほうは消される…。DOM イベントと同じ感覚でいると混乱してしまう。</p>

<p>これを回避するには <code>myclick.foo</code> や <code>myclick.bar</code> のように optional namespace をつけてイベント登録する必要がある。くわしくは <a href="https://github.com/mbostock/d3/wiki/Selections#on"><code>selection.on</code></a> を参照あれ。</p>
]]></description>
		</item>

		<item>
			<title>Git for Windows でレポジトリー上の CR LF を LF に変換する手順</title>
			<link>http://tech.nitoyon.com/ja/blog/2014/03/28/git-crlf-to-lf/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2014/03/28/git-crlf-to-lf/</guid>
			<pubDate>Fri, 28 Mar 2014 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>Git for Windows では改行コードが「レポジトリー上は LF」「ワーキング ディレクトリーは CR LF」となるように、git config の <code>core.autocrlf</code> が <code>true</code> となる状態でインストールされる (インストーラーでデフォルトの [Checkout Windows-style, commit Unix-style line endings] を選択した場合)。</p>

<p>Windows 以外の文化圏の人は CR LF を見ると CR がゴミに見えるので、妥当な設定だろう。</p>

<p>標準設定の <code>autocrlf</code> が <code>true</code> のときに、レポジトリー上に CR LF なファイルが紛れ込んでいないか調べたり、紛れ込んだ CR LF を LF に変換したかったのだけど、この手順が少しややこしかったので記事にまとめておく。</p>

<p>(<code>autocrlf</code> を <code>false</code> にして clone したらすぐに分かる…という話なんだけど、大きなレポジトリーを clone しなおすのはストレスフルなので、その場で確認する手順を調べてみた)</p>

<p>※ Git for Windows は 1.9 と 1.8.4 で検証した</p>

<h1>レポジトリー上に CR LF のファイルがあるか調べたい</h1>

<p>レポジトリー上のファイルの改行コードは LF で統一しているつもりなのに、CR LF のファイルが混ざりこんでたら悲しい。</p>

<p><code>autocrlf</code> が <code>true</code> な状態で、レポジトリー上に CR LF のファイルが入ってないか調べるには次のようにする。</p>
<div class="highlight"><pre><code class="language-console" data-lang="console">$ git grep --cached -I $&#39;\r&#39;
</code></pre></div>
<p>オプションの補足:</p>

<ul>
<li><code>--cached</code> を指定しないと、ワーキング ディレクトリー上のファイルから CR を探してしまう。つまり、<code>core.autocrlf</code> が <code>true</code> な状態では、すべての改行がヒットしてしまう。</li>
<li><code>-I</code> でバイナリー ファイルを無視している。</li>
</ul>

<h2>実行例</h2>

<p><a href="https://gist.github.com/nitoyon/9808563">https://gist.github.com/nitoyon/9808563</a> に CRLF と LF のファイルの 2 つがあるレポジトリーを用意してみた。</p>

<p><code>core.autocrlf</code> が <code>true</code> な状態で clone すると、両方のファイルが CRLF でチェックアウトされる。</p>

<p>この状態で上記のコマンドを実行してみると、CR LF のほうだけが引っかかる。</p>
<div class="highlight"><pre><code class="language-console" data-lang="console">$ git grep --cached -I $&#39;\r&#39;
crlf-test.txt:End of Line Character Test^M
crlf-test.txt:^M
crlf-test.txt:Which do you like CR LF or LF?^M
crlf-test.txt:^M
crlf-test.txt:This file uses &quot;CR LF&quot;!!!!^M
crlf-test.txt:^M
crlf-test.txt:Clone me!^M
</code></pre></div>
<p>めでたし。</p>

<h1>レポジトリー上の CR LF を LF に変換したい</h1>

<p>万が一、レポジトリー上に CR LF を発見したら、LF に統一しよう。</p>

<p>こちらも <code>core.autocrlf</code> が <code>true</code> になっている状態からの手順を示しておく。</p>

<ol>
<li><p>一時的に <code>core.autocrlf</code> を <code>false</code> に設定する。</p>
<div class="highlight"><pre><code class="language-console" data-lang="console">$ git config core.autocrlf false
</code></pre></div></li>
<li><p>LF でチェックアウトするために、ワーク ディレクトリーのファイルを全部削除してから、チェックアウトする (一度削除しないと反映されないことがあった!!)。</p>
<div class="highlight"><pre><code class="language-console" data-lang="console">$ rm -rf .
$ git checkout .
</code></pre></div></li>
<li><p>CR LF になっているファイルを何らかのエディターで LF に変換する。</p></li>
<li><p>コミットする。</p>
<div class="highlight"><pre><code class="language-console" data-lang="console">$ git add . &amp;&amp; git commit
</code></pre></div></li>
<li><p><code>autocrlf</code> の設定を戻す。</p>
<div class="highlight"><pre><code class="language-console" data-lang="console">$ git config core.autocrlf true
</code></pre></div></li>
</ol>

<h2>実行例</h2>

<p>再び、<a href="https://gist.github.com/nitoyon/9808563">https://gist.github.com/nitoyon/9808563</a> で試してみる。</p>

<p>作業完了後の diff はこんな感じになる。</p>
<div class="highlight"><pre><code class="language-diff" data-lang="diff">$ git diff HEAD~
diff --git a/crlf-test.txt b/crlf-test.txt
index ad9608a..85a3c62 100644
--- a/crlf-test.txt
+++ b/crlf-test.txt
@@ -1,7 +1,7 @@
-End of Line Character Test
-
-Which do you like CR LF or LF?
-
-This file uses &quot;CR LF&quot;!!!!
-
-Clone me!
+End of Line Character Test
+
+Which do you like CR LF or LF?
+
+This file uses &quot;CR LF&quot;!!!!
+
+Clone me!
</code></pre></div>
<p>違いが分かりにくい diff が表示されていて悲しい。git の diff では CR があると <code>^M</code> として警告してくれるはずなんだけど、<code>^M</code> が表示されるのは <code>+</code> から始まる行だけのようだ。今回のような「CR LF が LF になった」ケースでは CR があるのは <code>-</code> の行なので <code>^M</code> は表示してくれない…。</p>

<p><code>--ignore-space-at-eol</code> を指定して行末スペースの変更を無視したら、diff が消え去るので、うまくいっていると信じる。</p>
<div class="highlight"><pre><code class="language-console" data-lang="console">$ git diff --ignore-space-at-eol HEAD~
</code></pre></div>
<p><code>git grep</code> でも CR を見つけられなくなるので、うまくいっていると信じる。</p>
<div class="highlight"><pre><code class="language-console" data-lang="console">$ git grep --cached -I $&#39;\r&#39;
</code></pre></div>
<h1>まとめ</h1>

<p>Windows はつらいよ。</p>
]]></description>
		</item>

	</channel>
</rss>